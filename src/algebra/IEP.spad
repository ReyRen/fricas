)abbrev package IEP InnerEigenPackage
++ Author: P. Gianni
++ Description:
++  This is a package for the exact computation of eigenvalues and
++  eigenvectors.  This package works for matrices with coefficients from
++  a field over which we can factor polynomials.  Eigenvalues in base
++  field are always explicitly computed while the other are expressed
++  in terms of their minimal polynomial.
InnerEigenPackage(F : Field) : Exports == Implementation
 where
   UP   ==> SparseUnivariatePolynomial(F)
   M     ==> Matrix(F)
   NNI   ==> NonNegativeInteger
   AV    ==> Vector(UP)

   Eigenvalue  ==> Union(F, UP)
   EigenForm ==> Record(eigval : Eigenvalue, eigmult : NNI, eigvec : List AV)
   GenEigen  ==> Record(eigval : Eigenvalue, geneigvec : List AV)

   Exports == with

     characteristicPolynomial :  M ->  UP
       ++ characteristicPolynomial(m) returns the characteristic
       ++ polynomial of the matrix m

     eigenvalues : (M, UP -> Factored(UP)) ->  List Eigenvalue
       ++ eigenvalues(m, fac) returns the eigenvalues of the
       ++ matrix m.  Eigenvalues in base field are given
       ++ explicitely, other are represented by mininal polynomial.
       ++ fac is a factorizer for polynomials over F.

     eigenvector : (Eigenvalue, M)  ->  List AV
       ++ eigenvector(eigval, m) returns the
       ++ eigenvectors belonging to the eigenvalue eigval
       ++ for the matrix m.

     generalizedEigenvector : (Eigenvalue, M, NNI, NNI) -> List AV
       ++ generalizedEigenvector(alpha, m, k, g)
       ++ returns the generalized eigenvectors
       ++ of the matrix relative to the eigenvalue alpha.
       ++ The integers k and g are respectively the algebraic and the
       ++ geometric multiplicity of the eigenvalue alpha.

     generalizedEigenvector  : (EigenForm, M) -> List AV
       ++ generalizedEigenvector(eigen, m)
       ++ returns the generalized eigenvectors
       ++ of the matrix relative to the eigenvalue eigen, as
       ++ returned by the function eigenvectors.

     generalizedEigenvectors : (M, UP -> Factored(UP)) -> List GenEigen
       ++ generalizedEigenvectors(m, fac) returns the generalized
       ++ eigenvectors of the matrix m.
       ++ fac is a factorizer for polynomials over F.

     eigenvectors : (M, UP -> Factored(UP)) ->  List(EigenForm)
       ++ eigenvectors(m, fac) returns the eigenvalues and eigenvectors
       ++ for the matrix m.
       ++ The eigenvalues in base field and corresponding eigenvectors
       ++ are explicitely computed, while the other eigenvalues
       ++ are given via their minimal polynomial and the corresponding
       ++ eigenvectors are expressed in terms of a "generic" root of
       ++ such a polynomial.
       ++ fac is a factorizer for polynomials over F.

     if F has PolynomialFactorizationExplicit then

       eigenvalues : M -> List Eigenvalue
         ++ eigenvalues(m) returns the eigenvalues of the matrix m.
       eigenvectors : M ->  List(EigenForm)
         ++ eigenvectors(m) returns the eigenvalues and eigenvectors
         ++ for the matrix m.
         ++ The eigenvalues in base field and corresponding eigenvectors
         ++ are explicitely computed, while the non rational ones
         ++ are given via their minimal polynomial and the corresponding
         ++ eigenvectors are expressed in terms of a "generic" root of
         ++ such a polynomial.
       generalizedEigenvectors  : M -> List GenEigen
         ++ generalizedEigenvectors(m) returns the generalized
         ++ eigenvectors of the matrix m.

   Implementation == add

     if F has PolynomialFactorizationExplicit then

         eigenvalues(m) == eigenvalues(m, factorPolynomial$F)

         eigenvectors(m) == eigenvectors(m, factorPolynomial$F)

         generalizedEigenvectors(m) ==
             generalizedEigenvectors(m, factorPolynomial$F)

     -- local functions
     intRatEig : (F, M, NNI) -> List AV
     intAlgEig : (UP, M, NNI) -> List AV
     genEigForm : (EigenForm, M) -> GenEigen

     ---- next functions needed for defining  ModularField ----
     reduction(u : UP, p : UP) : UP == u rem p

     merge(p : UP, q : UP) : Union(UP, "failed") ==
         p = q => p
         p = 0 => q
         q = 0 => p
         "failed"

     exactquo(u : UP, v : UP, p : UP) : Union(UP, "failed") ==
         val := extendedEuclidean(v, p, u)
         val case "failed" => "failed"
         val.coef1

     -- generalized eigenvectors associated to a given eigenvalue
     genEigForm(eigen : EigenForm, A : M) : GenEigen ==
         alpha := eigen.eigval
         k := eigen.eigmult
         g := #(eigen.eigvec)
         k = g  => [alpha, eigen.eigvec]
         [alpha, generalizedEigenvector(alpha, A, k, g)]

     if F has FiniteFieldCategory then

         characteristicPolynomial(A : M) : UP ==
              char_pol(A)$CharacteristicPolynomial2(F)

     else

         characteristicPolynomial(A : M) : UP ==
              dimA := nrows A
              dimA ~= ncols A => error " The matrix is not square"
              dimA = 0 => 1$UP
              B : Matrix(UP) := zero(dimA, dimA)
              for i in 1..dimA repeat
                  for j in 1..dimA repeat  B(i, j) := A(i, j)::UP
                  B(i, i) := B(i, i) - monomial(1, 1)$UP
              determinant B

     eigenvalues(A : M, fac : UP -> Factored(UP)) : List Eigenvalue ==
         pol := characteristicPolynomial(A)
         lrat : List F := empty()
         lsym : List UP := empty()
         fp := fac(pol)
         for fr in factorList(fp) repeat
             f1 := fr.factor
             degree(f1) = 1 =>
                 rv := -coefficient(f1, 0)/leadingCoefficient(f1)
                 lrat := cons(rv, lrat)
             lsym := cons(f1, lsym)
         append([lr::Eigenvalue for lr in lrat],
                [ls::Eigenvalue for ls in lsym])

     eigenvector(alpha : Eigenvalue, A : M) : List AV  ==
         alpha case F => intRatEig(alpha::F, A, 1$NNI)
         intAlgEig(alpha::UP, A, 1$NNI)

     -- Eigenvectors belonging to a given eigenvalue from base field.
     intRatEig(alpha : F, A : M, m : NNI) : List AV  ==
         n := nrows A
         B : M := zero(n, n)$M
         for i in 1..n repeat
             for j in 1..n repeat B(i, j) := A(i, j)
             B(i, i) := B(i, i) - alpha
         sol : List(AV) := []
         for v in nullSpace(B^m) repeat
             w : AV := new(n, 0)
             for i in 1..n repeat w(i) := v(i)::UP
             sol := cons(w, sol)
         sol

     --  Eigenvectors belonging to a given algebraic eigenvalue.
     intAlgEig(alpha : UP, A : M, m : NNI) : List AV  ==
         n := nrows A
         MM := ModularField(UP, UP, reduction, merge, exactquo)
         AM := Matrix MM
         pol : UP := unitCanonical alpha
         alg : MM := reduce(monomial(1, 1), pol)
         B : AM := zero(n, n)
         for i in 1..n repeat
             for j in 1..n repeat B(i, j) := reduce(A(i, j)::UP, pol)
             B(i, i) := B(i, i) - alg
         sol : List AV := empty()
         for vec in nullSpace(B^m) repeat
             w : AV := new(n, 0)
             for i in 1..n repeat w(i) := vec(i)::UP
             sol := cons(w, sol)
         sol

     generalizedEigenvector(alpha : Eigenvalue, A : M, k : NNI, g : NNI
                           ) : List AV ==
         alpha case F => intRatEig(alpha::F, A, (1+k-g)::NNI)
         intAlgEig(alpha::UP, A, (1+k-g)::NNI)

     generalizedEigenvector(ei : EigenForm, A : M) : List AV  ==
         generalizedEigenvector(ei.eigval, A, ei.eigmult, # ei.eigvec)

     generalizedEigenvectors(A : M, fac : UP -> Factored(UP)
                            ) : List GenEigen  ==
         n := nrows A
         leig := eigenvectors(A, fac)
         [genEigForm(leg, A) for leg in leig]

     eigenvectors(A : M, fac : UP -> Factored(UP)) : List(EigenForm) ==
         n := nrows A
         p := characteristicPolynomial(A)
         ratSol : List EigenForm := empty()
         algSol : List EigenForm := empty()
         lff := factorList fac p
         for fact in lff repeat
             pol := fact.factor
             degree(pol) = 1 =>
                 vec : F := -coefficient(pol, 0)/leadingCoefficient(pol)
                 ratSol := cons([vec, fact.exponent,
                                 intRatEig(vec, A, 1$NNI)]$EigenForm, ratSol)
             alpha : UP := pol
             algSol := cons([alpha, fact.exponent,
                             intAlgEig(alpha, A, 1$NNI)]$EigenForm, algSol)
         append(ratSol, algSol)


