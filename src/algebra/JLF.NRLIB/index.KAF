11490               (|JetLazyFunction| JB D)
|domain|
(((|JetLazyFunction| |#1| |#2|)
  (|Join| (|JetBundleFunctionCategory| |#1|)
          (CATEGORY |domain| (ATTRIBUTE (|lazyRepresentation|))
           (SIGNATURE |coerce| ($ |#2|)) (SIGNATURE |coerce| (|#2| $))
           (SIGNATURE |collect| ($ $)) (SIGNATURE |eval1| ($ $))
           (SIGNATURE |eval| ($ $)) (SIGNATURE |ground?| ((|Boolean|) $))
           (SIGNATURE * ($ |#2| $)) (SIGNATURE |eqRep?| ((|Boolean|) $ $))
           (SIGNATURE |statistics| ((|Void|)))))
  (|JetBundleCategory|) (|JetBundleFunctionCategory| |#1|))
 (T |JetLazyFunction|))
(|Join| (|JetBundleFunctionCategory| |#1|)
        (CATEGORY |domain| (ATTRIBUTE (|lazyRepresentation|))
         (SIGNATURE |coerce| ($ |#2|)) (SIGNATURE |coerce| (|#2| $))
         (SIGNATURE |collect| ($ $)) (SIGNATURE |eval1| ($ $))
         (SIGNATURE |eval| ($ $)) (SIGNATURE |ground?| ((|Boolean|) $))
         (SIGNATURE * ($ |#2| $)) (SIGNATURE |eqRep?| ((|Boolean|) $ $))
         (SIGNATURE |statistics| ((|Void|)))))
"/git/fricas/src/algebra/JLF.spad"
((|coerce| (*1 *1 *2)
           (AND (|ofCategory| *3 (|JetBundleCategory|))
                (|isDomain| *1 (|JetLazyFunction| *3 *2))
                (|ofCategory| *2 (|JetBundleFunctionCategory| *3))))
 (|coerce| (*1 *2 *1)
           (AND (|ofCategory| *2 (|JetBundleFunctionCategory| *3))
                (|isDomain| *1 (|JetLazyFunction| *3 *2))
                (|ofCategory| *3 (|JetBundleCategory|))))
 (|collect| (*1 *1 *1)
  (AND (|ofCategory| *2 (|JetBundleCategory|))
       (|isDomain| *1 (|JetLazyFunction| *2 *3))
       (|ofCategory| *3 (|JetBundleFunctionCategory| *2))))
 (|eval1| (*1 *1 *1)
  (AND (|ofCategory| *2 (|JetBundleCategory|))
       (|isDomain| *1 (|JetLazyFunction| *2 *3))
       (|ofCategory| *3 (|JetBundleFunctionCategory| *2))))
 (|eval| (*1 *1 *1)
         (AND (|ofCategory| *2 (|JetBundleCategory|))
              (|isDomain| *1 (|JetLazyFunction| *2 *3))
              (|ofCategory| *3 (|JetBundleFunctionCategory| *2))))
 (|ground?| (*1 *2 *1)
  (AND (|ofCategory| *3 (|JetBundleCategory|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|JetLazyFunction| *3 *4))
       (|ofCategory| *4 (|JetBundleFunctionCategory| *3))))
 (* (*1 *1 *2 *1)
    (AND (|ofCategory| *3 (|JetBundleCategory|))
         (|isDomain| *1 (|JetLazyFunction| *3 *2))
         (|ofCategory| *2 (|JetBundleFunctionCategory| *3))))
 (|eqRep?| (*1 *2 *1 *1)
  (AND (|ofCategory| *3 (|JetBundleCategory|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|JetLazyFunction| *3 *4))
       (|ofCategory| *4 (|JetBundleFunctionCategory| *3))))
 (|statistics| (*1 *2)
  (AND (|ofCategory| *3 (|JetBundleCategory|)) (|isDomain| *2 (|Void|))
       (|isDomain| *1 (|JetLazyFunction| *3 *4))
       (|ofCategory| *4 (|JetBundleFunctionCategory| *3)))))
((~= (((|Boolean|) $ $) NIL)) (|zero?| (((|Boolean|) $) 52))
 (|unitNormal|
  (((|Record| (|:| |unit| $) (|:| |canonical| $) (|:| |associate| $)) $) NIL))
 (|unitCanonical| (($ $) NIL)) (|unit?| (((|Boolean|) $) NIL))
 (|symbol| (((|SparseEchelonMatrix| |#1| $) (|List| $)) NIL))
 (|subtractIfCan| (((|Union| $ "failed") $ $) NIL))
 (|subst| (($ $ |#1| $) 138)) (|statistics| (((|Void|)) 19))
 (|sortLD| (((|List| $) (|List| $)) NIL))
 (|solveFor| (((|Union| $ #1="failed") $ |#1|) 136))
 (|simplify|
  (((|Record| (|:| |Sys| (|List| $)) (|:| JM (|SparseEchelonMatrix| |#1| $))
              (|:| |Depend|
                   (|Union| #1# (|List| (|List| (|NonNegativeInteger|))))))
    (|List| $) (|SparseEchelonMatrix| |#1| $))
   167))
 (|simpOne| (($ $) NIL))
 (|simpMod| (((|List| $) (|List| $) (|List| $)) NIL)
  (((|Record| (|:| |Sys| (|List| $)) (|:| JM (|SparseEchelonMatrix| |#1| $))
              (|:| |Depend|
                   (|Union| #1# (|List| (|List| (|NonNegativeInteger|))))))
    (|List| $) (|SparseEchelonMatrix| |#1| $) (|List| $))
   NIL))
 (|setNotation| (((|Void|) (|Symbol|)) NIL)) (|sample| (($) NIL T CONST))
 (|rightRecip| (((|Union| $ #2="failed") $) NIL))
 (|rightPower| (($ $ (|PositiveInteger|)) NIL)
  (($ $ (|NonNegativeInteger|)) NIL))
 (|retractIfCan| (((|Union| |#1| "failed") $) NIL)) (|retract| ((|#1| $) NIL))
 (|reduceMod| (((|List| $) (|List| $) (|List| $)) 169))
 (|recip| (((|Union| $ #2#) $) 106))
 (|orderDim|
  (((|NonNegativeInteger|) (|List| $) (|SparseEchelonMatrix| |#1| $)
    (|NonNegativeInteger|))
   NIL))
 (|order| (((|NonNegativeInteger|) $) 110))
 (|opposite?| (((|Boolean|) $ $) NIL)) (|one?| (((|Boolean|) $) 53))
 (|numerator| (($ $) 93)) (|numIndVar| (((|PositiveInteger|)) NIL))
 (|numDepVar| (((|PositiveInteger|)) NIL))
 (|leftRecip| (((|Union| $ #2#) $) NIL))
 (|leftPower| (($ $ (|PositiveInteger|)) NIL)
  (($ $ (|NonNegativeInteger|)) NIL))
 (|leadingDer| ((|#1| $) 87))
 (|lcmCoef|
  (((|Record| (|:| |llcm_res| $) (|:| |coeff1| $) (|:| |coeff2| $)) $ $) NIL))
 (|lcm| (($ (|List| $)) NIL) (($ $ $) NIL)) (|latex| (((|String|) $) NIL))
 (|jetVariables| (((|List| |#1|) $) 41))
 (|jacobiMatrix| (((|SparseEchelonMatrix| |#1| $) (|List| $)) NIL)
  (((|SparseEchelonMatrix| |#1| $) (|List| $) (|List| (|List| |#1|))) 165))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) NIL))
 (|hash| (((|SingleInteger|) $) NIL)) (|ground?| (((|Boolean|) $) 74))
 (|getNotation| (((|Symbol|)) NIL))
 (|gcdPolynomial|
  (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)
    (|SparseUnivariatePolynomial| $))
   NIL))
 (|gcd| (($ (|List| $)) NIL) (($ $ $) NIL))
 (|freeOf?| (((|Boolean|) $ |#1|) 134))
 (|formalDiff2|
  (((|Record| (|:| |DPhi| $) (|:| |JVars| (|List| |#1|))) $ (|PositiveInteger|)
    (|SparseEchelonMatrix| |#1| $))
   NIL)
  (((|Record| (|:| |DSys| (|List| $)) (|:| |JVars| (|List| (|List| |#1|))))
    (|List| $) (|PositiveInteger|) (|SparseEchelonMatrix| |#1| $))
   132))
 (|formalDiff| (($ $ (|PositiveInteger|)) NIL)
  (($ $ (|List| (|NonNegativeInteger|))) NIL)
  (((|List| $) (|List| $) (|PositiveInteger|)) NIL))
 (|extractSymbol|
  (((|SparseEchelonMatrix| |#1| $) (|SparseEchelonMatrix| |#1| $)) NIL))
 (|exquo| (((|Union| $ "failed") $ $) NIL)) (|eval1| (($ $) 85))
 (|eval| (($ $) 63)) (|eqRep?| (((|Boolean|) $ $) 90))
 (|dimension|
  (((|NonNegativeInteger|) (|List| $) (|SparseEchelonMatrix| |#1| $)
    (|NonNegativeInteger|))
   NIL))
 (|differentiate| (($ $ (|Symbol|)) 115) (($ $ (|List| (|Symbol|))) NIL)
  (($ $ (|Symbol|) (|NonNegativeInteger|)) NIL)
  (($ $ (|List| (|Symbol|)) (|List| (|NonNegativeInteger|))) NIL)
  (($ $ |#1|) 114))
 (|denominator| (($ $) 94)) (|dSubst| (($ $ |#1| $) NIL))
 (|const?| (((|Boolean|) $) 108)) (|commutator| (($ $ $) NIL))
 (|collect| (($ $) 79))
 (|coerce| (((|OutputForm|) $) 66) (($ (|Integer|)) NIL) (($ $) NIL)
           (($ |#1|) 61) (($ |#2|) 62) ((|#2| $) 64))
 (|class| (((|NonNegativeInteger|) $) 112))
 (|characteristic| (((|NonNegativeInteger|)) NIL))
 (|autoReduce| (((|List| $) (|List| $)) 171)) (|associator| (($ $ $ $) NIL))
 (|associates?| (((|Boolean|) $ $) NIL)) (|antiCommutator| (($ $ $) NIL))
 (|annihilate?| (((|Boolean|) $ $) NIL))
 (^ (($ $ (|PositiveInteger|)) NIL) (($ $ (|NonNegativeInteger|)) NIL))
 (|Zero| (($) 86 T CONST)) (X (($ (|PositiveInteger|)) NIL) (($) NIL))
 (U (($ (|PositiveInteger|)) NIL) (($) NIL))
 (P (($ (|PositiveInteger|) (|List| (|NonNegativeInteger|))) NIL)
  (($ (|List| (|NonNegativeInteger|))) NIL)
  (($ (|PositiveInteger|) (|NonNegativeInteger|)) NIL)
  (($ (|NonNegativeInteger|)) NIL))
 (|One| (($) 80 T CONST)) (= (((|Boolean|) $ $) 92))
 (- (($ $ $) 91) (($ $) 55)) (+ (($ $ $) 99))
 (* (($ (|PositiveInteger|) $) NIL) (($ $ $) 58) (($ (|Integer|) $) 103)
    (($ (|NonNegativeInteger|) $) NIL) (($ |#2| $) 57))
 (|#2| (($ $ (|Symbol|)) NIL) (($ $ (|List| (|Symbol|))) NIL)
  (($ $ (|Symbol|) (|NonNegativeInteger|)) NIL)
  (($ $ (|List| (|Symbol|)) (|List| (|NonNegativeInteger|))) NIL)))
JLF
(((|JetBundleFunctionCategory| |#1|) . T) ((|lazyRepresentation|) . T))
(((|AbelianGroup|) . T) ((|AbelianMonoid|) . T) ((|AbelianSemiGroup|) . T)
 ((|Algebra| $) . T) ((|BasicType|) . T) ((|BiModule| |t#1| |t#1|) . T)
 ((|BiModule| $ $) . T) ((|CancellationAbelianMonoid|) . T)
 ((|CoercibleTo| (|OutputForm|)) . T) ((|CommutativeRing|) . T)
 ((|CommutativeStar|) . T) ((|EntireRing|) . T) ((|GcdDomain|) . T)
 ((|IntegralDomain|) . T) ((|JetBundleFunctionCategory| |#1|) . T)
 ((|LeftModule| |t#1|) . T) ((|LeftOreRing|) . T) ((|Magma|) . T)
 ((|MagmaWithUnit|) . T) ((|Module| |t#1|) . T) ((|Monoid|) . T)
 ((|NonAssociativeRing|) . T) ((|NonAssociativeRng|) . T)
 ((|NonAssociativeSemiRing|) . T) ((|NonAssociativeSemiRng|) . T)
 ((|PartialDifferentialRing| (|Symbol|)) . T) ((|RetractableTo| |t#1|) . T)
 ((|RightModule| |t#2|) . T) ((|Ring|) . T) ((|Rng|) . T) ((|SemiGroup|) . T)
 ((|SemiRing|) . T) ((|SemiRng|) . T) ((|SetCategory|) . T)
 ((|TwoSidedRecip|) . T) ((|lazyRepresentation|) . T) ((|noZeroDivisors|) . T)
 ((|unitsKnown|) . T))
((|constructor|
  (NIL
   "\\spadtype{JetLazyFunction} takes as argument a domain in \\spadtype{JetBundleFunctionCategory} and returns another domain in the same category. This domain has basically the same properties as the argument domain,{} but there is a lazy evaluation mechanism for derivatives. This means that differentiations are not immediately performed. Instead a pointer is established to the function to be differentiated. Only when the exact value of the derivative is needed,{} the differentiation is executed. Special care is taken for leading derivatives and jet variables to avoid as much as possible the need to evaluate expressions. This entails that the result of \\spad{jetVariables} may contain spurious variables. Furthermore many functions in \\spadtype{JetLazyFunction} destructively change their arguments. This affects,{} however,{} only their internal representation,{} not the value obtained after full evaluation."))
 (|statistics|
  (((|Void|))
   "\\spad{statistics()} prints a statistic on the use of the lazy evaluation mechanism. It displays the number of lazy differentiations performed and how many of them had to be executed explicitly later on."))
 (|eqRep?|
  (((|Boolean|) $ $)
   "\\spad{eqRep?(x,{} y)} compares the representations of \\spad{x} and \\spad{y} without any evaluation. Thus it is much weaker than \\spad{=} and cannot decide equality of the evaluated expressions."))
 (*
  (($ |#2| $)
   "\\spad{d*exp} is provided mainly for internal use,{} as basically all calculations should be performed within \\spadtype{JetLazyFunction}."))
 (|ground?|
  (((|Boolean|) $)
   "\\spad{ground(exp)} is \\spad{true},{} if \\spad{exp} contains only fully evaluated parts."))
 (|eval|
  (($ $)
   "\\spad{eval(exp)} explicitly evaluates all terms in \\spad{exp}. \\spad{exp} is destructively altered."))
 (|eval1|
  (($ $)
   "\\spad{eval1(exp)} explicitly evaluates the next term in \\spad{exp}. \\spad{exp} is destructively altered."))
 (|collect|
  (($ $)
   "\\spad{collect(exp)} \"collects\" former lazy terms which have been meanwhile evaluated."))
 (|coerce|
  ((|#2| $)
   "\\spad{coerce(exp)} retracts an element to the base domain \\spad{D}. This looses all information about its leading derivative and its jet variables and requires complete evaluation of the expression.")
  (($ |#2|)
   "\\spad{coerce(d)} coerces an element of \\spad{D} into the new domain. This includes the calculation of its leading derivative and its jet variables."))
 (|lazyRepresentation|
  ((|attribute|) "The representation contains a lazy evaluation scheme.")))
(("documentation" 0 8894) ("ancestors" 0 7917) ("parents" 0 7845)
 ("abbreviation" 0 7841) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 2841) ("modemaps" 0 1077) ("sourceFile" 0 1042)
 ("constructorCategory" 0 613) ("constructorModemap" 0 54)
 ("constructorKind" 0 45) ("constructorForm" 0 20))