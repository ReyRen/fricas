)abbrev domain CUBEC FiniteCubicalComplex
++ Author: Martin Baker
++ Description:
++   A Finite Cubical Complex
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/cubical/
++ Date Created: April 2016
++ Basic Operations:
++ Related packages:
++ Related categories:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: topology, finite, cubical, complex, edge, triangle
++ Examples:
++ References:

FiniteCubicalComplex(VS : AbelianGroup) : Exports == Impl where
  NNI==> NonNegativeInteger
  x<<y ==> hconcat(x::OutputForm, y::OutputForm)

  Exports ==> SetCategory() with
    cubicalComplex : (v : List(VS), f : List(CubicalFacet)) -> %
      ++ constructor where the cubes are supplied
    cubicalComplex : (v : List(VS), f : List(List(Segment(Integer)))) -> %
      ++ constructor where the cubes are supplied
    cubicalComplex : (v : List(VS), f : List(List(List(Integer)))) -> %
      ++ constructor where the cubes are supplied
    cubicalComplex : (v : List(VS)) -> %
      ++ construct empty cubical complex
    maxIndex : (s : %) -> NNI
      ++ find the maximum index.
    addCube : (a : %, f : CubicalFacet) -> %
      ++ Add a facet to this simplex
      ++ If the facet is also in the list then, dont append, instead
      ++ change the multiplier.
    grade : (s : %) -> List(List(CubicalFacet))
      ++ A function to grade faces according to the number of non-degenerate
      ++ intervals. This nests the lists according to their order
      ++ Vertices, edges, squares and so on.
    addImpliedFaces : (s : %) -> List(List(CubicalFacet))
      ++ a function to take a set of faces and add those that are implied
      ++ by the cubicalComplex conventions (if they don't already exist).
      ++ For example, if the input is a square [1..2, 1..2] then we would add
      ++ its edges [1..1, 1..2], [2..2, 1..2], [1..2, 1..1], and [1..2, 2..2].
    product : (a : %, b : %) -> %
      ++ Forms product of two cubical complexes.
    fundamentalGroup : (s : %) -> GroupPresentation
      ++ Generates fundamental group from this cubical complex.
      ++ This works by converting to a DeltaComplex and then generating the
      ++ fundamentalGroup from that. This is not the most efficient method
      ++ because the conversion generates lots of higher order faceMaps
      ++ which are not used.
      ++ This will attempt to simplify the group presentation, if you
      ++ don't want this use alternative function of same name.
      ++ TODO write a faster implemetation which only generates edge and
      ++ square faceMaps.
    fundamentalGroup : (s : %, simplify : Boolean, trace : Boolean) -> GroupPresentation
      ++ Generates fundamental group from this cubical complex.
      ++ This works by converting to a DeltaComplex and then generating the
      ++ fundamentalGroup from that. This is not the most efficient method
      ++ because the conversion generates lots of higher order faceMaps
      ++ which are not used.
      ++ TODO write a faster implementation which only generates edge and
      ++ square faceMaps.
      ++ This version has options to:
      ++ simplify - if true attempts to simplify the group presentation
      ++ trace - if true outputs trace of simplification rules used.
    homology : (a : %) -> List(Homology)
      ++ calculate homology using SmithNormalForm
    boundary : (s : %) -> %
      ++ Boundary operator. Step down to the next lower dimension, this is
      ++ like hollowing out the complex.
      ++ It takes the highest dimension entries and replaces them with
      ++ their boundaries, cancelling out where it can.
    chain : (s : %) -> ChainComplex
      ++ returns a matrix sequence representing the face maps
      ++ in linear algebra form
    coerce : (s : %) -> DeltaComplex(VS)
      ++ coerce CubicalComplex to DeltaComplex

  Impl ==> add

   -- Representation holds whole Cubical Complex. This consists of
   -- a vertex set, here represented as a vertex list so that we can
   -- index it.
   -- Also a list of hypercubes.
   Rep := Record(VERTSET : List(VS), CUBE : List(CubicalFacet))

   -- constructor where the vertex set and cubes are supplied
   cubicalComplex(v : List(VS), fs : List(CubicalFacet)) : % ==
       [v, fs]

   -- constructor where the vertex set and cubes are supplied
   cubicalComplex(v : List(VS), fs : List(List(Segment(Integer)))) : % ==
       res := []$List(CubicalFacet)
       for f in fs repeat
           res := concat(res, cubicalFacet(1, f))
       --print("cubicalComplex(" << fs << ") res=" << res)
       cubicalComplex(v, res)

   -- constructor where the vertex set and cubes are supplied
   cubicalComplex(v : List(VS), fs : List(List(List(Integer)))) : % ==
       res := []$List(CubicalFacet)
       for f in fs repeat
           res := concat(res, cubicalFacet(1, f))
       --print("cubicalComplex(" << fs << ") res=" << res)
       cubicalComplex(v, res)

   -- construct empty cubical complex
   cubicalComplex(v : List(VS)) : % ==
       res := []$List(CubicalFacet)
       [v, res]

   -- find the maximum index value.
   maxIndex(s : %) : NNI ==
       res : NNI := 0
       facs : List(CubicalFacet) := s.CUBE
       for fac in facs repeat
           i:List(Segment(Integer)) := getIntervals(fac)
           m := #i
           if m>res then res := m
       res

   -- Add a facet to this cubical complex
   -- If the facet is also in the list then add the multipliers.
   addCube(a : %, f : CubicalFacet) : % ==
       res : List(CubicalFacet) := a.CUBE
       res2 := []$List(CubicalFacet)
       -- check for duplicates
       found : Boolean := false
       for orf in res repeat
           if getIntervals(orf)=getIntervals(f)
               then
                   m : Integer := getMult(orf) + getMult(f)
                   if m~=0 then
                       res2 := concat(res2, setMult(orf, m))
                   found := true
               else
                   res2 := concat(res2, orf)
       if not found then
           res2 := concat(res2, f)
       --print("addCube(" << a << ", " << f << ") res=" << res2)
       cubicalComplex(a.VERTSET, res2)

   -- Boundary operator. Step down to the next lower dimension, this is
   -- like hollowing out the complex.
   -- It takes the highest dimension entries and replaces them with
   -- their boundaries, cancelling out where it can.
   boundary(s : %) : % ==
       res : % := cubicalComplex(s.VERTSET)
       --facets := []$List(CubicalFacet)
       for facet in s.CUBE repeat
           x : List(CubicalFacet) := boundary(facet)
           --print("boundary(" << s.CUBE << ") x=" << x)
           for y in x repeat
               --facets := concat(facets, y)$List(CubicalFacet)
               res := addCube(res, y)
       res

   -- A function to grade faces according to the number of
   -- non-degenerate intervals. This nests the lists according to
   -- their order. Verticies, edges, squares and so on.
   grade(s : %) : List(List(CubicalFacet)) ==
       simp : List(CubicalFacet) := s.CUBE
       -- set maxGrade to be the maximum number of non-degenerate
       -- intervals in any face
       maxGrade : NNI := 0
       for face in simp repeat
           if order(face) > maxGrade then maxGrade := order(face)
       --print("grade(" << s << ") maxGrade=" << maxGrade << " simp=" << simp)
       res := []$List(List(CubicalFacet))
       if maxGrade < 0 then return res
       -- create empty list for each grade
       for a in 0..maxGrade repeat
           res := concat(res, []$List(CubicalFacet))
       for face in simp repeat
           -- order is the number of non-degenerate intervals
           gr : Integer := order(face) + 1
           --print("grade(" << s << ") face=" << face << " gr=" << gr)
           if gr > 0
               then
                   res.gr := concat(res.gr, face)
               -- else
               --    print("grade face:" << face << " gr=" << res << "<1")
       --print("grade(" << s << ") res=" << res)
       res

   -- local function used in listUnion in addImpliedFaces
   isNewFace?(lst : List(CubicalFacet), b : CubicalFacet) : Boolean ==
       --print("isNewFace?(" << a << ", " << b << ")")
       for a in lst repeat
           if sameFace?(a, b) then return false
           --if member?(b, a)$List(CubicalFacet) then return false
       true

   -- local function used in addImpliedFaces
   listUnion(a : List(CubicalFacet), b : List(CubicalFacet)) : _
             List(CubicalFacet) ==
       res := []$List(CubicalFacet)
       for a1 in a repeat
           res := concat(res, a1)
       for b1 in b repeat
           if isNewFace?(a, b1) then
               res := concat(res, b1)
       --print("listUnion(" << a << ", " << b << ") = " << res)
       res

   -- A function to take a set of faces and add those that are implied
   -- by the cubical complex conventions (if they don't already exist).
   -- For example, if the input is a square [1..2, 1..2] then we would add
   -- its edges [1..1, 1..2], [2..2, 1..2], [1..2, 1..1], and [1..2, 2..2].
   addImpliedFaces(s : %) : List(List(CubicalFacet)) ==
       --print("addImpliedFaces s=" << s)
       -- start at highest grade and work down
       inputList : List(List(CubicalFacet)) := reverse(grade(s))
       res := []$List(List(CubicalFacet))
       maxGrade : NNI := #inputList
       --print("addImpliedFaces inputList=" << inputList <<
       --      " maxGrade=" << maxGrade)
       if (maxGrade) < 1 then
           --print("addImpliedFaces return because maxGrade=" << maxGrade)
           return res
       -- create an empty list for each grade
       for a in 1..(maxGrade) repeat
           res := concat(res, []$List(CubicalFacet))
       newFaces := []$List(CubicalFacet)
       for gr in inputList for grn in 1..(maxGrade) repeat
           --print("addImpliedFaces grade number grn=" << grn << " gr=" << gr)
           -- add old faces
           for face in gr repeat
               res.grn := concat(res.grn, face)
           -- add new faces
           for face in newFaces repeat
               res.grn := concat(res.grn, face)
           -- print("addImpliedFaces empty newFaces. res.(" << grn
           --       <<")=" << res.grn)
           newFaces := []$List(CubicalFacet)
           --print("addImpliedFaces res.(" << grn <<")=" << res.grn)
           for face in res.grn repeat
               len := qcoerce(order(face) -1)@NNI
               if len > -1 then
                   newFaces := listUnion(newFaces, allSubsets(face, len, len))
           -- print("addImpliedFaces get next grade res=" << res <<
           --       " newFaces=" << newFaces)
       --print("addImpliedFaces result=" << reverse(res))
       reverse(res)

   -- Forms product of two cubical complexes.
   -- For more detailed explanation of cube product code see:
   -- \url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/cubical/}
   product(a : %, b : %) : % ==
       cubesa : List(CubicalFacet) := a.CUBE
       cubesb : List(CubicalFacet) := b.CUBE
       -- How do we represent the points? This should be the Cartesian
       -- product of the points in 'a' and the points in 'b', so this
       -- would increase the dimension of the points. But here
       -- we do not know how these points are represented, we can only
       -- do Abelian group operations (+, - or set to 0).
       -- The following is not correct but it is the best I can do for now.
       vs : List(VS) := []
       for pa in a.VERTSET repeat
           for pb in b.VERTSET repeat
               pp:VS := pa+pb
               vs := concat(vs,pp)
       res := []$List(CubicalFacet)
       for cubea in cubesa repeat
           for cubeb in cubesb repeat
               p : CubicalFacet := product(cubea, cubeb)
               res := concat(res, p)
       cubicalComplex(vs, res)

   -- Generates fundamental group from this cubucal complex.
   -- This works by converting to a DeltaComplex and then generating the
   -- fundamentalGroup from that. This is not the most efficient method
   -- because the conversion generates lots of higher order faceMaps
   -- which are not used.
   -- This will attempt to simplify the group presentation, if you
   -- don't want this use alternative function of same name.
   -- TODO write a faster implemetation which only generates edge and
   -- square faceMaps.
   fundamentalGroup(s : %) : GroupPresentation ==
       fundamentalGroup(s, true, false)

   -- Generates fundamental group from this cubucal complex.
   -- This works by converting to a DeltaComplex and then generating the
   -- fundamentalGroup from that. This is not the most efficient method
   -- because the conversion generates lots of higher order faceMaps
   -- which are not used.
   -- TODO write a faster implementation which only generates edge and
   -- square faceMaps.
   -- This version has options to:
   -- simplify - if true attempts to simplify the group presentation
   -- trace - if true outputs trace of simplification rules used.
   fundamentalGroup(s:%, simplify : Boolean, trace : Boolean) : _
                  GroupPresentation ==
       dc : DeltaComplex(VS) := deltaComplex(s pretend FiniteCubicalComplex(VS))
       fundamentalGroup(dc, simplify, trace)

   -- calculate homology using SmithNormalForm
   homology(s : %) : List(Homology) ==
       dc : DeltaComplex(VS) := deltaComplex(s pretend FiniteCubicalComplex(VS))
       homology(dc)$DeltaComplex(VS)

   -- returns a matrix sequence representing the face maps
   -- in linear algebra form
   chain(s : %) : ChainComplex ==
       dc : DeltaComplex(VS) := deltaComplex(s pretend FiniteCubicalComplex(VS))
       cc : ChainComplex := chain(dc)$DeltaComplex(VS)
       cc

   -- Returns true if x equals y.
   -- That is, they contain the same simplexes, although not
   -- necessarily in the same order.
   -- TODO - Assumes point set is exactly the same, for more generality
   -- we should allow the points to be defined in a different order.
   _=(a : %, b : %) : Boolean ==
       as : List(CubicalFacet) := a.CUBE
       bs : List(CubicalFacet) := b.CUBE
       --print("equal:" << as << ", " << bs)
       len : NNI := #as
       if len ~= #bs then return false
       flags : List(Boolean) := [false for x in as] -- flag for every entry in b
       --print("empty flags " << flags)
       for a1 in as repeat
           x : NNI := 1
           while (a1 ~= bs.x) or (flags.x) repeat
               --print("loop:" << x << " flags" << flags)
               x := x + 1
               if x > #as then return false
           flags.x := true
           --print("flags." << x << "=true " << flags)
       --print("final flags " << flags)
       for f in flags repeat
           if f=false then return false
       true

   -- output
   coerce(s : %) : OutputForm ==
       res := empty()$OutputForm
       if empty?(s.CUBE) then return bracket(message("empty"))
       for a in s.CUBE repeat
           -- a is OrientedFacet
           res := vconcat(res, a::OutputForm)
       --print("FiniteCubicialComplex coerce num=" << #(s.CUBE))
       res

   -- coerce CubicalComplex to DeltaComplex
   coerce(s : %)  :  DeltaComplex(VS) ==
       deltaComplex(s pretend FiniteCubicalComplex(VS))

)if false
\section{Delta Complex}

The FiniteSimplicialComplex representation defines faces, of any
dimension, by their vertices. This is an efficient way to define
them, a disadvantage is that intermediate parts, such as edges, are
not indexed. It is sometimes useful to be able to do this, for
example, when generating homotopy groups such as the fundamental group.

Advantages of Simpectial Complexes:
\begin{itemize}
\item Easier to construct and to understand
\item Some operations are easier on simplectial complexes.
\end{itemize}
Advantages of Delta Complexes
\begin{itemize}
\item Can sometimes be more compact, for example, use less points.
\item Easier to construct chains, homology and homotopy from delta
complexes so they are a good intermediate step.
\end{itemize}

So it is worthwhile implementing both types in code with conversions
between them.

It is possible to convert from and to simplectial complexes like this:
\begin{verbatim}
simplectial complexes ->  delta complexes -> simplectial complexes
\end{verbatim}
and get back to where we started. However it is not always possible
to start with delta complexes and get back to where we started.
\begin{verbatim}
delta complexes -> simplectial complexes ->  delta complexes
\end{verbatim}
This is because the more compact coding of delta complexes is hard to
translate because it can only be done by adding extra points. Also the
two types are not exactly isomorphic as there are special cases which
can only be coded in one type.

There are also other codings of cell complexes such as cubical
complexes, implemented below.

\subsection{Creating Delta Complexes}
Here are 3 ways to construct a delta complex:
\begin{itemize}
\item From DeltaComplexFactory - Some simple complexes are provided
by factory functions.
\item From FiniteSimplicialComplex - Sometimes it is easier to
construct a simplicial complex first and then convert.
\item Directly from index lists.
\end{itemize}
We cab easily construct from factory functions like this:
\begin{verbatim}
(5) -> cD := circle()$DeltaComplexFactory(Integer)

   (5)
         1D:[[1,- 1]]
           0D:[[0]]
                               Type: DeltaComplex(Integer)
\end{verbatim}
Constructing from  a simplicial complex first and then converting:
\begin{verbatim}
(6) -> cS := sphereSurface(2)$SCF

   (6)  points 1..3
           (1,2)
          -(1,3)
           (2,3)
                   Type: FiniteSimplicialComplex(Integer)
(7) -> deltaComplex(cS)

   (7)
         1D:[[1,- 2],[- 1,3],[2,- 3]]
               0D:[[0],[0],[0]]
                               Type: DeltaComplex(Integer)
\end{verbatim}
Here we construct directly from index lists:
\begin{verbatim}
(8) -> deltaComplex([],1, [[[1, -1]]])$DeltaComplex(Integer)

   (8)
          1D:[[1,- 1]]
            0D:[[0]]
                               Type: DeltaComplex(Integer)
\end{verbatim}

\subsection{Representation of Delta Complexes}
The representation consists of:
\begin{itemize}
\item vertexset - As for simpectial complex.
\item maps - Highest dimension first down to dimension zero (points)
\end{itemize}
The array for each point is either [0] for a used point or [] for an
unused point. By 'unused point' I mean a point that is not part of
this delta complex but its position is held for future use.
)endif

