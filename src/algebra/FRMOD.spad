)abbrev category FRMOD FramedModule
++ Author: Waldek Hebisch
++ Description:
++  A \spadtype{FramedModule} is a finite rank free module
++  with fixed R-module basis.
FramedModule(R : Join(SemiRng, AbelianMonoid)) : Category ==
    LeftModule(R) with
      basis : () -> Vector %
        ++ basis() returns the fixed R-module basis.
      rank : () -> PositiveInteger
        ++ rank() returns the rank of the module
      coordinates : % -> Vector R
        ++ coordinates(a) returns the coordinates of \spad{a} with
        ++ respect to the fixed R-module basis.
      coordinates : Vector % -> Matrix R
        ++ coordinates([v1, ..., vm]) returns the coordinates of the
        ++ vi's with to the fixed basis.  The coordinates of vi are
        ++ contained in the ith row of the matrix returned by this
        ++ function.
      represents : Vector R -> %
        ++ represents([a1, .., an]) returns \spad{a1*v1 + ... + an*vn}, where
        ++ v1, ..., vn are the elements of the fixed basis.
      convert : % -> Vector R
        ++ convert(a) returns the coordinates of \spad{a} with respect to the
        ++ fixed R-module basis.
      convert : Vector R -> %
        ++ convert([a1, .., an]) returns \spad{a1*v1 + ... + an*vn}, where
        ++ v1, ..., vn are the elements of the fixed basis.
      if R has Finite then Finite
  add

      convert(x : %) : Vector(R)  == coordinates(x)
      convert(v : Vector R) : %   == represents(v)

      coordinates(v : Vector %) ==
          m := new(#v, rank(), 0)$Matrix(R)
          for i in minIndex v .. maxIndex v for j in minRowIndex m .. repeat
              setRow!(m, j, coordinates qelt(v, i))
          m

      if R has Finite then

          index(i : PositiveInteger) : % ==
              m := size()$R
              l := []$List(R)
              ii : Integer := i - 1
              for j in 1..rank() repeat
                  (ii, i1) := divide(ii, m)
                  l := cons(index(qcoerce(i1 + 1))$R, l)
              represents(vector(l)$Vector(R))

          lookup(x : %) : PositiveInteger ==
              v := coordinates(x)
              res := 0$Integer
              m := size()$R
              for i in 1..rank() repeat
                  res := m*res + lookup(v(i)) - 1
              qcoerce(res + 1)

          size()   == size()$R ^ rank()

          random() == represents [random()$R for i in 1..rank()]$Vector(R)

