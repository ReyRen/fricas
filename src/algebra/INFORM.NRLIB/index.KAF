8113                (MAKEPROP '|InputForm| 'NILADIC T)
(|InputForm|)
|domain|
(((|InputForm|)
  (|Join|
   (|SExpressionCategory| (|String|) (|Symbol|) (|Integer|) (|DoubleFloat|))
   (|ConvertibleTo| (|SExpression|))
   (CATEGORY |domain| (SIGNATURE |interpret| ((|Any|) $))
    (SIGNATURE |convert| ($ (|SExpression|)))
    (SIGNATURE |binary| ($ $ (|List| $)))
    (SIGNATURE |function| ($ $ (|List| (|Symbol|)) (|Symbol|)))
    (SIGNATURE |lambda| ($ $ (|List| (|Symbol|)))) (SIGNATURE + ($ $ $))
    (SIGNATURE * ($ $ $)) (SIGNATURE / ($ $ $))
    (SIGNATURE ^ ($ $ (|NonNegativeInteger|))) (SIGNATURE ^ ($ $ (|Integer|)))
    (SIGNATURE 0 ($) |constant|) (SIGNATURE 1 ($) |constant|)
    (SIGNATURE |flatten| ($ $)) (SIGNATURE |unparse| ((|String|) $))
    (SIGNATURE |parse| ($ (|String|)))
    (SIGNATURE |declare| ((|Symbol|) (|List| $)))
    (SIGNATURE |compile| ((|Symbol|) (|Symbol|) (|List| $))))))
 (T |InputForm|))
(|Join|
 (|SExpressionCategory| (|String|) (|Symbol|) (|Integer|) (|DoubleFloat|))
 (|ConvertibleTo| (|SExpression|))
 (CATEGORY |domain| (SIGNATURE |interpret| ((|Any|) $))
  (SIGNATURE |convert| ($ (|SExpression|)))
  (SIGNATURE |binary| ($ $ (|List| $)))
  (SIGNATURE |function| ($ $ (|List| (|Symbol|)) (|Symbol|)))
  (SIGNATURE |lambda| ($ $ (|List| (|Symbol|)))) (SIGNATURE + ($ $ $))
  (SIGNATURE * ($ $ $)) (SIGNATURE / ($ $ $))
  (SIGNATURE ^ ($ $ (|NonNegativeInteger|))) (SIGNATURE ^ ($ $ (|Integer|)))
  (SIGNATURE (|Zero|) ($) |constant|) (SIGNATURE (|One|) ($) |constant|)
  (SIGNATURE |flatten| ($ $)) (SIGNATURE |unparse| ((|String|) $))
  (SIGNATURE |parse| ($ (|String|)))
  (SIGNATURE |declare| ((|Symbol|) (|List| $)))
  (SIGNATURE |compile| ((|Symbol|) (|Symbol|) (|List| $)))))
"/git/fricas/src/algebra/INFORM.spad"
((|interpret| (*1 *2 *1)
              (AND (|isDomain| *2 (|Any|)) (|isDomain| *1 (|InputForm|))))
 (|convert| (*1 *1 *2)
            (AND (|isDomain| *2 (|SExpression|))
                 (|isDomain| *1 (|InputForm|))))
 (|binary| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|List| (|InputForm|))) (|isDomain| *1 (|InputForm|))))
 (|function| (*1 *1 *1 *2 *3)
             (AND (|isDomain| *2 (|List| (|Symbol|)))
                  (|isDomain| *3 (|Symbol|)) (|isDomain| *1 (|InputForm|))))
 (|lambda| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|List| (|Symbol|))) (|isDomain| *1 (|InputForm|))))
 (+ (*1 *1 *1 *1) (|isDomain| *1 (|InputForm|)))
 (* (*1 *1 *1 *1) (|isDomain| *1 (|InputForm|)))
 (/ (*1 *1 *1 *1) (|isDomain| *1 (|InputForm|)))
 (^ (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|NonNegativeInteger|)) (|isDomain| *1 (|InputForm|))))
 (^ (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|Integer|)) (|isDomain| *1 (|InputForm|))))
 (|Zero| (*1 *1) (|isDomain| *1 (|InputForm|)))
 (|One| (*1 *1) (|isDomain| *1 (|InputForm|)))
 (|flatten| (*1 *1 *1) (|isDomain| *1 (|InputForm|)))
 (|unparse| (*1 *2 *1)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *1 (|InputForm|))))
 (|parse| (*1 *1 *2)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *1 (|InputForm|))))
 (|declare| (*1 *2 *3)
            (AND (|isDomain| *3 (|List| (|InputForm|)))
                 (|isDomain| *2 (|Symbol|)) (|isDomain| *1 (|InputForm|))))
 (|compile| (*1 *2 *2 *3)
            (AND (|isDomain| *2 (|Symbol|))
                 (|isDomain| *3 (|List| (|InputForm|)))
                 (|isDomain| *1 (|InputForm|)))))
((~= (((|Boolean|) $ $) NIL)) (|unparse| (((|String|) $) 45))
 (|symbol?| (((|Boolean|) $) 42)) (|symbol| (((|Symbol|) $) 43))
 (|string?| (((|Boolean|) $) 40)) (|string| (((|String|) $) 41))
 (|parse| (($ (|String|)) 46)) (|pair?| (((|Boolean|) $) NIL))
 (|null?| (((|Boolean|) $) NIL)) (|list?| (((|Boolean|) $) NIL))
 (|latex| (((|String|) $) NIL)) (|lambda| (($ $ (|List| (|Symbol|))) 18))
 (|interpret| (((|Any|) $) 20)) (|integer?| (((|Boolean|) $) NIL))
 (|integer| (((|Integer|) $) NIL))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) NIL))
 (|hash| (((|SingleInteger|) $) NIL))
 (|function| (($ $ (|List| (|Symbol|)) (|Symbol|)) 58))
 (|float?| (((|Boolean|) $) NIL)) (|float| (((|DoubleFloat|) $) NIL))
 (|flatten| (($ $) 36)) (|eq| (((|Boolean|) $ $) NIL))
 (|elt| (($ $ (|Integer|)) NIL) (($ $ (|List| (|Integer|))) NIL))
 (|destruct| (((|List| $) $) 26)) (|declare| (((|Symbol|) (|List| $)) 47))
 (|convert| (($ (|List| $)) 54) (($ (|String|)) NIL) (($ (|Symbol|)) 16)
            (($ (|Integer|)) 8) (($ (|DoubleFloat|)) 23)
            (((|SExpression|) $) 11) (($ (|SExpression|)) 12))
 (|compile| (((|Symbol|) (|Symbol|) (|List| $)) 50))
 (|coerce| (((|OutputForm|) $) NIL)) (|cdr| (($ $) 49)) (|car| (($ $) 48))
 (|binary| (($ $ (|List| $)) 55)) (|atom?| (((|Boolean|) $) 25))
 (^ (($ $ (|NonNegativeInteger|)) 64) (($ $ (|Integer|)) 63))
 (|Zero| (($) 9 T CONST)) (|One| (($) 10 T CONST)) (= (((|Boolean|) $ $) 59))
 (/ (($ $ $) 65)) (+ (($ $ $) 60)) (* (($ $ $) 61)) (|#| (((|Integer|) $) NIL)))
INFORM
(((|SExpressionCategory| (|String|) (|Symbol|) (|Integer|) (|DoubleFloat|))
  . T)
 ((|ConvertibleTo| (|SExpression|)) . T))
(((|BasicType|) . T) ((|CoercibleTo| (|OutputForm|)) . T)
 ((|ConvertibleTo| (|SExpression|)) . T)
 ((|SExpressionCategory| (|String|) (|Symbol|) (|Integer|) (|DoubleFloat|))
  . T)
 ((|SetCategory|) . T))
((|constructor|
  (NIL
   "Domain of parsed forms which can be passed to the interpreter. This is also the interface between algebra code and facilities in the interpreter."))
 (|compile|
  (((|Symbol|) (|Symbol|) (|List| $))
   "\\spad{compile(f,{} [t1,{} ...,{} tn])} forces the interpreter to compile the function \\spad{f} with signature \\spad{(t1,{} ...,{} tn) -> ?}. returns the symbol \\spad{f} if successful. Error: if \\spad{f} was not defined beforehand in the interpreter,{} or if the \\spad{ti}\\spad{'s} are not valid types,{} or if the compiler fails."))
 (|declare|
  (((|Symbol|) (|List| $))
   "\\spad{declare(t)} returns a name \\spad{f} such that \\spad{f} has been declared to the interpreter to be of type \\spad{t},{} but has not been assigned a value yet. Note: \\spad{t} should be created as \\spad{devaluate(T)\\$Lisp} where \\spad{T} is the actual type of \\spad{f} (this hack is required for the case where \\spad{T} is a mapping type)."))
 (|parse|
  (($ (|String|))
   "\\spad{parse(s)} is the inverse of unparse. It parses a string to InputForm"))
 (|unparse|
  (((|String|) $)
   "\\spad{unparse(f)} returns a string \\spad{s} such that the parser would transform \\spad{s} to \\spad{f}. Error: if \\spad{f} is not the parsed form of a string."))
 (|flatten|
  (($ $)
   "\\spad{flatten(s)} returns an input form corresponding to \\spad{s} with all the nested operations flattened to triples using new local variables. If \\spad{s} is a piece of code,{} this speeds up the compilation tremendously later on."))
 ((|One|) (($) "\\spad{1} returns the input form corresponding to 1."))
 ((|Zero|) (($) "\\spad{0} returns the input form corresponding to 0."))
 (^
  (($ $ (|Integer|))
   "\\spad{a ^ b} returns the input form corresponding to \\spad{a ^ b}.")
  (($ $ (|NonNegativeInteger|))
   "\\spad{a ^ b} returns the input form corresponding to \\spad{a ^ b}."))
 (/
  (($ $ $)
   "\\spad{a / b} returns the input form corresponding to \\spad{a / b}."))
 (*
  (($ $ $)
   "\\spad{a * b} returns the input form corresponding to \\spad{a * b}."))
 (+
  (($ $ $)
   "\\spad{a + b} returns the input form corresponding to \\spad{a + b}."))
 (|lambda|
  (($ $ (|List| (|Symbol|)))
   "\\spad{lambda(code,{} [x1,{} ...,{} xn])} returns the input form corresponding to \\spad{(x1,{} ...,{} xn) +-> code} if \\spad{n > 1},{} or to \\spad{x1 +-> code} if \\spad{n = 1}."))
 (|function|
  (($ $ (|List| (|Symbol|)) (|Symbol|))
   "\\spad{function(code,{} [x1,{} ...,{} xn],{} f)} returns the input form corresponding to \\spad{f(x1,{} ...,{} xn) == code}."))
 (|binary|
  (($ $ (|List| $))
   "\\spad{binary(op,{} [a1,{} ...,{} an])} returns the input form corresponding to \\spad{a1 op a2 op ... op an}."))
 (|convert|
  (($ (|SExpression|))
   "\\spad{convert(s)} makes \\spad{s} into an input form."))
 (|interpret|
  (((|Any|) $) "\\spad{interpret(f)} passes \\spad{f} to the interpreter.")))
(("documentation" 0 5193) ("ancestors" 0 4987) ("parents" 0 4862)
 ("abbreviation" 0 4855) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 3337) ("modemaps" 0 1768) ("sourceFile" 0 1730)
 ("constructorCategory" 0 930) ("constructorModemap" 0 78)
 ("constructorKind" 0 69) ("constructorForm" 0 55) ("NILADIC" 0 20))