)abbrev package CLINDEP ConstantLinearDependence
++ Description:
++ \spad{ConstantLinearDependence(R, F)} supports solving linear
++ systems with coefficients in \spad{Expression(R)} over constants.
++ The parameter \spad{ld} to each function is a list of derivations
++ to use.  By definition element \spad{f} from \spad{Expression(R)}
++ is a constant if for each \spad{d} in \spad{ld} we have \spad{d(f) = 0}.
++ We assume that inputs are normalized in such a way that
++ field of constants is generated by constant kernels.
ConstantLinearDependence(R, F) : Exports == Implementation where
  R : Join(IntegralDomain, Comparable)
  F : FunctionSpace R
  PartialQ ==>  Union(Vector F, "failed")
  BothQ ==> Record(particular : PartialQ, basis : List Vector F)
  LFF ==> List(F -> F)
  Exports ==> with
    linearlyDependentOverConstants? : (Vector F, LFF) -> Boolean
      ++ \spad{linearlyDependentOverConstants?([v1, ..., vn], ld)}
      ++ returns true if the vi's are linearly dependent over
      ++ constants, false otherwise.
    linearDependenceOverConstants : (Vector F, LFF) ->
                                      Union(Vector F, "failed")
      ++ \spad{linearlyDependenceOverConstants([v1, ..., vn], ld)} returns
      ++ \spad{[c1, ..., cn]} if
      ++ \spad{c1*v1 + ... + cn*vn = 0} and not all the ci's are 0, "failed"
      ++ if the vi's are linearly independent over constants.
    particularSolutionOverConstants : (Vector F, F, LFF) -> PartialQ
      ++ \spad{particularSolutionOverConstants([v1, ..., vn], u, ld)} returns
      ++ \spad{[c1, ..., cn]} such that \spad{c1*v1 + ... + cn*vn = u},
      ++ "failed" if no such constants numbers ci's exist.
    particularSolutionOverConstants : (Matrix F, Vector F, LFF) -> PartialQ
      ++ \spad{solveLinearlyOverConstants([v1, ..., vn], u, ld)} returns
      ++ \spad{[c1, ..., cn]} such that \spad{c1*v1 + ... + cn*vn = u},
      ++ "failed" if no such rational numbers ci's exist.
    solveLinearOverConstants : (Vector F, F, LFF) -> BothQ
      ++ \spad{solveLinearOverConstants([v1, ..., vn], u, ld)} returns
      ++ solution of the system  \spad{c1*v1 + ... + cn*vn = u} and
      ++ and a basis of the associated homogeneous system
      ++ \spad{c1*v1 + ... + cn*vn = 0}
    solveLinearOverConstants : (Matrix F, Vector F, LFF) -> BothQ
      ++ \spad{solveLinearOverConstants([v1, ..., vn], u, ld)} returns
      ++ solution of the system  \spad{c1*v1 + ... + cn*vn = u} and
      ++ and a basis of the associated homogeneous system
      ++ \spad{c1*v1 + ... + cn*vn = 0}
    reducedSystem : (Matrix F, Vector F, LFF) ->
                    Record(mat : Matrix F, vec : Vector F)
      ++ reducedSystem(A, v, ld) returns matrix of constants B and
      ++ vector of constants w such
      ++ that \spad{A x = v} and \spad{B x = w}
      ++ have the same solutions over constants.
    reducedSystem : (Matrix(F), LFF) -> Matrix(F)
      ++ reducedSystem(A, ld) returns a matrix of constants B such
      ++ that \spad{A x = 0} and \spad{B x = 0}
      ++ have the same solutions over constants.
    nullSpaceOverConstants : (Matrix F, LFF) -> List Vector F
      ++ nullSpaceOverConstants(A, ld) returns basis of the
      ++ homogeneous system \spad{A*vc = 0} where vc is a
      ++ vector of constants.
    constant_subspace : (List Vector(F),  LFF) ->
                    Record(transform : Matrix(F), basis : List Vector(F))
      ++ constant_subspace(b, ld) returns [M, nb] such that
      ++ nb is basis of subspace spanned by b over F consistng
      ++ of vectors with constant coordinates.  M is the transformation
      ++ matrix, i.e. mnb = M mb where mb (mnb respectively) is matrix
      ++ having b (nb respectively) as rows.

  Implementation ==> add

    EF ==> Expression(F)

    LD ==> LinearDependence(F, EF)

    K1 ==> Kernel(F)

    K2 ==> Kernel(EF)

    MP ==> SparseMultivariatePolynomial(R, K1)

    IE ==> IndexedExponents(K1)

    Lift ==> PolynomialCategoryLifting(IE, K1, R, MP, EF)

    F_to_EF1 : (F, K1 -> EF) -> EF

    DUMMYVAR := '%dummyVar

    kmap(k : K1, ldmvar : List K1, ldmval : List EF, ld : LFF) : EF ==
        for dmvar in ldmvar for dmval in ldmval repeat
            if k = dmvar then return dmval
        is_const := true
        kf := k::F
        for d in ld repeat
            if d(kf) ~= 0 then
                is_const := false
                break
        is_const => kf::EF
        op := operator(operator(k))$EF
        args := argument(k)
        nargs : List(EF)
        if (u := property(op, DUMMYVAR)) case None then
            n := u::None pretend NonNegativeInteger
            da := retract(a1 := second(args))@K1
            if not(member?(da, ldmvar)) then
                ldmvar := cons(da, ldmvar)
                ldmval := cons(new()$Symbol::EF, ldmval)
                sa1 := retract(a1)@Symbol
                ld := cons((ff : F) : F +-> differentiate(ff, sa1), ld)
            if n = 2 then
                da2 := retract(a2 := args(3))@K1
                if not(member?(da2, ldmvar)) then
                    ldmvar := cons(da2, ldmvar)
                    ldmval := cons(new()$Symbol::EF, ldmval)
                    sa2 := retract(a2)@Symbol
                    ld := cons((ff : F) : F +-> differentiate(ff, sa2), ld)
        kmap1 := (kk : K1) : EF +-> kmap(kk, ldmvar, ldmval, ld)
        kernel(op, [F_to_EF1(a, kmap1) for a in argument(k)])$EF

    F_to_EF1(f : F, kmap1 : K1 -> EF) : EF ==
        map(kmap1, (c : R) : EF +-> c::F::EF, numer(f))$Lift
          /map(kmap1, (c : R) : EF +-> c::F::EF, denom(f))$Lift

    F_to_EF(f : F, ld : LFF) : EF ==
        F_to_EF1(f, (k : K1) : EF +-> kmap(k, [], [], ld))

    VF_to_VEF(v : Vector(F), ld : LFF) : Vector(EF) ==
        map(x +-> F_to_EF(x, ld), v)$VectorFunctions2(F, EF)

    MF_to_MEF(m : Matrix(F), ld : LFF) : Matrix(EF) ==
        map(x +-> F_to_EF(x, ld), m)$TwoDimensionalArrayFunctions(
            F, Vector(F), Vector(F), Matrix(F),
            EF, Vector(EF), Vector(EF), Matrix(EF))

    linearlyDependentOverConstants?(v, ld) ==
        linearlyDependent?(VF_to_VEF(v, ld))$LD

    linearDependenceOverConstants(v, ld) ==
        linearDependence(VF_to_VEF(v, ld))$LD

    particularSolutionOverConstants(v : Vector F, u : F, ld : LFF) ==
        particularSolution(VF_to_VEF(v, ld), F_to_EF(u, ld))$LD

    particularSolutionOverConstants(m : Matrix F, v : Vector F, ld : LFF) ==
        particularSolution(MF_to_MEF(m, ld), VF_to_VEF(v, ld))$LD

    solveLinearOverConstants(v : Vector F, u : F, ld : LFF) ==
        solveLinear(VF_to_VEF(v, ld), F_to_EF(u, ld))$LD

    solveLinearOverConstants(m : Matrix F, v : Vector F, ld : LFF) ==
        solveLinear(MF_to_MEF(m, ld), VF_to_VEF(v, ld))$LD

    reducedSystem(m : Matrix F, ld : LFF) ==
        reducedSystem(MF_to_MEF(m, ld))$EF

    reducedSystem(m : Matrix F, v : Vector F, ld : LFF) ==
        reducedSystem(MF_to_MEF(m, ld), VF_to_VEF(v, ld))$EF

    nullSpaceOverConstants(m : Matrix F, ld : LFF) ==
        solveLinearOverConstants(m, new(nrows(m), 0)$Vector(F), ld).basis

    UP  ==> SparseUnivariatePolynomial F

    constant_subspace(b : List Vector(F), ld : LFF
          ) : Record(transform : Matrix(F), basis : List Vector(F)) ==
        empty?(b) => [new(0, 0, 1), []]
        nc := #first(b)
        nr := #b
        m0b := matrix([entries(bv) for bv in b])$Matrix(F)
        m0 := horizConcat(m0b, scalarMatrix(nr, 1))
        m1 := rowEchelon(m0)
        k : Integer := 1
        lpiv : List Integer := []
        lri :  List Integer := []
        for i in 1..nrows(m1) repeat
            k1 := k
            while m1(i, k1) = 0 and k1 <= nc repeat k1 := k1 + 1
            nc < k1 => "iterate"
            k := k1
            m1(i, k) ~= 1 => error "impossible"
            lri := cons(i, lri)
            lpiv := cons(k, lpiv)
        lpiv := cons(nc + 1, lpiv)
        lpiv := reverse!(lpiv)
        lr : List Vector F := []
        ll : List List F := []
        for i in lri repeat
            lpiv1 := lpiv
            kk := first(lpiv1)
            lpiv1 := rest(lpiv1)
            ll1 : List F := []
            for j in 1..nc repeat
                j = kk =>
                    kk := first(lpiv1)
                    lpiv1 := rest(lpiv1)
                for d1 in ld repeat
                    ll1 := cons(d1(m1(i, j)), ll1)
            ll := cons(ll1, ll)
            lr := cons(row(m1, i), lr)
        m := transpose(matrix(ll))
        s1 := nullSpaceOverConstants(m, ld)
        l3 := [lin_comb(bv, lr)$LinearCombinationUtilities(F, UP) for bv in s1]
        m2 := matrix([[bv(i) for i in nc+1..ncols(m0)] for bv in l3]
                    )$Matrix(F)
        [m2, [bv(1..nc) for bv in l3]]


