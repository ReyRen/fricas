)abbrev domain LATJOFM LatticeJoinOfMeets
++ Author: Martin Baker
++ Date Created: Sept 2015
++ Basic Operations:
++ Related Constructors: LatticeMeetOfJoins is complementary domain
++ Keywords: Logic Lattice Meet Join
++ Description: Infinite Lattice which is distributive.
++   Representation held as join of meets.
++ References:
++ http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/

LatticeJoinOfMeets() : Exports == Implementation where

 NNI ==> NonNegativeInteger
 PR ==> Record(rft : %, pout : NNI)
   ++ parse result includes term returned and new index
 ELEMENT ==> Union(_
               const : Record(val : Symbol), _
               var : Record(str : String) _
               )

 Exports == BoundedDistributiveLattice with
   logicT : () -> %
     ++ construct true: a logical constant.
   logicF : () -> %
     ++ construct false (contradiction): a logical constant.
   variable : (v : String) -> %
     ++ construct a variable
   latticeJoinOfMeets : (e : ELEMENT) -> %
     ++ construct a lattice with one element
   emptyLattice : () -> %
     ++ construct an empty lattice
   empty? : (n : %) -> Boolean
     ++ true if empty
   meet : (ln : List %) -> %
     ++ meet of set of elements
   join : (ln : List %) -> %
     ++ join of set of elements
   redux : (n : %) -> %
     ++ attempt to simplify terms
   factor : (n : %) -> List %
     ++ splits n into a list of factors which must be true for the
     ++ whole to be true.
     ++ This assumes that the top level is already a set of factors
     ++ separated by /\ otherwise the result will just be a list with
     ++ one entry: 'n'.
     ++ This is used when converting ILogic to types by using the
     ++ Curry-Howard isomorphism.
   deductions : (ln : List %) -> List %
     ++ assumes ln contains a list of factors which must be true for
     ++ the whole to be true (such as the list produced by factor).
     ++ From this deductions attempts to produce a list of other
     ++ proposition that must also be true by using modus ponens.
     ++ This is used to determine the returned type when converting
     ++ ILogic to types by using the Curry-Howard isomorphism.
   "=" : (a : %, b : %) -> Boolean
     ++ returns true (boolean true) if intuitionisticLogic values
     ++ are the same.
     ++ Translates from Intuitionistic Logic to Boolean Logic
   opType : (n : %) -> Symbol
     ++ if this is a compound op then opType returns the type of
     ++ that op:
     ++ "IMPLY"::Symbol =implies
     ++ "AND"::Symbol=/\
     ++ "OR"::Symbol=\/
     ++ "NOT"::Symbol=~
     ++ "OTHER"::Symbol=not compound op
   getChildren : (n : %) -> List %
     ++ returns child nodes if this is a compound term
     ++ otherwise returns []
   atom? : (n : %) -> Boolean
     ++ returns true if this is an atom, that is a leaf node
     ++ otherwise return false if this is a compound term
   value : (n : %) -> Symbol
     ++ returns:
     ++   "T"::Symbol = T
     ++   "F"::Symbol = _|_
     ++   "E"::Symbol = error
     ++   "P"::Symbol = proposition
     ++   "C"::Symbol = compound
     ++ Constructs lambda term and bind any variables with the name provided
   toString : (n : %) -> String
     ++ creates a string representation of this term and its sub-terms
   toStringUnwrapped : (n : %) -> String
     ++ similar to 'toString' but does not put outer compound terms
     ++ in brackets
   coerce : (n : %) -> LatticeMeetOfJoins
     ++ convert lattice from join-of-meets to meet-of-joins
   coerce : (n : LatticeMeetOfJoins) -> %
     ++ convert lattice from meet-of-joins to join-of-meets

 Implementation == add

   Rep := List(List(ELEMENT))
       ++ This domain is a distributive lattice, this allows us to
       ++ represent the lattice as a meet of joins.
       ++ So the inner list is a list of elements which are joined,
       ++ the outer list represents a meet of these joins.
       ++ The elements of this structure are constants or variables:
       ++ 1) const: Record(val: Symbol)
       ++   holds the true and false values:
       ++   "T"::Symbol = T
       ++   "F"::Symbol = _|_
       ++
       ++ 2) var: Record(str: String)
       ++   holds a proposition name

   -- Constructs a proposition
   proposition(s : String) : % == [[[[s]]]]

   -- literal constructors
   logicT() == [[[["T"::Symbol]]]]
   logicF() == [[[["F"::Symbol]]]]

   emptyLattice() == []$List(List(ELEMENT))

   -- construct a variable
   variable(v : String) : % == [[[[v]]]]

   -- construct a lattice with one element
   latticeJoinOfMeets(e : ELEMENT) : % ==
       [[e]]

   -- true if empty
   empty?(n : %) : Boolean ==
       empty?(n)$Rep

   -- /\ returns the logical 'meet', e.g. 'and'.
   --
   -- simplification rules:
   -- idempotenceMeet for all x: x /\ x -> x ()
   -- idempotenceJoin for all x: x \/ x -> x
   -- absorptionMeetOverJoin for all(x, y): x/\(x\/y)=x
   -- absorptionJoinOverMeet for all(x, y): x\/(x/\y)=x
   --
   _/_\(a : %, b : %) ==
       if empty?(a) then return b
       if empty?(b) then return a
       r : List(List(ELEMENT)) := []
       for innera in a repeat
           for innerb in b repeat
               termLeft : List(ELEMENT) := innera
               termRight : List(ELEMENT) := innerb
               term := concat(termLeft, termRight)$List(ELEMENT)
               r := concat(r, term)$List(List(ELEMENT))
       redux(r)

   -- \/ returns the logical 'join', e.g. 'or'.
   --
   -- simplification rules:
   -- idempotenceMeet for all x: x /\ x -> x ()
   -- idempotenceJoin for all x: x \/ x -> x
   -- absorptionMeetOverJoin for all(x, y): x/\(x\/y)=x
   -- absorptionJoinOverMeet for all(x, y): x\/(x/\y)=x
   --
   _\_/(a : %, b : %) ==
       if empty?(a) then return b
       if empty?(b) then return a
       redux(concat(a pretend Rep, b pretend Rep)$List(List(ELEMENT)))

   meet(ln : List %) : % ==
       r : % := emptyLattice()
       for ele in ln repeat
           r := _/_\(r, ele)
       r

   join(ln : List %) : % ==
       r : % := emptyLattice()
       for ele in ln repeat
           r := _\_/(r, ele)
       r

   -- local function used by removeDuplicatesInTerm which is used by
   -- redux to remove duplicates.
   -- Returns true if elements are equal.
   equalElements(a : ELEMENT, b : ELEMENT) : Boolean ==
       if (a case var) and (a case var) then
           return (a.var.str) = (b.var.str)
       if (a case const)  and (b case const) then
           return (a.const.val) = (b.const.val)
       false

   -- local function used by redux to remove duplicates, that is
   -- apply idempotence. We cannot use the removeDuplicates in List
   -- because ELEMENT does not have ATFINAG or BASTYPE.
   removeDuplicatesInTerm(n : List(ELEMENT)) : List(ELEMENT) ==
       r : List(ELEMENT) := []$List(ELEMENT)
       for e1 in n for ne1 in 1..#n repeat
           match : Boolean := false
           for e2 in n for ne2 in 1..#n repeat
               if e1 = e2 and ne1 < ne2 then match := true
           if not match then r := concat(r, e1)
       r

   -- local function used by redux to remove duplicate lists.
   -- Returns true if lists are equal, that is contain the same elements
   -- (independant of order).
   equalTerms(a : List(ELEMENT), b : List(ELEMENT)) : Boolean ==
       if #a ~= #b then return false
       for a1 in a repeat
           found : Boolean := false
           for b1 in b repeat
               if equalElements(a1, b1) then found := true
           if not found then return false
       true

   -- local function used by redux to apply absorption.
   -- Returns true if a is a sub-term of b.
   subTerm(a : List(ELEMENT), b : List(ELEMENT)) : Boolean ==
       if #a >= #b then return false
       for a1 in a repeat
           found : Boolean := false
           for b1 in b repeat
               if equalElements(a1, b1) then found := true
           if not found then return false
       true

   -- Attempt to simplify terms
   --
   -- simplification rules:
   -- idempotenceMeet for all x: x /\ x -> x ()
   -- idempotenceJoin for all x: x \/ x -> x
   -- absorptionMeetOverJoin for all(x, y): x/\(x\/y)=x
   -- absorptionJoinOverMeet for all(x, y): x\/(x/\y)=x
   --
   -- TODO add rules for top and bottom
   --
   redux(n : %) : % ==
       r : List(List(ELEMENT)) := []$List(List(ELEMENT))
       -- 'modified' set to true if this call of redux has made a reduction
       modified : Boolean := false
       for outer in n for outern in 1..#n repeat
           -- check for idempotence
           newinnerList : List(ELEMENT) := removeDuplicatesInTerm(outer)
           if not equalTerms(newinnerList, outer) then modified := true
           match : Boolean := false
           for inner in n for innern in 1..#n repeat
               if equalTerms(inner, outer) and innern<outern then match := true
           -- check for absorption
           isSubTerm : Boolean := false
           for inner in n repeat
               if subTerm(inner, outer) then isSubTerm := true
           if (not match) and (not isSubTerm)
               then r := concat(r, newinnerList)$List(List(ELEMENT))
               else modified := true
       -- print("LatticeJoinOfMeets.redux"::Symbol << n << _
       --       ", "::Symbol << (r pretend %) << _
       --       " mod="::Symbol << modified)
       -- apply until no more changes
       if modified then redux(r) else r

   -- splits n into a list of factors which must be true for the
   -- whole to be true.
   -- This assumes that the top level is already a set of factors
   -- separated by /\ otherwise the result will just be a list with
   -- one entry: 'n'.
   -- This is used when converting ILogic to types by using the
   -- Curry-Howard isomorphism.
   factor(n : %) : List % ==
       [n]

   -- remove duplicates. Return elements of 'b' except those that are
   -- in 'a'
   -- I would use duplicate removal built into List but that only
   -- works when the list is defined over SETCAT
   removeDup(a : List %, b : List %) : List % ==
       a

   -- assumes ln contains a list of factors which must be true for
   -- the whole to be true (such as the list produced by factor).
   -- From this deductions attempts to produce a list of other
   -- proposition that must also be true by using modus ponens.
   -- This is used to determine the returned type when converting
   -- ILogic to types by using the Curry-Howard isomorphism.
   deductions(ln : List %) : List % ==
       ln

   -- if this is a compound op then opType returns the type of that op:
   -- "IMPLY"::Symbol =implies
   -- "AND"::Symbol=/\
   -- "OR"::Symbol=\/
   -- "NOT"::Symbol=~
   -- "OTHER"::Symbol=not compound op
   opType(n : %) : Symbol ==
       "OTHER"::Symbol

   -- returns true if this is an atom, that is a leaf node
   -- otherwise return false if this is a compound term
   atom?(n : %) : Boolean == false

   -- returns:
   --   "F"::Symbol = _|_
   --   "T"::Symbol = T
   --   "E"::Symbol = error
   --   "P"::Symbol = proposition
   --   "C"::Symbol = compound
   value(n : %) : Symbol ==
       "C"::Symbol

   -- returns child nodes if this is a compound term
   -- otherwise returns []
   getChildren(n : %) : List % ==
       [n]

   -- returns true (boolean true) if values
   -- are the same. The terms must match exactly not just be
   -- equivalent, that is x /\ 1 is not equal to x
   -- Translates from Intuitionistic Logic to Boolean Logic
   a = b ==
       false

   -- return string representation
   toString(n : %) : String ==
       concat ["(", toStringUnwrapped(n), ")"]

   -- local function used by coerce to String
   -- convert variable or literal to String
   stringVarOrLit(a : Union(const : Record(val : Symbol),
                  var : Record(str : String))) : String ==
        if (a case var) then return (a.var.str)::String
        if (a case const) then
            if (a.const.val) = "T"::Symbol then return "T"
            return "F"
        "error"

   -- similar to 'toString' but does not put outer compound terms
   -- in brackets
   toStringUnwrapped(n : %) : String ==
       outerList : List String := []
       r : String := ""
       for outer in n for outern in 1..#n repeat
           innerList : List String := []
           for inner in outer for innern in (1..#outer) repeat
               r := concat(r::String, stringVarOrLit(inner))
               if innern ~= #outer then r := concat(r::String, "_/_\"::String)
           if outern ~= #n then r := concat(r::String, ")_\_/("::String)
       r

   -- local function used by coerce to OutputForm
   -- convert variable or literal to OutputForm
   outputVarOrLit(a : Union(const : Record(val : Symbol),
                  var : Record(str : String))) : OutputForm ==
        if (a case var) then return (a.var.str)::OutputForm
        if (a case const) then return (a.const.val)::OutputForm
        error "outputVarOrLit"

   -- output
   coerce(n : %) : OutputForm ==
       outerList : List OutputForm := []
       r : OutputForm := message("(")
       for outer in n for outern in 1..#n repeat
           innerList : List OutputForm := []
           for inner in outer for innern in (1..#outer) repeat
               r := hconcat(r::OutputForm, outputVarOrLit(inner))
               if innern ~= #outer then
                   r := hconcat(r::OutputForm, message("_/_\"))
           if outern ~= #n then
               r := hconcat(r::OutputForm, message(")_\_/("))
       hconcat(r, message(")"))::OutputForm

   -- convert lattice from join-of-meets to meet-of-joins
   coerce(n : %) : LatticeMeetOfJoins ==
       r : LatticeMeetOfJoins := emptyLattice()
       for outer in n for outern in 1..#n repeat
           term : LatticeMeetOfJoins := emptyLattice()
           for inner in outer for innern in 1..#outer repeat
               ele : LatticeMeetOfJoins := latticeMeetOfJoins(inner)
               term := _/_\(term, ele)
               --print("coerce:"::Symbol << ele << term)
           r := _\_/(r, term)
       r

   -- convert lattice from meet-of-joins to join-of-meets
   coerce(n1 : LatticeMeetOfJoins) : % ==
       r : % := emptyLattice()
       n : List(List(ELEMENT)) := n1 pretend List(List(ELEMENT))
       for outer in n for outern in 1..#n repeat
           term : % := emptyLattice()
           for inner in outer for innern in 1..#outer repeat
               ele : % := latticeJoinOfMeets(inner)
               term := _\_/(term, ele)
               --print("coerce:"::Symbol << ele << term)
           r := _/_\(r, term)
       r

)if false
\section{Frames}
Logic for semi-decidable propositions

Some properties may possibly be provable but not disprovable (or visa versa)
such properties are known as semi-decidable.

We can interpret semi-decidable properties in topology as open sets. See [1]
and [5].

So, for example, imagine that we can measure the value of 'x' to any
arbitrary level of accuracy but there will always be some error.  If x
is not equal to 2 then we can prove it, but if x is exactly 2 then we
can never prove it.

"This allows us to ignore points and do pointless or localic topology"[1]

According to [1], terminology around concepts like 'frame' is not fixed
amongst different authors. Steven Vickers [1] definition (which follows
Johnstone) is:
\begin{itemize}
\item 1) every subset has a join
\item 2) every finite subset has a meet
\item 3) binary meets distribute over joins
\end{itemize}

\subsection{Arbitrary vs. Finite Conjunction and Disjunctions}

This structure makes a distinction between arbitrary and finite
conjunction/disjunctions.  This is related to the convergence of
a sequence (Hausdorff Umgebungsaxiome).

For example: a sequence of ever-smaller open intervals around
zero: (-1, 1), (-1/2, 1/2), (-1/3, 1/3), ...

For unions:
If we take any union of any of these open sets we will get an open set (any
point in that union will have a little neighbourhood around it).

For intersections:
\begin{itemize}
\item If we take a finite number of the sets and take their intersection,
      then we'll still get an open set.
\item If we take the infinite intersection we don't necessarily get an
      open set, in the example above the only point that is in all the
      intervals is 0.  0 on its own isn't an open set, because 0 doesn't
      have a little neighbourhood around it.
\end{itemize}

We cannot determine if arbitrary (infinite) frames are equal because,
however many terms of two frames that start with the same values
we have, they might be still be extended with different values. We
can never check the complete frame because we cannot hold an
infinite structure in a finite computer.

\subsection{Algebra of Frames}
Translating this into lattice algebra:
If A and B are semi-decidable then:
\begin{itemize}
\item Conjunction A/\B: if A and B are semi-decidable, then A/\B is
      semi-decidable (you can test A/\B by testing A and B separately and
      stopping if and when both the tests for A and B stop).
\item Conjunction arbitrary arity /\(Ai): infinite conjunction are not
      semi-decidable. Note: that even given that we can arbitrarily many
      tests at the same time, it still doesn't follow that
      arbitrary conjunctions of semi-decidable propositions are
      semi-decidable: if the first one terminates after 1 minute, the
      second after 2, etc., e'll never be able to stop the test of the
      conjunction even though all tests terminate eventually.
\item Disjunction A\/B: if A and B are semi-decidable, then A\/B is
      semi-decidable
\item Disjunction arbitrary arity \/(Ai): is semi-decidable.  Given Ai,
      we can test \/(Ai) by running all the tests in parallel and
      stopping when any of them stop.
\item Implication: A->B isn't necessarily semi-decidable for the same
      reason that ~A isx't, but we still want to reason about the case
      where A implies B. Therefore, we allow A->B with the meaning that
      A implies B, but only at the 'top level' (you can't nest
      this connective).
\item Top is semi-decidable.
\item Bottom  is semi-decidable.
\item Not: this algebra does not have 'not'/'complement' because if A
      is semi-decidable, it's not necessarily the case that ~A is.
\end{itemize}
See [5]
\subsection{Examples}
For example consider the integers implemented by:
\begin{itemize}
\item zero() -> %
\item increment(%) -> %
\item decrement(%) -> %
\end{itemize}
This constructs a partial order. In this order both meet and join are
guaranteed to exist (glb and lub) for any finite set of elements. However
top and bottom don't exist (\infinity and -\infinity are not integers).
In other words we can't take a meet or a join of an infinite set of elements.

Another example might be a 'tree', this has a bottom element (root) and joins
(including infinite) exist, but meets do not exist and the top element does
not exist.

The general case of these examples are recursively defined types.

I cannot work out how to represent infinite conjunctions, we could supply
a list of arguments like this:
\begin{verbatim}
join(elements : List(%)) : % ==
\end{verbatim}
but to encode the important structure we need to take the limit as the
number of arguments approaches infinity.  So I suspect we need to use
some sort of infinite series. I don't know how to go about this so, for
now, I have removed my attempts to encode a frame structure.
)endif

)if false
\section{Example Structures}
\subsection{BitStreamFrame}
BitStreams are potentially infinite in length. The elements of this
domain are finite sequences that have not yet been completed. So we
can think of these elements as approximations to the actual bitstream.

These BitStream representations are semidecidable, we can determine
if two representations of streams are not equal but we cannot determine
if they are equal. So if two streams are not unequal it does not follow
that they are equal.

We cannot determine if they are equal because, however many terms of two
streams that start with the same values, they might be still be extended
with different values. We can never check the complete bitstream because
we cannot hold an infinite structure in a finite computer.
)endif

