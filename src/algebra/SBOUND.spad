)abbrev domain SBOUND SBoundary
++ Author: Martin Baker
++ Date Created: February 2012
++ Basic Operations: spnt, sipnt, svec, sivec, screenCoords
++ Related Constructors: SCartesian, SArgand, SConformal
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/prog/scratchpad/mycode/graph/
++ Description:
++ This domain implements boundaries for use in scene graph

SBoundary(PT) : Exports == Implementation where
  ++ SBoundary implements boundaries for use in scene graph
  ++ This defines the outer extent of the scene, or of an element
  ++ in the scene, or of some branch in the scene.
  ++ The difference between this boundary and an n-dimensional
  ++ surface, such as IFS, is that boundary must always have a
  ++ well defined inside and an outside.
  ++ SBoundary does not necessarily follow the exact outer contours
  ++ of the shape but just constructs a simple boundary shape where
  ++ all points of the shape are guaranteed to be inside the boundary.
  ++ Currently there are the following boundary forms:
  ++  Simple types:
  ++   "box"::Symbol which is a n-dimensional axis-aligned rectangle.
  ++   "ellipoid"::Symbol which is a n-dimensional axis-aligned ellipse.
  ++  Compound types:
  ++   This is a combination of simple and other compound types such
  ++   as union or intersection.
  ++    "union"::Symbol represents union of supplied list
  ++    "intersection"::Symbol represents intersection of supplied list
  ++  Null types:
  ++   "none" is used for a node which does not have a boundary in
  ++       space, for example, when the boundary of a material node
  ++       is requested.
  ++ The uses of SBoundary are:
  ++ 1) So we know how much to scale a given scene to fit in a
  ++    given size.
  ++ 2) So that we know where to terminate arrows going in out out of
  ++    of the shape.
  ++ 3) To detect if objects intersect (collision detect), or if one
  ++    object is contained completely inside another.

  PT : SPointCategory

  PI ==> PositiveInteger
  NNI ==> NonNegativeInteger
  DF ==> DoubleFloat
  LINE ==> List PT
  PARAMS ==> Union(nul:"none",
               simple : Record(ty : Symbol, control1 : PT, control2 : PT),
               compound : Record(ty : Symbol, parts : List %))
  Exports == with

    nullBoundary : () -> %
      ++ nullBoundary() constructs a null boundary, for example,
      ++ when the boundary of a material node is requested.
    boxBoundary : (c1 : PT, c2 : PT) -> %
      ++ boxBoundary(c1, c2) constructs a box boundary
      ++ (n-dimensional axis-aligned rectangle) with given
      ++ parameters
      ++ c1: PT holds minimum coordinates
      ++ c2: PT holds maximum coordinates
    ellipseBoundary : (c1 : PT, c2 : PT) -> %
      ++ ellipseBoundary(c1, c2) constructs an ellipse boundary
      ++ n-dimensional axis-aligned ellipoid with given
      ++ parameters
      ++ c1: PT holds centre point
      ++ c2: PT holds extent (radius for each coordinate)
    union : (x : List %) -> %
      ++ union(x) constructs a compound boundary from the union
      ++ of x
      ++ x: List % is supplied list of boundaries to form union
    intersection : (x : List %) -> %
      ++ intersection(x) constructs a compound boundary from the
      ++ intersection of x
      ++ x: List % is supplied list of boundaries to form
      ++ intersection.
    sunion : (x : %, y : %) -> %
      ++ sunion(x, y) gives the union of two boundaries as a box,
      ++   that is it gives a box that is external to both.
      ++ x: % is first boundary to be combined
      ++ y: % is second boundary to be combined
    extendToPoint : (n : %, p : PT) -> %
      ++ extendToPoint(n, p) creates a boundary that is the union
      ++   of a boundary and a point.
      ++ n is the boundary
      ++ p is the point
    containsPoint? : (n : %, p : PT) -> Boolean
      ++ containsPoint?(n, p) returns true if the point is inside
      ++   the boundary.
      ++ n is the boundary
      ++ p is the point
    lineIntersect : (n : %, p : PT) -> PT
      ++ lineIntersect(n, p) returns the point where a line,
      ++ from the centre of the boundary to the point p, intersects
      ++ with the boundary.
      ++ n: % is the boundary
      ++ p: PT is the point at the end of the line (outside boundary)
    isNull? : (n : %) -> Boolean
      ++ isNull?(n) returns true if this is a null boundary, that is
      ++ no boundary
    isEllipse? : (n : %) -> Boolean
      ++ isEllipse?(n) returns true if this is a ellipsoid boundary.
    isBox? : (n : %) -> Boolean
      ++ isBox?(n) returns true if this is a rectangular boundary.
    getMin : (n : %) -> PT
      ++ getMin(n) returns minimum coordinate of the boundary.
      ++ n is the boundary
    getMax : (n : %) -> PT
      ++ getMax(n) returns maximum coordinate of the boundary.
      ++ n is the boundary
    getCentre : (n : %) -> PT
      ++ getCentre(n) returns centre coordinate of the boundary.
      ++ n: % is the boundary
    link : (m : %, n : %) -> LINE
      ++ link(m, n) returns a line which is the shortest distance
      ++ between the two boundaries. The line is represented by its
      ++ two endpoints.
      ++ m: % is the first boundary to be linked
      ++ n: % is the second boundary to be linked
    coerce : (bd : %) -> OutputForm
      ++ coerce(bd) outputs description of bd as formatted text

  Implementation == add

    Rep := PARAMS

    -- nullBoundary() constructs a null boundary, for example,
    --      when the boundary of a material node is requested.
    nullBoundary() : % ==
      ["none"]

    -- boxBoundary(c1, c2) constructs a box boundary with given
    -- parameters
    boxBoundary(c1 : PT, c2 : PT) : % ==
      [["box"::Symbol,min(c1,c2),max(c1,c2)]]

    -- ellipseBoundary(c1, c2) constructs a ellipse boundary with given
    -- parameters
    ellipseBoundary(c1 : PT, c2 : PT) : % ==
      [["ellipoid"::Symbol,c1,c2]]

    -- union(x) constructs a compound boundary from the union
    -- of x
    -- x: List % is supplied list of boundaries to form union
    union(x : List %) : % ==
      [["union"::Symbol,x]]

    -- intersection(x) constructs a compound boundary from the
    -- intersection of x
    -- x: List % is supplied list of boundaries to form
    -- intersection.
    intersection(x : List %) : % ==
      [["intersection"::Symbol,x]]

    -- sunion(x, y) gives the union of two boundaries as a box,
    --   that is it gives a box that is external to both.
    -- x: % is first boundary to be combined
    -- y: % is second boundary to be combined
    sunion(x : %, y : %) : % ==
      if x case nul then return y
      if y case nul then return x
      if x case compound then
        p : List % := x.compound.parts
        if #p = 0 then return y
        if #p = 1 then return sunion(first p, y)
        res : % := sunion(first p, y)
        for ptr in 2..#p repeat res := sunion(res, p.ptr)
        return res
      if y case compound then
        p : List % := y.compound.parts
        if #p = 0 then return x
        if #p = 1 then return sunion(first p, x)
        res : % := sunion(first p, x)
        for ptr in 2..#p repeat res := sunion(res, p.ptr)
        return res
      -- since we have reached here then we have simple boundaries
      xmin : PT := x.simple.control1
      xmax : PT := x.simple.control2
      ymin : PT := y.simple.control1
      ymax : PT := y.simple.control2
      if x.simple.ty= "ellipoid"::Symbol then
        xmin := x.simple.control1 - x.simple.control2
        xmax := x.simple.control1 + x.simple.control2
      if y.simple.ty= "ellipoid"::Symbol then
        ymin := y.simple.control1 - y.simple.control2
        ymax := y.simple.control1 + y.simple.control2
      [["box"::Symbol,min(xmin,ymin),max(xmax,ymax)]]

    -- extendToPoint(n, p) creates a boundary that is the union
    --   of a boundary and a point.
    -- n is the boundary
    -- p is the point
    extendToPoint(n : %, p : PT) : % ==
      if n case nul then return [["box"::Symbol,p,p]]
      if n case compound then
        pa : List % := n.compound.parts
        if #pa = 0 then return [["box"::Symbol,p,p]]
        if #pa = 1 then return extendToPoint(first pa, p)
        res : % := extendToPoint(first pa, p)
        for ptr in 2..#pa repeat res := sunion(res, pa.ptr)
        return res
      -- since we have reached here then we have simple boundaries
      xmin : PT := getMin(n)
      xmax : PT := getMax(n)
      [["box"::Symbol,min(xmin,p),max(xmax,p)]]

    -- containsPoint?(n, p) returns true if the point is inside
    --   the boundary.
    -- n is the boundary
    -- p is the point
    containsPoint?(n : %, p : PT) : Boolean ==
      if n case nul then return false
      if n case compound then
        pa : List % := n.compound.parts
        for sub in pa repeat
          if containsPoint?(sub, p) then return true
        return false
      -- since we have reached here then we have simple boundaries
      if isEllipse?(n) then
        pRel := n.simple.control1 - p
        pDist : DF := screenCoordX(pRel)*screenCoordX(pRel) + _
                    screenCoordY(pRel)*screenCoordY(pRel)
        rDist : DF := screenCoordX(n.simple.control2) * _
                    screenCoordX(n.simple.control2) + _
                    screenCoordY(n.simple.control2) * _
                    screenCoordY(n.simple.control2)
        return rDist > pDist
      inBounds?(p, n.simple.control1, n.simple.control2)

    -- lineIntersect(n, p) returns the point where a line,
    -- from the centre of the boundary to the point p, intersects
    -- with the boundary.
    -- n is the boundary
    -- p is the point at the end of the line (outside boundary)
    lineIntersect(n : %, p : PT) : PT ==
      if n case nul then return p
      if n case compound then
        error "cant compute lineIntersect with compound border"
      if isEllipse?(n) then
        -- equation of ellipse is x^2/a^2 + y^2/b^b = 1
        -- equation of straight line is y/x = py/px
        -- solving for x and y gives:
        centre : PT := n.simple.control1
        rad : PT := n.simple.control2
        pRel := p - centre
        a := screenCoordX(rad)
        b := screenCoordY(rad)
        xp := screenCoordX(pRel)
        yp := screenCoordY(pRel)
        ab := a*b
        divisor := sqrt(a*a*yp*yp + b*b*xp*xp)
        x := 0::DF
        y := 0::DF
        if not (divisor = 0::DF) then
          x := ab*xp/divisor
          y := ab*yp/divisor
        --print(vconcat([_
        -- hconcat("lineIntersect Ellipse control1="::OutputForm,_
        -- (n.simple.control1)::OutputForm), _
        -- hconcat(" control2="::OutputForm,(n.simple.control2)::OutputForm),_
        -- hconcat(" p="::OutputForm,p::OutputForm),_
        -- hconcat(" a="::OutputForm,a::OutputForm),_
        -- hconcat(" b="::OutputForm,b::OutputForm),_
        -- hconcat(" xp="::OutputForm,xp::OutputForm),_
        -- hconcat(" yp="::OutputForm,yp::OutputForm),_
        -- hconcat(" ab="::OutputForm,ab::OutputForm),_
        -- hconcat(" divisor="::OutputForm,divisor::OutputForm),_
        -- hconcat(" x="::OutputForm,x::OutputForm),_
        -- hconcat(" y="::OutputForm,y::OutputForm),_
        -- hconcat(" result="::OutputForm,(centre+svec(x,y)$PT)::OutputForm)]))
        return centre+svec(x, y)$PT
      cent := 0.5::DF * (n.simple.control1 + n.simple.control2)
      pRel := p - cent
      rad : PT := 0.5::DF * (n.simple.control2 - n.simple.control1)
      a := screenCoordX(rad)
      b := screenCoordY(rad)
      xp := screenCoordX(pRel)
      yp := screenCoordY(pRel)
      x := if yp ~= 0 then b*xp/yp else a+1::DF
      y := if yp > 0 then b else -b
      if yp < 0 then x := -x
      if x > a or x < -a then
        y := if xp ~= 0 then a*yp/xp else b
        x := if xp > 0 then a else -a
        if xp < 0 then y := -y
      --print(vconcat([_
      -- hconcat("lineIntersect Box control1="::OutputForm,(n.simple.control1)::OutputForm),_
      -- hconcat(" control2="::OutputForm,(n.simple.control2)::OutputForm),_
      -- hconcat(" p="::OutputForm,p::OutputForm),_
      -- hconcat(" cent="::OutputForm,cent::OutputForm),_
      -- hconcat(" a="::OutputForm,a::OutputForm),_
      -- hconcat(" b="::OutputForm,b::OutputForm),_
      -- hconcat(" xp="::OutputForm,xp::OutputForm),_
      -- hconcat(" yp="::OutputForm,yp::OutputForm),_
      -- hconcat(" pRel="::OutputForm,pRel::OutputForm),_
      -- hconcat(" rad="::OutputForm,rad::OutputForm),_
      -- hconcat(" x="::OutputForm,x::OutputForm),_
      -- hconcat(" y="::OutputForm,y::OutputForm)]))
      cent + svec(x, y)$PT

    -- isNull?(n) returns true if this is a null boundary, that is
    -- no boundary
    isNull?(n : %) : Boolean ==
      (n case nul)::Boolean

    -- isEllipse?(n) returns true if this is a ellipsoid boundary.
    isEllipse?(n : %) : Boolean ==
      if not (n case simple) then return false
      (n.simple.ty = "ellipoid"::Symbol)::Boolean

    -- isBox?(n) returns true if this is a rectangular boundary.
    isBox?(n : %) ==
      if not (n case simple) then return false
      (n.simple.ty = "box"::Symbol)::Boolean

    -- getMin(n) returns minimum coordinate of the boundary.
    -- n is the boundary
    getMin(n : %) : PT ==
      if isEllipse?(n) then
        --print(vconcat([_
        -- hconcat("scenebd getMin n.control1="::OutputForm,(n.control1)::OutputForm),_
        -- hconcat(" n.control2="::OutputForm,(n.control2)::OutputForm),_
        -- hconcat(" (n.control1) - (n.control2)="::OutputForm,((n.control1) - (n.control2))::OutputForm)]))
        return toPoint((n.simple.control1) - (n.simple.control2))
      --print(hconcat(["scenebd getMin("::OutputForm,_
      -- n::OutputForm, _
      -- ")="::OutputForm,_
      -- (n.control1)::OutputForm]))
      n.simple.control1

    -- getMax(n) returns maximum coordinate of the boundary.
    -- n is the boundary
    getMax(n : %) : PT ==
      if isEllipse?(n) then
        return toPoint((n.simple.control1) + (n.simple.control2))
      n.simple.control2

    -- getCentre(n) returns centre coordinate of the boundary.
    -- n is the boundary
    getCentre(n : %) : PT ==
      if isEllipse?(n) then return n.simple.control1
      0.5::DF * (n.simple.control1 + n.simple.control2)

    -- link(m, n) returns a line which is the shortest distance
    -- between the two boundaries. The line is represented by its
    -- two endpoints.
    -- m is the first boundary to be linked
    -- n is the second boundary to be linked
    link(m : %, n : %) : LINE ==
      bm := lineIntersect(m, getCentre(n))
      bn := lineIntersect(n, getCentre(m))
      [bm, bn]

    -- output
    coerce(n : %) : OutputForm ==
      ty:OutputForm := outputForm("none "::Symbol)
      if n case simple then ty := (n.simple.ty)::OutputForm
      if n case compound then ty := (n.compound.ty)::OutputForm
      s:OutputForm := hconcat(outputForm("bound "::Symbol),ty)
      if n case nul then return s
      if n case simple then return _
        hconcat([s, message(":"), n.simple.control1::OutputForm,_
               outputForm("->"::Symbol),n.simple.control2::OutputForm])
      sub : OutputForm := bracket([x::OutputForm for x in n.compound.parts])
      hconcat([s,outputForm(":"::Symbol),sub])

)if false

\section{XML code}
There are 2 domains and one package here to support the storage and writing
of XML information, these are:
\begin{itemize}
\item XmlAttribute domain - this holds an attribute
\item XmlElement domain - this holds an element, including a list of all
           its elements and a list of all child elements.
\item ExportXml package - has code for writing out the complete XML file.
\end{itemize}
This XML code is used to write both SVG and X3D files. It was the original
intention that this XML should not be specific to the scenegraph but be
general enough to be used in other places (perhaps it could be used in the
html and mathml code).

However there is some scengraph specific code, that is code to write to
VRML because VRML is a non-XML version of X3D. So by including a outputVRML
function we can support two formats without too much duplication.
\section{XmlAttribute domain}
)endif

