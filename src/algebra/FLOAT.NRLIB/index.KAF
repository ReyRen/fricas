20008               (MAKEPROP '|Float| 'NILADIC T)
(|Float|)
|domain|
(((|Float|)
  (|Join| (|FloatingPointSystem|) (|DifferentialRing|) (|OpenMath|)
          (|CoercibleTo| (|DoubleFloat|)) (|ConvertibleTo| (|InputForm|))
          (|TranscendentalFunctionCategory|) (|arbitraryPrecision|)
          (|arbitraryExponent|)
          (CATEGORY |domain| (SIGNATURE |normalize| ($ $))
           (SIGNATURE |relerror| ($ $ $)) (SIGNATURE |shift| ($ $ (|Integer|)))
           (SIGNATURE |rationalApproximation|
            ((|Fraction| (|Integer|)) $ (|NonNegativeInteger|)))
           (SIGNATURE |rationalApproximation|
            ((|Fraction| (|Integer|)) $ (|NonNegativeInteger|)
             (|NonNegativeInteger|)))
           (SIGNATURE |log2| ($)) (SIGNATURE |log10| ($))
           (SIGNATURE |exp1| ($)) (SIGNATURE |atan| ($ $ $))
           (SIGNATURE |log2| ($ $)) (SIGNATURE |log10| ($ $))
           (SIGNATURE |convert| ($ (|DoubleFloat|)))
           (SIGNATURE |outputFloating| ((|Void|)))
           (SIGNATURE |outputFloating| ((|Void|) (|NonNegativeInteger|)))
           (SIGNATURE |outputFixed| ((|Void|)))
           (SIGNATURE |outputFixed| ((|Void|) (|NonNegativeInteger|)))
           (SIGNATURE |outputGeneral| ((|Void|)))
           (SIGNATURE |outputGeneral| ((|Void|) (|NonNegativeInteger|)))
           (SIGNATURE |outputSpacing| ((|Void|) (|NonNegativeInteger|))))))
 (T |Float|))
(|Join| (|FloatingPointSystem|) (|DifferentialRing|) (|OpenMath|)
        (|CoercibleTo| (|DoubleFloat|)) (|ConvertibleTo| (|InputForm|))
        (|TranscendentalFunctionCategory|) (|arbitraryPrecision|)
        (|arbitraryExponent|)
        (CATEGORY |domain| (SIGNATURE |normalize| ($ $))
         (SIGNATURE |relerror| ($ $ $)) (SIGNATURE |shift| ($ $ (|Integer|)))
         (SIGNATURE |rationalApproximation|
          ((|Fraction| (|Integer|)) $ (|NonNegativeInteger|)))
         (SIGNATURE |rationalApproximation|
          ((|Fraction| (|Integer|)) $ (|NonNegativeInteger|)
           (|NonNegativeInteger|)))
         (SIGNATURE |log2| ($)) (SIGNATURE |log10| ($)) (SIGNATURE |exp1| ($))
         (SIGNATURE |atan| ($ $ $)) (SIGNATURE |log2| ($ $))
         (SIGNATURE |log10| ($ $)) (SIGNATURE |convert| ($ (|DoubleFloat|)))
         (SIGNATURE |outputFloating| ((|Void|)))
         (SIGNATURE |outputFloating| ((|Void|) (|NonNegativeInteger|)))
         (SIGNATURE |outputFixed| ((|Void|)))
         (SIGNATURE |outputFixed| ((|Void|) (|NonNegativeInteger|)))
         (SIGNATURE |outputGeneral| ((|Void|)))
         (SIGNATURE |outputGeneral| ((|Void|) (|NonNegativeInteger|)))
         (SIGNATURE |outputSpacing| ((|Void|) (|NonNegativeInteger|)))))
"/git/fricas/src/algebra/FLOAT.spad"
((|normalize| (*1 *1 *1) (|isDomain| *1 (|Float|)))
 (|relerror| (*1 *1 *1 *1) (|isDomain| *1 (|Float|)))
 (|shift| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|Integer|)) (|isDomain| *1 (|Float|))))
 (|rationalApproximation| (*1 *2 *1 *3)
  (AND (|isDomain| *3 (|NonNegativeInteger|))
       (|isDomain| *2 (|Fraction| (|Integer|))) (|isDomain| *1 (|Float|))))
 (|rationalApproximation| (*1 *2 *1 *3 *3)
  (AND (|isDomain| *3 (|NonNegativeInteger|))
       (|isDomain| *2 (|Fraction| (|Integer|))) (|isDomain| *1 (|Float|))))
 (|log2| (*1 *1) (|isDomain| *1 (|Float|)))
 (|log10| (*1 *1) (|isDomain| *1 (|Float|)))
 (|exp1| (*1 *1) (|isDomain| *1 (|Float|)))
 (|atan| (*1 *1 *1 *1) (|isDomain| *1 (|Float|)))
 (|log2| (*1 *1 *1) (|isDomain| *1 (|Float|)))
 (|log10| (*1 *1 *1) (|isDomain| *1 (|Float|)))
 (|convert| (*1 *1 *2)
            (AND (|isDomain| *2 (|DoubleFloat|)) (|isDomain| *1 (|Float|))))
 (|outputFloating| (*1 *2)
  (AND (|isDomain| *2 (|Void|)) (|isDomain| *1 (|Float|))))
 (|outputFloating| (*1 *2 *3)
  (AND (|isDomain| *3 (|NonNegativeInteger|)) (|isDomain| *2 (|Void|))
       (|isDomain| *1 (|Float|))))
 (|outputFixed| (*1 *2)
  (AND (|isDomain| *2 (|Void|)) (|isDomain| *1 (|Float|))))
 (|outputFixed| (*1 *2 *3)
  (AND (|isDomain| *3 (|NonNegativeInteger|)) (|isDomain| *2 (|Void|))
       (|isDomain| *1 (|Float|))))
 (|outputGeneral| (*1 *2)
  (AND (|isDomain| *2 (|Void|)) (|isDomain| *1 (|Float|))))
 (|outputGeneral| (*1 *2 *3)
  (AND (|isDomain| *3 (|NonNegativeInteger|)) (|isDomain| *2 (|Void|))
       (|isDomain| *1 (|Float|))))
 (|outputSpacing| (*1 *2 *3)
  (AND (|isDomain| *3 (|NonNegativeInteger|)) (|isDomain| *2 (|Void|))
       (|isDomain| *1 (|Float|)))))
((~= (((|Boolean|) $ $) NIL)) (|zero?| (((|Boolean|) $) 26))
 (|wholePart| (((|Integer|) $) 52))
 (|unitNormal|
  (((|Record| (|:| |unit| $) (|:| |canonical| $) (|:| |associate| $)) $) NIL))
 (|unitCanonical| (($ $) NIL)) (|unit?| (((|Boolean|) $) NIL))
 (|truncate| (($ $) 117))
 (|toString| (((|String|) $) 36) (((|String|) $ (|NonNegativeInteger|)) NIL))
 (|tanh| (($ $) 81)) (|tan| (($ $) 69))
 (|subtractIfCan| (((|Union| $ "failed") $ $) NIL))
 (|squareFreePart| (($ $) NIL)) (|squareFree| (((|Factored| $) $) NIL))
 (|sqrt| (($ $) 40)) (|smaller?| (((|Boolean|) $ $) NIL))
 (|sizeLess?| (((|Boolean|) $ $) NIL)) (|sinh| (($ $) 79)) (|sin| (($ $) 67))
 (|sign| (((|Integer|) $) 61)) (|shift| (($ $ (|Integer|)) 59))
 (|sech| (($ $) NIL)) (|sec| (($ $) NIL)) (|sample| (($) NIL T CONST))
 (|round| (($ $) 119)) (|rightRecip| (((|Union| $ #1="failed") $) NIL))
 (|rightPower| (($ $ (|PositiveInteger|)) NIL)
  (($ $ (|NonNegativeInteger|)) NIL))
 (|retractIfCan| (((|Union| (|Integer|) #2="failed") $) 193)
  (((|Union| (|Fraction| (|Integer|)) #2#) $) 189))
 (|retract| (((|Integer|) $) 191) (((|Fraction| (|Integer|)) $) 187))
 (|rem| (($ $ $) NIL)) (|relerror| (($ $ $) 108))
 (|recip| (((|Union| $ #1#) $) 121))
 (|rationalApproximation|
  (((|Fraction| (|Integer|)) $ (|NonNegativeInteger|)) 194)
  (((|Fraction| (|Integer|)) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   186))
 (|quo| (($ $ $) NIL))
 (|principalIdeal|
  (((|Record| (|:| |coef| (|List| $)) (|:| |generator| $)) (|List| $)) NIL))
 (|prime?| (((|Boolean|) $) NIL))
 (|precision| (((|PositiveInteger|)) 71)
  (((|PositiveInteger|) (|PositiveInteger|)) 105
   (|has| $ (|arbitraryPrecision|))))
 (|positive?| (((|Boolean|) $) 112)) (|pi| (($) 33))
 (|patternMatch|
  (((|PatternMatchResult| (|Float|) $) $ (|Pattern| (|Float|))
    (|PatternMatchResult| (|Float|) $))
   NIL))
 (|outputSpacing| (((|Void|) (|NonNegativeInteger|)) 155))
 (|outputGeneral| (((|Void|)) 160) (((|Void|) (|NonNegativeInteger|)) 161))
 (|outputFloating| (((|Void|)) 162) (((|Void|) (|NonNegativeInteger|)) 163))
 (|outputFixed| (((|Void|)) 158) (((|Void|) (|NonNegativeInteger|)) 159))
 (|order| (((|Integer|) $) 55)) (|opposite?| (((|Boolean|) $ $) NIL))
 (|one?| (((|Boolean|) $) 110)) (|nthRoot| (($ $ (|Integer|)) NIL))
 (|normalize| (($ $) 44)) (|norm| (($ $) NIL))
 (|negative?| (((|Boolean|) $) 28))
 (|multiEuclidean| (((|Union| (|List| $) #3="failed") (|List| $) $) NIL))
 (|min| (($ $ $) NIL)
  (($) NIL
   (AND (|not| (|has| $ (|arbitraryExponent|)))
        (|not| (|has| $ (|arbitraryPrecision|))))))
 (|max| (($ $ $) NIL)
  (($) NIL
   (AND (|not| (|has| $ (|arbitraryExponent|)))
        (|not| (|has| $ (|arbitraryPrecision|))))))
 (|mantissa| (((|Integer|) $) 17)) (|log2| (($) 86) (($ $) 92))
 (|log10| (($) 91) (($ $) 93)) (|log| (($ $) 82))
 (|leftRecip| (((|Union| $ #1#) $) NIL))
 (|leftPower| (($ $ (|PositiveInteger|)) NIL)
  (($ $ (|NonNegativeInteger|)) NIL))
 (|lcmCoef|
  (((|Record| (|:| |llcm_res| $) (|:| |coeff1| $) (|:| |coeff2| $)) $ $) NIL))
 (|lcm| (($ $ $) NIL) (($ (|List| $)) NIL)) (|latex| (((|String|) $) NIL))
 (|inv| (($ $) 123))
 (|increasePrecision|
  (((|PositiveInteger|) (|Integer|)) 39 (|has| $ (|arbitraryPrecision|))))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) 199))
 (|hash| (((|SingleInteger|) $) NIL))
 (|gcdPolynomial|
  (((|SparseUnivariatePolynomial| $) (|SparseUnivariatePolynomial| $)
    (|SparseUnivariatePolynomial| $))
   NIL))
 (|gcd| (($ $ $) NIL) (($ (|List| $)) NIL)) (|fractionPart| (($ $) 50))
 (|floor| (($ $) 116))
 (|float| (($ (|Integer|) (|Integer|)) 113)
          (($ (|Integer|) (|Integer|) (|PositiveInteger|)) 114))
 (|factor| (((|Factored| $) $) NIL))
 (|extendedEuclidean|
  (((|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $)) $ $) NIL)
  (((|Union| (|Record| (|:| |coef1| $) (|:| |coef2| $)) #3#) $ $ $) NIL))
 (|exquo| (((|Union| $ "failed") $ $) NIL))
 (|expressIdealMember| (((|Union| (|List| $) "failed") (|List| $) $) NIL))
 (|exponent| (((|Integer|) $) 19)) (|exp1| (($) 94)) (|exp| (($ $) 78))
 (|euclideanSize| (((|NonNegativeInteger|) $) NIL))
 (|divide| (((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $) NIL))
 (|digits| (((|PositiveInteger|)) 106)
  (((|PositiveInteger|) (|PositiveInteger|)) 107
   (|has| $ (|arbitraryPrecision|))))
 (|differentiate| (($ $ (|NonNegativeInteger|)) NIL) (($ $) 122))
 (|decreasePrecision|
  (((|PositiveInteger|) (|Integer|)) 43 (|has| $ (|arbitraryPrecision|))))
 (|csch| (($ $) NIL)) (|csc| (($ $) NIL)) (|coth| (($ $) NIL))
 (|cot| (($ $) NIL)) (|cosh| (($ $) 80)) (|cos| (($ $) 68))
 (|convert| (((|Float|) $) 179) (((|DoubleFloat|) $) 181)
            (((|Pattern| (|Float|)) $) NIL) (((|String|) $) 165)
            (((|InputForm|) $) 177) (($ (|DoubleFloat|)) 185))
 (|commutator| (($ $ $) NIL))
 (|coerce| (((|OutputForm|) $) 169) (($ $) NIL) (($ (|Integer|)) 190)
           (($ (|Fraction| (|Integer|))) NIL) (((|DoubleFloat|) $) 182))
 (|characteristic| (((|NonNegativeInteger|)) NIL)) (|ceiling| (($ $) 118))
 (|bits| (((|PositiveInteger|)) 51)
  (((|PositiveInteger|) (|PositiveInteger|)) 63
   (|has| $ (|arbitraryPrecision|))))
 (|base| (((|PositiveInteger|)) 109)) (|atanh| (($ $) 85))
 (|atan| (($ $) 42) (($ $ $) 49)) (|associator| (($ $ $ $) NIL))
 (|associates?| (((|Boolean|) $ $) NIL)) (|asinh| (($ $) 83))
 (|asin| (($ $) 30)) (|asech| (($ $) NIL)) (|asec| (($ $) NIL))
 (|antiCommutator| (($ $ $) NIL)) (|annihilate?| (((|Boolean|) $ $) NIL))
 (|acsch| (($ $) NIL)) (|acsc| (($ $) NIL)) (|acoth| (($ $) NIL))
 (|acot| (($ $) NIL)) (|acosh| (($ $) 84)) (|acos| (($ $) 45))
 (|abs| (($ $) 48))
 (^ (($ $ (|PositiveInteger|)) 65) (($ $ (|NonNegativeInteger|)) NIL)
  (($ $ (|Integer|)) 87) (($ $ (|Fraction| (|Integer|))) 132) (($ $ $) 124))
 (|Zero| (($) 27 T CONST)) (|One| (($) 31 T CONST))
 (|OMwrite| (((|String|) $) NIL) (((|String|) $ (|Boolean|)) NIL)
  (((|Void|) (|OpenMathDevice|) $) NIL)
  (((|Void|) (|OpenMathDevice|) $ (|Boolean|)) 24))
 (D (($ $ (|NonNegativeInteger|)) NIL) (($ $) NIL))
 (>= (((|Boolean|) $ $) 166)) (> (((|Boolean|) $ $) 35))
 (= (((|Boolean|) $ $) 32)) (<= (((|Boolean|) $ $) NIL))
 (< (((|Boolean|) $ $) 47)) (/ (($ $ $) 41) (($ $ (|Integer|)) 34))
 (- (($ $ $) 46) (($ $) 29)) (+ (($ $ $) 58))
 (* (($ (|PositiveInteger|) $) 62) (($ $ $) 57) (($ (|Integer|) $) 66)
    (($ (|NonNegativeInteger|) $) NIL) (($ $ (|Fraction| (|Integer|))) NIL)
    (($ (|Fraction| (|Integer|)) $) NIL)))
((|HasCategory| $ '(|arbitraryPrecision|))
 (AND (|not| (|HasCategory| $ '(|arbitraryExponent|)))
      (|not| (|HasCategory| $ '(|arbitraryPrecision|)))))
FLOAT
(((|FloatingPointSystem|) . T) ((|DifferentialRing|) . T) ((|OpenMath|) . T)
 ((|CoercibleTo| (|DoubleFloat|)) . T) ((|ConvertibleTo| (|InputForm|)) . T)
 ((|TranscendentalFunctionCategory|) . T) ((|arbitraryPrecision|) . T)
 ((|arbitraryExponent|) . T))
(((|AbelianGroup|) . T) ((|AbelianMonoid|) . T) ((|AbelianSemiGroup|) . T)
 ((|Algebra| (|Fraction| (|Integer|))) . T) ((|Algebra| $) . T)
 ((|Approximate|) . T) ((|ArcHyperbolicFunctionCategory|) . T)
 ((|ArcTrigonometricFunctionCategory|) . T) ((|BasicType|) . T)
 ((|BiModule| |t#1| |t#1|) . T) ((|BiModule| $ $) . T)
 ((|CancellationAbelianMonoid|) . T) ((|CharacteristicZero|) . T)
 ((|CoercibleTo| (|DoubleFloat|)) . T) ((|CoercibleTo| (|OutputForm|)) . T)
 ((|CommutativeRing|) . T) ((|CommutativeStar|) . T) ((|Comparable|) . T)
 ((|ConvertibleTo| (|InputForm|)) . T) ((|ConvertibleTo| (|String|)) . T)
 ((|ConvertibleTo| (|Pattern| (|Float|))) . T)
 ((|ConvertibleTo| (|Float|)) . T) ((|ConvertibleTo| (|DoubleFloat|)) . T)
 ((|DifferentialRing|) . T) ((|DivisionRing|) . T)
 ((|ElementaryFunctionCategory|) . T) ((|EntireRing|) . T)
 ((|EuclideanDomain|) . T) ((|Field|) . T) ((|FloatingPointSystem|) . T)
 ((|GcdDomain|) . T) ((|HyperbolicFunctionCategory|) . T)
 ((|IntegralDomain|) . T) ((|LeftModule| |t#1|) . T) ((|LeftOreRing|) . T)
 ((|Magma|) . T) ((|MagmaWithUnit|) . T) ((|Module| |t#1|) . T)
 ((|Monoid|) . T) ((|NonAssociativeRing|) . T) ((|NonAssociativeRng|) . T)
 ((|NonAssociativeSemiRing|) . T) ((|NonAssociativeSemiRng|) . T)
 ((|OpenMath|) . T) ((|OrderedAbelianGroup|) . T)
 ((|OrderedAbelianMonoid|) . T) ((|OrderedAbelianSemiGroup|) . T)
 ((|OrderedCancellationAbelianMonoid|) . T) ((|OrderedRing|) . T)
 ((|OrderedSet|) . T) ((|PartialOrder|) . T)
 ((|PatternMatchable| (|Float|)) . T) ((|PrincipalIdealDomain|) . T)
 ((|RadicalCategory|) . T) ((|RealConstant|) . T) ((|RealNumberSystem|) . T)
 ((|RetractableTo| (|Fraction| (|Integer|))) . T)
 ((|RetractableTo| (|Integer|)) . T) ((|RightModule| |t#2|) . T) ((|Ring|) . T)
 ((|Rng|) . T) ((|SemiGroup|) . T) ((|SemiRing|) . T) ((|SemiRng|) . T)
 ((|SetCategory|) . T) ((|TranscendentalFunctionCategory|) . T)
 ((|TrigonometricFunctionCategory|) . T) ((|TwoSidedRecip|) . T)
 ((|UniqueFactorizationDomain|) . T) ((|arbitraryExponent|) . T)
 ((|arbitraryPrecision|) . T) ((|canonicalUnitNormal|) . T)
 ((|canonicalsClosed|) . T) ((|noZeroDivisors|) . T) ((|unitsKnown|) . T))
((|constructor|
  (NIL
   "\\spadtype{Float} implements arbitrary precision floating point arithmetic. The number of significant digits of each operation can be set to an arbitrary value (the default is 20 decimal digits). The operation \\spad{float(mantissa,{} exponent,{} \\spadfunFrom{base}{FloatingPointSystem})} for integer \\spad{mantissa},{} \\spad{exponent} specifies the number \\spad{mantissa * \\spadfunFrom{base}{FloatingPointSystem} ^ exponent} The underlying representation for floats is binary not decimal. The implications of this are described below. \\blankline The model adopted is that arithmetic operations are rounded to to nearest unit in the last place,{} that is,{} accurate to within \\spad{2^(-\\spadfunFrom{bits}{FloatingPointSystem})}. Also,{} the elementary functions and constants are accurate to one unit in the last place. A float is represented as a record of two integers,{} the mantissa and the exponent. The \\spadfunFrom{base}{FloatingPointSystem} of the representation is binary,{} hence a \\spad{Record(m: mantissa,{} e: exponent)} represents the number \\spad{m * 2 ^ e}. Though it is not assumed that the underlying integers are represented with a binary \\spadfunFrom{base}{FloatingPointSystem},{} the code will be most efficient when this is the the case (this is \\spad{true} in most implementations of Lisp). The decision to choose the \\spadfunFrom{base}{FloatingPointSystem} to be binary has some unfortunate consequences. First,{} decimal numbers like 0.3 cannot be represented exactly. Second,{} there is a further loss of accuracy during conversion to decimal for output. To compensate for this,{} if \\spad{d} digits of precision are specified,{} \\spad{1 + ceiling(log2(10^d))} bits are used. Two numbers that are displayed identically may therefore be not equal. On the other hand,{} a significant efficiency loss would be incurred if we chose to use a decimal \\spadfunFrom{base}{FloatingPointSystem} when the underlying integer base is binary. \\blankline Algorithms used: For the elementary functions,{} the general approach is to apply identities so that the taylor series can be used,{} and,{} so that it will converge within \\spad{O( sqrt n )} steps. For example,{} using the identity \\spad{exp(x) = exp(x/2)^2},{} we can compute \\spad{exp(1/3)} to \\spad{n} digits of precision as follows. We have \\spad{exp(1/3) = exp(2 ^ (-sqrt s) / 3) ^ (2 ^ sqrt s)}. The taylor series will converge in less than sqrt \\spad{n} steps and the exponentiation requires sqrt \\spad{n} multiplications for a total of \\spad{2 sqrt n} multiplications. Assuming integer multiplication costs \\spad{O( n^2 )} the overall running time is \\spad{O( sqrt(n) n^2 )}. This approach is the best known approach for precisions up to about 10,{} 000 digits at which point the methods of Brent which are \\spad{O( log(n) n^2 )} become competitive. Note also that summing the terms of the taylor series for the elementary functions is done using integer operations. This avoids the overhead of floating point operations and results in efficient code at low precisions. This implementation makes no attempt to reuse storage,{} relying on the underlying system to do \\spadgloss{garbage collection}. \\spad{I} estimate that the efficiency of this package at low precisions could be improved by a factor of 2 if in-place operations were available. \\blankline Running times: in the following,{} \\spad{n} is the number of bits of precision \\indented{5}{\\spad{*},{} \\spad{/},{} \\spad{sqrt},{} \\spad{\\spad{pi}},{} \\spad{exp1},{} \\spad{log2},{} \\spad{log10}: \\spad{ O( n^2 )}} \\indented{5}{\\spad{exp},{} \\spad{log},{} \\spad{sin},{} \\spad{atan}:\\space{2}\\spad{ O( sqrt(n) n^2 )}} The other elementary functions are coded in terms of the ones above."))
 (|outputSpacing|
  (((|Void|) (|NonNegativeInteger|))
   "\\spad{outputSpacing(n)} inserts a space after \\spad{n} (default 10) digits on output; outputSpacing(0) means no spaces are inserted."))
 (|outputGeneral|
  (((|Void|) (|NonNegativeInteger|))
   "\\spad{outputGeneral(n)} sets the output mode to general notation with \\spad{n} significant digits displayed.")
  (((|Void|))
   "\\spad{outputGeneral()} sets the output mode (default mode) to general notation; numbers will be displayed in either fixed or floating (scientific) notation depending on the magnitude."))
 (|outputFixed|
  (((|Void|) (|NonNegativeInteger|))
   "\\spad{outputFixed(n)} sets the output mode to fixed point notation,{} with \\spad{n} digits displayed after the decimal point.")
  (((|Void|))
   "\\spad{outputFixed()} sets the output mode to fixed point notation; the output will contain a decimal point."))
 (|outputFloating|
  (((|Void|) (|NonNegativeInteger|))
   "\\spad{outputFloating(n)} sets the output mode to floating (scientific) notation with \\spad{n} significant digits displayed after the decimal point.")
  (((|Void|))
   "\\spad{outputFloating()} sets the output mode to floating (scientific) notation,{} \\spadignore{i.e.} \\spad{mantissa * 10 exponent} is displayed as \\spad{0.mantissa E exponent}."))
 (|convert|
  (($ (|DoubleFloat|))
   "\\spad{convert(x)} converts a \\spadtype{DoubleFloat} \\spad{x} to a \\spadtype{Float}."))
 (|atan|
  (($ $ $)
   "\\spad{atan(x,{} y)} computes the arc tangent from \\spad{x} with phase \\spad{y}."))
 (|exp1| (($) "\\spad{exp1()} returns exp 1: \\spad{2.7182818284...}."))
 (|log10|
  (($ $) "\\spad{log10(x)} computes the logarithm for \\spad{x} to base 10.")
  (($) "\\spad{log10()} returns \\spad{ln 10}: \\spad{2.3025809299...}."))
 (|log2|
  (($ $) "\\spad{log2(x)} computes the logarithm for \\spad{x} to base 2.")
  (($)
   "\\spad{log2()} returns \\spad{ln 2},{} \\spadignore{i.e.} \\spad{0.6931471805...}."))
 (|rationalApproximation|
  (((|Fraction| (|Integer|)) $ (|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{rationalApproximation(f,{} n,{} b)} computes a rational approximation \\spad{r} to \\spad{f} with relative error \\spad{< b^(-n)},{} that is \\spad{|(r-f)/f| < b^(-n)}.")
  (((|Fraction| (|Integer|)) $ (|NonNegativeInteger|))
   "\\spad{rationalApproximation(f,{} n)} computes a rational approximation \\spad{r} to \\spad{f} with relative error \\spad{< 10^(-n)}."))
 (|shift|
  (($ $ (|Integer|))
   "\\spad{shift(x,{} n)} adds \\spad{n} to the exponent of float \\spad{x}."))
 (|relerror|
  (($ $ $)
   "\\spad{relerror(x,{} y)} computes the absolute value of \\spad{(x - y)/y},{} when \\spad{y \\~= 0}."))
 (|normalize|
  (($ $) "\\spad{normalize(x)} normalizes \\spad{x} at current precision.")))
(("documentation" 0 13434) ("ancestors" 0 11276) ("parents" 0 11021)
 ("abbreviation" 0 11015) ("predicates" 0 10859) ("superDomain" 0 NIL)
 ("operationAlist" 0 4406) ("modemaps" 0 2711) ("sourceFile" 0 2674)
 ("constructorCategory" 0 1412) ("constructorModemap" 0 70)
 ("constructorKind" 0 61) ("constructorForm" 0 51) ("NILADIC" 0 20))