30820               (|ThreeSpaceCategory| R)
|category|
(((|ThreeSpaceCategory| |#1|) (|Category|) (|Ring|)) (T |ThreeSpaceCategory|))
(|Join| (|SetCategory|)
        (CATEGORY |domain| (SIGNATURE |create3Space| ($))
         (SIGNATURE |create3Space| ($ (|SubSpace| 3 |t#1|)))
         (SIGNATURE |numberOfComponents| ((|NonNegativeInteger|) $))
         (SIGNATURE |numberOfComposites| ((|NonNegativeInteger|) $))
         (SIGNATURE |merge| ($ (|List| $))) (SIGNATURE |merge| ($ $ $))
         (SIGNATURE |composite| ($ (|List| $)))
         (SIGNATURE |components| ((|List| $) $))
         (SIGNATURE |composites| ((|List| $) $)) (SIGNATURE |copy| ($ $))
         (SIGNATURE |enterPointData|
          ((|NonNegativeInteger|) $ (|List| (|Point| |t#1|))))
         (SIGNATURE |modifyPointData|
          ($ $ (|NonNegativeInteger|) (|Point| |t#1|)))
         (SIGNATURE |point| ($ $ (|Point| |t#1|)))
         (SIGNATURE |point| ($ $ (|List| |t#1|)))
         (SIGNATURE |point| ($ $ (|NonNegativeInteger|)))
         (SIGNATURE |point| ($ (|Point| |t#1|)))
         (SIGNATURE |point| ((|Point| |t#1|) $))
         (SIGNATURE |point?| ((|Boolean|) $))
         (SIGNATURE |curve| ($ $ (|List| (|Point| |t#1|))))
         (SIGNATURE |curve| ($ $ (|List| (|List| |t#1|))))
         (SIGNATURE |curve| ($ (|List| (|Point| |t#1|))))
         (SIGNATURE |curve| ((|List| (|Point| |t#1|)) $))
         (SIGNATURE |curve?| ((|Boolean|) $))
         (SIGNATURE |closedCurve| ($ $ (|List| (|Point| |t#1|))))
         (SIGNATURE |closedCurve| ($ $ (|List| (|List| |t#1|))))
         (SIGNATURE |closedCurve| ($ (|List| (|Point| |t#1|))))
         (SIGNATURE |closedCurve| ((|List| (|Point| |t#1|)) $))
         (SIGNATURE |closedCurve?| ((|Boolean|) $))
         (SIGNATURE |polygon| ($ $ (|List| (|Point| |t#1|))))
         (SIGNATURE |polygon| ($ $ (|List| (|List| |t#1|))))
         (SIGNATURE |polygon| ($ (|List| (|Point| |t#1|))))
         (SIGNATURE |polygon| ((|List| (|Point| |t#1|)) $))
         (SIGNATURE |polygon?| ((|Boolean|) $))
         (SIGNATURE |mesh|
          ($ $ (|List| (|List| (|Point| |t#1|)))
           (|List| (|SubSpaceComponentProperty|))
           (|SubSpaceComponentProperty|)))
         (SIGNATURE |mesh|
          ($ $ (|List| (|List| (|List| |t#1|)))
           (|List| (|SubSpaceComponentProperty|))
           (|SubSpaceComponentProperty|)))
         (SIGNATURE |mesh|
          ($ $ (|List| (|List| (|Point| |t#1|))) (|Boolean|) (|Boolean|)))
         (SIGNATURE |mesh|
          ($ $ (|List| (|List| (|List| |t#1|))) (|Boolean|) (|Boolean|)))
         (SIGNATURE |mesh| ($ (|List| (|List| (|Point| |t#1|)))))
         (SIGNATURE |mesh|
          ($ (|List| (|List| (|Point| |t#1|))) (|Boolean|) (|Boolean|)))
         (SIGNATURE |mesh| ((|List| (|List| (|Point| |t#1|))) $))
         (SIGNATURE |mesh?| ((|Boolean|) $))
         (SIGNATURE |lp| ((|List| (|Point| |t#1|)) $))
         (SIGNATURE |lllip|
          ((|List| (|List| (|List| (|NonNegativeInteger|)))) $))
         (SIGNATURE |lllp| ((|List| (|List| (|List| (|Point| |t#1|)))) $))
         (SIGNATURE |llprop|
          ((|List| (|List| (|SubSpaceComponentProperty|))) $))
         (SIGNATURE |lprop| ((|List| (|SubSpaceComponentProperty|)) $))
         (SIGNATURE |objects|
          ((|Record| (|:| |points| (|NonNegativeInteger|))
                     (|:| |curves| (|NonNegativeInteger|))
                     (|:| |polygons| (|NonNegativeInteger|))
                     (|:| |constructs| (|NonNegativeInteger|)))
           $))
         (SIGNATURE |check| ($ $))
         (SIGNATURE |subspace| ((|SubSpace| 3 |t#1|) $))
         (SIGNATURE |coerce| ((|OutputForm|) $))))
"/git/fricas/src/algebra/SPACEC.spad"
((|coerce| (*1 *2 *1)
           (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3))
                (|ofCategory| *3 (|Ring|)) (|isDomain| *2 (|OutputForm|))))
 (|create3Space| (*1 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *2)) (|ofCategory| *2 (|Ring|))))
 (|create3Space| (*1 *1 *2)
  (AND (|isDomain| *2 (|SubSpace| 3 *3)) (|ofCategory| *3 (|Ring|))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3))))
 (|numberOfComponents| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|NonNegativeInteger|))))
 (|numberOfComposites| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|NonNegativeInteger|))))
 (|merge| (*1 *1 *2)
  (AND (|isDomain| *2 (|List| *1)) (|ofCategory| *1 (|ThreeSpaceCategory| *3))
       (|ofCategory| *3 (|Ring|))))
 (|merge| (*1 *1 *1 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *2)) (|ofCategory| *2 (|Ring|))))
 (|composite| (*1 *1 *2)
  (AND (|isDomain| *2 (|List| *1)) (|ofCategory| *1 (|ThreeSpaceCategory| *3))
       (|ofCategory| *3 (|Ring|))))
 (|components| (*1 *2 *1)
  (AND (|ofCategory| *3 (|Ring|)) (|isDomain| *2 (|List| *1))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3))))
 (|composites| (*1 *2 *1)
  (AND (|ofCategory| *3 (|Ring|)) (|isDomain| *2 (|List| *1))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3))))
 (|copy| (*1 *1 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *2)) (|ofCategory| *2 (|Ring|))))
 (|enterPointData| (*1 *2 *1 *3)
  (AND (|isDomain| *3 (|List| (|Point| *4)))
       (|ofCategory| *1 (|ThreeSpaceCategory| *4)) (|ofCategory| *4 (|Ring|))
       (|isDomain| *2 (|NonNegativeInteger|))))
 (|modifyPointData| (*1 *1 *1 *2 *3)
  (AND (|isDomain| *2 (|NonNegativeInteger|)) (|isDomain| *3 (|Point| *4))
       (|ofCategory| *1 (|ThreeSpaceCategory| *4)) (|ofCategory| *4 (|Ring|))))
 (|point| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|Point| *3)) (|ofCategory| *1 (|ThreeSpaceCategory| *3))
       (|ofCategory| *3 (|Ring|))))
 (|point| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|List| *3)) (|ofCategory| *1 (|ThreeSpaceCategory| *3))
       (|ofCategory| *3 (|Ring|))))
 (|point| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|NonNegativeInteger|))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))))
 (|point| (*1 *1 *2)
  (AND (|isDomain| *2 (|Point| *3)) (|ofCategory| *3 (|Ring|))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3))))
 (|point| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|Point| *3))))
 (|point?| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|Boolean|))))
 (|curve| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|List| (|Point| *3)))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))))
 (|curve| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|List| (|List| *3)))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))))
 (|curve| (*1 *1 *2)
  (AND (|isDomain| *2 (|List| (|Point| *3))) (|ofCategory| *3 (|Ring|))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3))))
 (|curve| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|List| (|Point| *3)))))
 (|curve?| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|Boolean|))))
 (|closedCurve| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|List| (|Point| *3)))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))))
 (|closedCurve| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|List| (|List| *3)))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))))
 (|closedCurve| (*1 *1 *2)
  (AND (|isDomain| *2 (|List| (|Point| *3))) (|ofCategory| *3 (|Ring|))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3))))
 (|closedCurve| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|List| (|Point| *3)))))
 (|closedCurve?| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|Boolean|))))
 (|polygon| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|List| (|Point| *3)))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))))
 (|polygon| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|List| (|List| *3)))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))))
 (|polygon| (*1 *1 *2)
  (AND (|isDomain| *2 (|List| (|Point| *3))) (|ofCategory| *3 (|Ring|))
       (|ofCategory| *1 (|ThreeSpaceCategory| *3))))
 (|polygon| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|List| (|Point| *3)))))
 (|polygon?| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|Boolean|))))
 (|mesh| (*1 *1 *1 *2 *3 *4)
  (AND (|isDomain| *2 (|List| (|List| (|Point| *5))))
       (|isDomain| *3 (|List| (|SubSpaceComponentProperty|)))
       (|isDomain| *4 (|SubSpaceComponentProperty|))
       (|ofCategory| *1 (|ThreeSpaceCategory| *5)) (|ofCategory| *5 (|Ring|))))
 (|mesh| (*1 *1 *1 *2 *3 *4)
  (AND (|isDomain| *2 (|List| (|List| (|List| *5))))
       (|isDomain| *3 (|List| (|SubSpaceComponentProperty|)))
       (|isDomain| *4 (|SubSpaceComponentProperty|))
       (|ofCategory| *1 (|ThreeSpaceCategory| *5)) (|ofCategory| *5 (|Ring|))))
 (|mesh| (*1 *1 *1 *2 *3 *3)
  (AND (|isDomain| *2 (|List| (|List| (|Point| *4))))
       (|isDomain| *3 (|Boolean|)) (|ofCategory| *1 (|ThreeSpaceCategory| *4))
       (|ofCategory| *4 (|Ring|))))
 (|mesh| (*1 *1 *1 *2 *3 *3)
  (AND (|isDomain| *2 (|List| (|List| (|List| *4))))
       (|isDomain| *3 (|Boolean|)) (|ofCategory| *1 (|ThreeSpaceCategory| *4))
       (|ofCategory| *4 (|Ring|))))
 (|mesh| (*1 *1 *2)
  (AND (|isDomain| *2 (|List| (|List| (|Point| *3))))
       (|ofCategory| *3 (|Ring|)) (|ofCategory| *1 (|ThreeSpaceCategory| *3))))
 (|mesh| (*1 *1 *2 *3 *3)
  (AND (|isDomain| *2 (|List| (|List| (|Point| *4))))
       (|isDomain| *3 (|Boolean|)) (|ofCategory| *4 (|Ring|))
       (|ofCategory| *1 (|ThreeSpaceCategory| *4))))
 (|mesh| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|List| (|List| (|Point| *3))))))
 (|mesh?| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|Boolean|))))
 (|lp| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|List| (|Point| *3)))))
 (|lllip| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|List| (|List| (|List| (|NonNegativeInteger|)))))))
 (|lllp| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|List| (|List| (|List| (|Point| *3)))))))
 (|llprop| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|List| (|List| (|SubSpaceComponentProperty|))))))
 (|lprop| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|List| (|SubSpaceComponentProperty|)))))
 (|objects| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2
                   (|Record| (|:| |points| (|NonNegativeInteger|))
                             (|:| |curves| (|NonNegativeInteger|))
                             (|:| |polygons| (|NonNegativeInteger|))
                             (|:| |constructs| (|NonNegativeInteger|))))))
 (|check| (*1 *1 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *2)) (|ofCategory| *2 (|Ring|))))
 (|subspace| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ThreeSpaceCategory| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *2 (|SubSpace| 3 *3)))))
((~= (((|Boolean|) $ $) 6)) (|subspace| (((|SubSpace| 3 |#1|) $) 6))
 (|polygon?| (((|Boolean|) $) 6))
 (|polygon| (($ $ (|List| (|Point| |#1|))) 6) (($ $ (|List| (|List| |#1|))) 6)
  (($ (|List| (|Point| |#1|))) 6) (((|List| (|Point| |#1|)) $) 6))
 (|point?| (((|Boolean|) $) 6))
 (|point| (($ $ (|Point| |#1|)) 6) (($ $ (|List| |#1|)) 6)
  (($ $ (|NonNegativeInteger|)) 6) (($ (|Point| |#1|)) 6)
  (((|Point| |#1|) $) 6))
 (|objects|
  (((|Record| (|:| |points| (|NonNegativeInteger|))
              (|:| |curves| (|NonNegativeInteger|))
              (|:| |polygons| (|NonNegativeInteger|))
              (|:| |constructs| (|NonNegativeInteger|)))
    $)
   6))
 (|numberOfComposites| (((|NonNegativeInteger|) $) 6))
 (|numberOfComponents| (((|NonNegativeInteger|) $) 6))
 (|modifyPointData| (($ $ (|NonNegativeInteger|) (|Point| |#1|)) 6))
 (|mesh?| (((|Boolean|) $) 6))
 (|mesh|
  (($ $ (|List| (|List| (|Point| |#1|))) (|List| (|SubSpaceComponentProperty|))
    (|SubSpaceComponentProperty|))
   6)
  (($ $ (|List| (|List| (|List| |#1|))) (|List| (|SubSpaceComponentProperty|))
    (|SubSpaceComponentProperty|))
   6)
  (($ $ (|List| (|List| (|Point| |#1|))) (|Boolean|) (|Boolean|)) 6)
  (($ $ (|List| (|List| (|List| |#1|))) (|Boolean|) (|Boolean|)) 6)
  (($ (|List| (|List| (|Point| |#1|)))) 6)
  (($ (|List| (|List| (|Point| |#1|))) (|Boolean|) (|Boolean|)) 6)
  (((|List| (|List| (|Point| |#1|))) $) 6))
 (|merge| (($ (|List| $)) 6) (($ $ $) 6))
 (|lprop| (((|List| (|SubSpaceComponentProperty|)) $) 6))
 (|lp| (((|List| (|Point| |#1|)) $) 6))
 (|llprop| (((|List| (|List| (|SubSpaceComponentProperty|))) $) 6))
 (|lllp| (((|List| (|List| (|List| (|Point| |#1|)))) $) 6))
 (|lllip| (((|List| (|List| (|List| (|NonNegativeInteger|)))) $) 6))
 (|latex| (((|String|) $) 6))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) 6))
 (|hash| (((|SingleInteger|) $) 6))
 (|enterPointData| (((|NonNegativeInteger|) $ (|List| (|Point| |#1|))) 6))
 (|curve?| (((|Boolean|) $) 6))
 (|curve| (($ $ (|List| (|Point| |#1|))) 6) (($ $ (|List| (|List| |#1|))) 6)
  (($ (|List| (|Point| |#1|))) 6) (((|List| (|Point| |#1|)) $) 6))
 (|create3Space| (($) 6) (($ (|SubSpace| 3 |#1|)) 6)) (|copy| (($ $) 6))
 (|composites| (((|List| $) $) 6)) (|composite| (($ (|List| $)) 6))
 (|components| (((|List| $) $) 6)) (|coerce| (((|OutputForm|) $) 6))
 (|closedCurve?| (((|Boolean|) $) 6))
 (|closedCurve| (($ $ (|List| (|Point| |#1|))) 6)
  (($ $ (|List| (|List| |#1|))) 6) (($ (|List| (|Point| |#1|))) 6)
  (((|List| (|Point| |#1|)) $) 6))
 (|check| (($ $) 6)) (= (((|Boolean|) $ $) 6)))
SPACEC
(((|SetCategory|) . T))
(((|BasicType|) . T) ((|CoercibleTo| (|OutputForm|)) . T) ((|SetCategory|) . T))
((|constructor|
  (NIL
   "The category ThreeSpaceCategory is used for creating three dimensional objects using functions for defining points,{} curves,{} polygons,{} constructs and the subspaces containing them."))
 (|coerce|
  (((|OutputForm|) $)
   "\\spad{coerce(s)} returns the \\spadtype{ThreeSpace} \\spad{s} to Output format."))
 (|subspace|
  (((|SubSpace| 3 |#1|) $)
   "\\spad{subspace(s)} returns the \\spadtype{SubSpace} which holds all the point information in the \\spadtype{ThreeSpace},{} \\spad{s}."))
 (|check|
  (($ $)
   "\\spad{check(s)} returns lllpt,{} list of lists of lists of point information about the \\spadtype{ThreeSpace} \\spad{s}."))
 (|objects|
  (((|Record| (|:| |points| (|NonNegativeInteger|))
              (|:| |curves| (|NonNegativeInteger|))
              (|:| |polygons| (|NonNegativeInteger|))
              (|:| |constructs| (|NonNegativeInteger|)))
    $)
   "\\spad{objects(s)} returns the \\spadtype{ThreeSpace},{} \\spad{s},{} in the form of a 3D object record containing information on the number of points,{} curves,{} polygons and constructs comprising the \\spadtype{ThreeSpace}.."))
 (|lprop|
  (((|List| (|SubSpaceComponentProperty|)) $)
   "\\spad{lprop(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a list of subspace component properties,{} and if so,{} returns the list; An error is signaled otherwise."))
 (|llprop|
  (((|List| (|List| (|SubSpaceComponentProperty|))) $)
   "\\spad{llprop(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a list of curves which are lists of the subspace component properties of the curves,{} and if so,{} returns the list of lists; An error is signaled otherwise."))
 (|lllp|
  (((|List| (|List| (|List| (|Point| |#1|)))) $)
   "\\spad{lllp(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a list of components,{} which are lists of curves,{} which are lists of points,{} and if so,{} returns the list of lists of lists; An error is signaled otherwise."))
 (|lllip|
  (((|List| (|List| (|List| (|NonNegativeInteger|)))) $)
   "\\spad{lllip(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a list of components,{} which are lists of curves,{} which are lists of indices to points,{} and if so,{} returns the list of lists of lists; An error is signaled otherwise."))
 (|lp|
  (((|List| (|Point| |#1|)) $)
   "\\spad{lp(s)} returns the list of points component which the \\spadtype{ThreeSpace},{} \\spad{s},{} contains; these points are used by reference,{} \\spadignore{i.e.} the component holds indices referring to the points rather than the points themselves. This allows for sharing of the points."))
 (|mesh?|
  (((|Boolean|) $)
   "\\spad{mesh?(s)} returns \\spad{true} if the \\spadtype{ThreeSpace} \\spad{s} is composed of one component,{} a mesh comprising a list of curves which are lists of points,{} or returns \\spad{false} if otherwise"))
 (|mesh|
  (((|List| (|List| (|Point| |#1|))) $)
   "\\spad{mesh(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a single surface component defined by a list curves which contain lists of points,{} and if so,{} returns the list of lists of points; An error is signaled otherwise.")
  (($ (|List| (|List| (|Point| |#1|))) (|Boolean|) (|Boolean|))
   "\\spad{mesh([[p0],{} [p1],{} ...,{} [pn]],{} close1,{} close2)} creates a surface defined over a list of curves,{} \\spad{p0} through \\spad{pn},{} which are lists of points; the booleans \\spad{close1} and \\spad{close2} indicate how the surface is to be closed: \\spad{close1} set to \\spad{true} means that each individual list (a curve) is to be closed (that is,{} the last point of the list is to be connected to the first point); \\spad{close2} set to \\spad{true} means that the boundary at one end of the surface is to be connected to the boundary at the other end (the boundaries are defined as the first list of points (curve) and the last list of points (curve)); the \\spadtype{ThreeSpace} containing this surface is returned.")
  (($ (|List| (|List| (|Point| |#1|))))
   "\\spad{mesh([[p0],{} [p1],{} ...,{} [pn]])} creates a surface defined by a list of curves which are lists,{} \\spad{p0} through \\spad{pn},{} of points,{} and returns a \\spadtype{ThreeSpace} whose component is the surface.")
  (($ $ (|List| (|List| (|List| |#1|))) (|Boolean|) (|Boolean|))
   "\\spad{mesh(s,{} [ [[r10]...,{} [r1m]],{} [[r20]...,{} [r2m]],{} ...,{} [[rn0]...,{} [rnm]] ],{} close1,{} close2)} adds a surface component to the \\spadtype{ThreeSpace} \\spad{s},{} which is defined over a rectangular domain of size \\spad{WxH} where \\spad{W} is the number of lists of points from the domain \\spad{PointDomain(R)} and \\spad{H} is the number of elements in each of those lists; the booleans \\spad{close1} and \\spad{close2} indicate how the surface is to be closed: if \\spad{close1} is \\spad{true} this means that each individual list (a curve) is to be closed (\\spadignore{i.e.} the last point of the list is to be connected to the first point); if \\spad{close2} is \\spad{true},{} this means that the boundary at one end of the surface is to be connected to the boundary at the other end (the boundaries are defined as the first list of points (curve) and the last list of points (curve)).")
  (($ $ (|List| (|List| (|Point| |#1|))) (|Boolean|) (|Boolean|))
   "\\spad{mesh(s,{} [[p0],{} [p1],{} ...,{} [pn]],{} close1,{} close2)} adds a surface component to the \\spadtype{ThreeSpace},{} which is defined over a list of curves,{} in which each of these curves is a list of points. The boolean arguments \\spad{close1} and \\spad{close2} indicate how the surface is to be closed. Argument \\spad{close1} equal \\spad{true} means that each individual list (a curve) is to be closed,{} \\spadignore{i.e.} the last point of the list is to be connected to the first point. Argument \\spad{close2} equal \\spad{true} means that the boundary at one end of the surface is to be connected to the boundary at the other end,{} \\spadignore{i.e.} the boundaries are defined as the first list of points (curve) and the last list of points (curve).")
  (($ $ (|List| (|List| (|List| |#1|))) (|List| (|SubSpaceComponentProperty|))
    (|SubSpaceComponentProperty|))
   "\\spad{mesh(s,{} [ [[r10]...,{} [r1m]],{} [[r20]...,{} [r2m]],{} ...,{} [[rn0]...,{} [rnm]] ],{} [props],{} prop)} adds a surface component to the \\spadtype{ThreeSpace} \\spad{s},{} which is defined over a rectangular domain of size \\spad{WxH} where \\spad{W} is the number of lists of points from the domain \\spad{PointDomain(R)} and \\spad{H} is the number of elements in each of those lists; lprops is the list of the subspace component properties for each curve list,{} and prop is the subspace component property by which the points are defined.")
  (($ $ (|List| (|List| (|Point| |#1|))) (|List| (|SubSpaceComponentProperty|))
    (|SubSpaceComponentProperty|))
   "\\spad{mesh(s,{} [[p0],{} [p1],{} ...,{} [pn]],{} [props],{} prop)} adds a surface component,{} defined over a list curves which contains lists of points,{} to the \\spadtype{ThreeSpace} \\spad{s}; props is a list which contains the subspace component properties for each surface parameter,{} and prop is the subspace component property by which the points are defined."))
 (|polygon?|
  (((|Boolean|) $)
   "\\spad{polygon?(s)} returns \\spad{true} if the \\spadtype{ThreeSpace} \\spad{s} contains a single polygon component,{} or \\spad{false} otherwise."))
 (|polygon|
  (((|List| (|Point| |#1|)) $)
   "\\spad{polygon(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a single polygon component defined by a list of points,{} and if so,{} returns the list of points; An error is signaled otherwise.")
  (($ (|List| (|Point| |#1|)))
   "\\spad{polygon([p0,{} p1,{} ...,{} pn])} creates a polygon defined by a list of points,{} \\spad{p0} through \\spad{pn},{} and returns a \\spadtype{ThreeSpace} whose component is the polygon.")
  (($ $ (|List| (|List| |#1|)))
   "\\spad{polygon(s,{} [[r0],{} [r1],{} ...,{} [rn]])} adds a polygon component defined by a list of points \\spad{r0} through \\spad{rn},{} which are lists of elements from the domain \\spad{PointDomain(m,{} R)} to the \\spadtype{ThreeSpace} \\spad{s},{} where \\spad{m} is the dimension of the points and \\spad{R} is the \\spadtype{Ring} over which the points are defined.")
  (($ $ (|List| (|Point| |#1|)))
   "\\spad{polygon(s,{} [p0,{} p1,{} ...,{} pn])} adds a polygon component defined by a list of points,{} \\spad{p0} throught \\spad{pn},{} to the \\spadtype{ThreeSpace} \\spad{s}."))
 (|closedCurve?|
  (((|Boolean|) $)
   "\\spad{closedCurve?(s)} returns \\spad{true} if the \\spadtype{ThreeSpace} \\spad{s} contains a single closed curve component,{} \\spadignore{i.e.} the first element of the curve is also the last element,{} or \\spad{false} otherwise."))
 (|closedCurve|
  (((|List| (|Point| |#1|)) $)
   "\\spad{closedCurve(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a single closed curve component defined by a list of points in which the first point is also the last point,{} all of which are from the domain \\spad{PointDomain(m,{} R)} and if so,{} returns the list of points. An error is signaled otherwise.")
  (($ (|List| (|Point| |#1|)))
   "\\spad{closedCurve(lp)} sets a list of points defined by the first element of \\spad{lp} through the last element of \\spad{lp} and back to the first elelment again and returns a \\spadtype{ThreeSpace} whose component is the closed curve defined by \\spad{lp}.")
  (($ $ (|List| (|List| |#1|)))
   "\\spad{closedCurve(s,{} [[lr0],{} [lr1],{} ...,{} [lrn],{} [lr0]])} adds a closed curve component defined by a list of points \\spad{lr0} through \\spad{lrn},{} which are lists of elements from the domain \\spad{PointDomain(m,{} R)},{} where \\spad{R} is the \\spadtype{Ring} over which the point elements are defined and \\spad{m} is the dimension of the points,{} in which the last element of the list of points contains a copy of the first element list,{} \\spad{lr0}. The closed curve is added to the \\spadtype{ThreeSpace},{} \\spad{s}.")
  (($ $ (|List| (|Point| |#1|)))
   "\\spad{closedCurve(s,{} [p0,{} p1,{} ...,{} pn,{} p0])} adds a closed curve component which is a list of points defined by the first element \\spad{p0} through the last element \\spad{pn} and back to the first element \\spad{p0} again,{} to the \\spadtype{ThreeSpace} \\spad{s}."))
 (|curve?|
  (((|Boolean|) $)
   "\\spad{curve?(s)} queries whether the \\spadtype{ThreeSpace},{} \\spad{s},{} is a curve,{} \\spadignore{i.e.} has one component,{} a list of list of points,{} and returns \\spad{true} if it is,{} or \\spad{false} otherwise."))
 (|curve|
  (((|List| (|Point| |#1|)) $)
   "\\spad{curve(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a single curve defined by a list of points and if so,{} returns the curve,{} \\spadignore{i.e.} list of points. An error is signaled otherwise.")
  (($ (|List| (|Point| |#1|)))
   "\\spad{curve([p0,{} p1,{} p2,{} ...,{} pn])} creates a space curve defined by the list of points \\spad{p0} through \\spad{pn},{} and returns the \\spadtype{ThreeSpace} whose component is the curve.")
  (($ $ (|List| (|List| |#1|)))
   "\\spad{curve(s,{} [[p0],{} [p1],{} ...,{} [pn]])} adds a space curve which is a list of points \\spad{p0} through \\spad{pn} defined by lists of elements from the domain \\spad{PointDomain(m,{} R)},{} where \\spad{R} is the \\spadtype{Ring} over which the point elements are defined and \\spad{m} is the dimension of the points,{} to the \\spadtype{ThreeSpace} \\spad{s}.")
  (($ $ (|List| (|Point| |#1|)))
   "\\spad{curve(s,{} [p0,{} p1,{} ...,{} pn])} adds a space curve component defined by a list of points \\spad{p0} through \\spad{pn},{} to the \\spadtype{ThreeSpace} \\spad{s}."))
 (|point?|
  (((|Boolean|) $)
   "\\spad{point?(s)} queries whether the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of a single component which is a point and returns the boolean result."))
 (|point|
  (((|Point| |#1|) $)
   "\\spad{point(s)} checks to see if the \\spadtype{ThreeSpace},{} \\spad{s},{} is composed of only a single point and if so,{} returns the point. An error is signaled otherwise.")
  (($ (|Point| |#1|))
   "\\spad{point(p)} returns a \\spadtype{ThreeSpace} object which is composed of one component,{} the point \\spad{p}.")
  (($ $ (|NonNegativeInteger|))
   "\\spad{point(s,{} i)} adds a point component which is placed into a component list of the \\spadtype{ThreeSpace},{} \\spad{s},{} at the index given by \\spad{i}.")
  (($ $ (|List| |#1|))
   "\\spad{point(s,{} [x,{} y,{} z])} adds a point component defined by a list of elements which are from the \\spad{PointDomain(R)} to the \\spadtype{ThreeSpace},{} \\spad{s},{} where \\spad{R} is the \\spadtype{Ring} over which the point elements are defined.")
  (($ $ (|Point| |#1|))
   "\\spad{point(s,{} p)} adds a point component defined by the point,{} \\spad{p},{} specified as a list from \\spad{List(R)},{} to the \\spadtype{ThreeSpace},{} \\spad{s},{} where \\spad{R} is the \\spadtype{Ring} over which the point is defined."))
 (|modifyPointData|
  (($ $ (|NonNegativeInteger|) (|Point| |#1|))
   "\\spad{modifyPointData(s,{} i,{} p)} changes the point at the indexed location \\spad{i} in the \\spadtype{ThreeSpace},{} \\spad{s},{} to that of point \\spad{p}. This is useful for making changes to a point which has been transformed."))
 (|enterPointData|
  (((|NonNegativeInteger|) $ (|List| (|Point| |#1|)))
   "\\spad{enterPointData(s,{} [p0,{} p1,{} ...,{} pn])} adds a list of points from \\spad{p0} through \\spad{pn} to the \\spadtype{ThreeSpace},{} \\spad{s},{} and returns the index,{} to the starting point of the list."))
 (|copy|
  (($ $)
   "\\spad{copy(s)} returns a new \\spadtype{ThreeSpace} that is an exact copy of \\spad{s}."))
 (|composites|
  (((|List| $) $)
   "\\spad{composites(s)} takes the \\spadtype{ThreeSpace} \\spad{s},{} and creates a list containing a unique \\spadtype{ThreeSpace} for each single composite of \\spad{s}. If \\spad{s} has no composites defined (composites need to be explicitly created),{} the list returned is empty. Note that not all the components need to be part of a composite."))
 (|components|
  (((|List| $) $)
   "\\spad{components(s)} takes the \\spadtype{ThreeSpace} \\spad{s},{} and creates a list containing a unique \\spadtype{ThreeSpace} for each single component of \\spad{s}. If \\spad{s} has no components defined,{} the list returned is empty."))
 (|composite|
  (($ (|List| $))
   "\\spad{composite([s1,{} s2,{} ...,{} sn])} will create a new \\spadtype{ThreeSpace} that is a union of all the components from each \\spadtype{ThreeSpace} in the parameter list,{} grouped as a composite."))
 (|merge|
  (($ $ $)
   "\\spad{merge(s1,{} s2)} will create a new \\spadtype{ThreeSpace} that has the components of \\spad{s1} and \\spad{s2}; Groupings of components into composites are maintained.")
  (($ (|List| $))
   "\\spad{merge([s1,{} s2,{} ...,{} sn])} will create a new \\spadtype{ThreeSpace} that has the components of all the ones in the list; Groupings of components into composites are maintained."))
 (|numberOfComposites|
  (((|NonNegativeInteger|) $)
   "\\spad{numberOfComposites(s)} returns the number of supercomponents,{} or composites,{} in the \\spadtype{ThreeSpace},{} \\spad{s}; Composites are arbitrary groupings of otherwise distinct and unrelated components; A \\spadtype{ThreeSpace} need not have any composites defined at all and,{} outside of the requirement that no component can belong to more than one composite at a time,{} the definition and interpretation of composites are unrestricted."))
 (|numberOfComponents|
  (((|NonNegativeInteger|) $)
   "\\spad{numberOfComponents(s)} returns the number of distinct object components in the indicated \\spadtype{ThreeSpace},{} \\spad{s},{} such as points,{} curves,{} polygons,{} and constructs."))
 (|create3Space|
  (($ (|SubSpace| 3 |#1|))
   "\\spad{create3Space(s)} creates a \\spadtype{ThreeSpace} object containing objects pre-defined within some \\spadtype{SubSpace} \\spad{s}.")
  (($)
   "\\spad{create3Space()} creates a \\spadtype{ThreeSpace} object capable of holding point,{} curve,{} mesh components and any combination.")))
(("documentation" 0 14396) ("ancestors" 0 14315) ("parents" 0 14291)
 ("abbreviation" 0 14284) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 11713) ("modemaps" 0 3712) ("sourceFile" 0 3674)
 ("constructorCategory" 0 135) ("constructorModemap" 0 56)
 ("constructorKind" 0 45) ("constructorForm" 0 20))