)abbrev domain SEG Segment
++ Author:  Stephen M. Watt
++ Date Created:  December 1986
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: range, segment
++ Examples:
++ References:
++ Description:
++   This type is used to specify a range of values from type \spad{S}.

Segment(S : Type) : SegmentCategory(S) with
    if S has OrderedRing then SegmentExpansionCategory(S, List S)
  == add

    Rep := Record(low : S, high : S, incr : Integer)

    a..b == [a, b, 1]
    low s == s.low
    high s == s.high
    incr s == s.incr
    segment(a, b) == [a, b, 1]
    BY(s, r) == [low(s), high(s), r]

    if S has SetCategory then
      (s1 : %) = (s2 : %) ==
        s1.low = s2.low and s1.high = s2.high and s1.incr = s2.incr

      coerce(s : %) : OutputForm ==
        seg := SEGMENT(s.low::OutputForm, s.high::OutputForm)
        s.incr = 1 => seg
        infix(message(" by "), seg, s.incr::OutputForm)

    convert(a : S) : % == [a, a, 1]

    if S has ConvertibleTo InputForm then
        INFORM1 ==> InputFormFunctions1(%)

        convert(s : %) : InputForm ==

            seg := packageCall('SEGMENT,
                               [convert(low(s))@InputForm,
                                convert(high(s))@InputForm])$INFORM1
            if one?(incr s)
            then seg
            else packageCall('BY,
                             [seg, convert(incr s)@InputForm])$INFORM1

    if S has AbelianSemiGroup then
        (i : S + s : %) ==
            [i + low(s), i + high(s), incr(s)]
        (s : % + i : S) ==
            [low(s) + i, high(s) + i, incr(s)]

    if S has AbelianGroup then
        (s : % - i : S) ==
            [low(s) - i, high(s) - i, incr(s)]

    if S has OrderedRing then

      reverse(s : %) : % == [high(s), low(s), -incr(s)]

      expand(ls : List %) : List S ==
        lr := []$List(S)
        for s in ls repeat
          l := low(s)
          h := high(s)
          inc := (incr s)::S
          zero? inc => error "Cannot expand a segment with an increment of zero"
          if inc > 0 then
            while l <= h repeat
              lr := concat(l, lr)
              l := l + inc
          else
            while l >= h repeat
              lr := concat(l, lr)
              l := l + inc
        reverse! lr

      expand(s : %) == expand([s]$List(%))$%
      map(f : S->S, s : %) : List S ==
        lr := []$List(S)
        l := low(s)
        h := high(s)
        inc := (incr s)::S
        if inc > 0 then
          while l <= h repeat
            lr := concat(f l, lr)
            l := l + inc
        else
          while l >= h repeat
            lr := concat(f l, lr)
            l := l + inc
        reverse! lr

