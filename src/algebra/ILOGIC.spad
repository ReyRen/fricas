)abbrev domain ILOGIC ILogic
++ Author: Martin Baker
++ Date Created: March 2011
++ Basic Operations:
++ Related Constructors:
++ Keywords: intuitionisticLogic
++ Description: ILogic is an algebra with
++ true, false and other 'unproven' values
++ References:
++ http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/intuitionistic/index.htm

ILogic() : Exports == Implementation where

 NNI ==> NonNegativeInteger
 PR ==> Record(rft : %, pout : NNI)
   ++ parse result includes term returned and new index

 Exports == BoundedLattice with
  logicT : () -> %
    ++ true is a logical constant.
  logicF : () -> %
    ++ false (contradiction) is a logical constant.
  proposition : (s : String) -> %
    ++ Constructs a proposition
  implies : (%, %) -> %
    ++ implies(a, b) returns the logical implication
    ++ of ILogic a and b.
    ++ a is premise, b is conclusion, result is false (contradiction)
    ++ if premise=true and conclusion=false
    ++ does not mean there is a causal connection
  redux : (n : %) -> %
    ++ attempt to simplify theory
    ++ apply recursively to subnodes
    ++ normally this should not be necessary since logic values are
    ++ interpreted when constructed
  factor : (n : %) -> List %
    ++ splits n into a list of factors which must be true for the
    ++ whole to be true.
    ++ This assumes that the top level is already a set of factors
    ++ separated by /\ otherwise the result will just be a list with
    ++ one entry: 'n'.
    ++ This is used when converting ILogic to types by using the
    ++ Curry-Howard isomorphism.
  deductions : (ln : List %) -> List %
    ++ assumes ln contains a list of factors which must be true for
    ++ the whole to be true (such as the list produced by factor).
    ++ From this deductions attempts to produce a list of other
    ++ proposition that must also be true by using modus ponens.
    ++ This is used to determine the returned type when converting
    ++ ILogic to types by using the Curry-Howard isomorphism.
  "=" : (a : %, b : %) -> Boolean
    ++ returns true (boolean true) if intuitionisticLogic values
    ++ are the same.
    ++ Translates from Intuitionistic Logic to Boolean Logic
  _~ : % -> %
    ++ ~(x) returns the logical complement of x.
    ++ TODO not sure if complement should be included here?
    ++ intuitionistic logic can have complement but has different axioms
    ++ to complement in Boolean algebra.
    ++ Equivalent capability can be provided by implication.
  opType : (n : %) -> Symbol
    ++ if this is a compound op then opType returns the type of
    ++ that op:
    ++ "IMPLY"::Symbol =implies
    ++ "AND"::Symbol=/\
    ++ "OR"::Symbol=\/
    ++ "NOT"::Symbol=~
    ++ "OTHER"::Symbol=not compound op
  getChildren : (n : %) -> List %
    ++ returns child nodes if this is a compound term
    ++ otherwise returns []
  atom? : (n : %) -> Boolean
    ++ returns true if this is an atom, that is a leaf node
    ++ otherwise return false if this is a compound term
  value : (n : %) -> Symbol
    ++ returns:
    ++   "T"::Symbol = T
    ++   "F"::Symbol = _|_
    ++   "E"::Symbol = error
    ++   "P"::Symbol = proposition
    ++   "C"::Symbol = compound
    ++ Constructs lambda term and bind any variables with the name provided
  parseIL : (t1 : String) -> %
    ++ Constructs intuitionistic logic terms from a string
    ++ notation assumes format like this:
    ++ <term> : := var | <term>/\<term> | <term>\/<term> |
    ++            <term>-><term> | "("<term>")"
  parseIL2 : (t1 : String, pin : NNI) -> PR
    ++ Constructs intuitionistic logic terms from a string
    ++ notation assumes format like this:
    ++ <term2> : := var | "("<term>")"
    ++ <term> : := var | <term>/\<term> | <term>\/<term> |
    ++            <term>-><term> | "("<term>")"
  parseILTerm : (t1 : String, pin : NNI) -> PR
    ++ parseTerm is used by parseIL. It would rarely be called
    ++ externally but it is here to allow it to call parseIL
    ++ that is to allow circular calls
  toString : (n : %) -> String
    ++ creates a string representation of this term and its sub-terms
  toStringUnwrapped : (n : %) -> String
    ++ similar to 'toString' but does not put outer compound terms
    ++ in brackets

 Implementation == add

  Rep := Union(_
               const : Record(val : Symbol), _
               var : Record(str : String), _
               binaryOp : Record(typ : Symbol, c1 : %, c2 : %), _
               unaryOp : Record(typ : Symbol, c1 : %)_
               )
    ++ this allows us to represent an intuitionistic
    ++ expression as a tree structure where the nodes are
    ++ one of:
    ++ 1) const: Record(val: Symbol)
    ++   holds the true and false values:
    ++   "T"::Symbol = T
    ++   "F"::Symbol = _|_
    ++
    ++ 2) var: Record(str: String)
    ++   holds a proposition name
    ++
    ++ 3) binaryOp: Record(typ: Symbol, c1: %, c2: %)
    ++   holds binary operations:
    ++   "IMPLY"::Symbol =implies
    ++   "AND"::Symbol=/\
    ++   "OR"::Symbol=\/
    ++ 4) unaryOp: Record(typ: Symbol, c1: %)
    ++   holds unary operations the only one is
    ++   "NOT"::Symbol = ~

  -- Constructs a proposition
  proposition(s : String) : % == [[s]]

  -- literal constructors
  logicT() == [["T"::Symbol]]
  logicF() == [["F"::Symbol]]

  -- not operator: returns the logical complement
  -- in general case 'x' this will generate a new element '~x'
  -- but for specific cases we can apply the simplification rules:
  -- ~T -> F
  -- ~(~T) -> T
  ~ b ==
      -- apply rule: ~T -> F
      if (b case const) then
          if (b.const.val = "T"::Symbol) then return [["F"::Symbol]]
      -- apply rule: ~(~T) -> T
      if (b case unaryOp) then
          c : % := b.unaryOp.c1
          if (c case unaryOp) then
              d : % := c.unaryOp.c1
              if (d case const) then
                  if (d.const.val = "T"::Symbol) then return [["F"::Symbol]]
      [["NOT"::Symbol, b]]

  -- /\ returns the logical 'meet', e.g. 'and'.
  --
  -- simplification rules:
  -- ~x /\ x -> F
  -- x /\ ~x -> F
  -- x /\ x -> x
  -- F /\ x -> F
  -- x /\ F -> F
  -- x /\ T -> x
  -- T /\ x -> x
  --
  _/_\(a : %, b : %) ==
      -- apply rule: F /\ x -> F
      if (a case const) then
          if (a.const.val = "F"::Symbol) then return [["F"::Symbol]]
      -- apply rule: x /\ F -> F
      if (b case const) then
          if (b.const.val = "F"::Symbol) then return [["F"::Symbol]]
      -- apply rule: x /\ x -> x
      if a = b then
          return a
      -- apply rule: x /\ ~x -> F
      if a = (~b) then
          return [["F"::Symbol]]
      -- apply rule: ~x /\ x -> F
      if (~a) = b then
          return [["F"::Symbol]]
      -- apply rule: x /\ T -> x
      if (b case const) then
          if (b.const.val = "T"::Symbol) then return a
      -- apply rule: T /\ x -> x
      if (a case const) then
          if (a.const.val = "T"::Symbol) then return b
      [["AND"::Symbol, a, b]]

  -- \/ returns the logical 'join', e.g. 'or'.
  --
  -- simplification rules:
  -- T \/ x -> T
  -- x \/ T -> T
  -- x \/ x -> x
  -- x \/ _|_ -> x
  -- _|_ \/ x -> x
  --
  _\_/(a : %, b : %) ==
      -- apply rule: T \/ x -> T
      if (a case const) then
          if (a.const.val = "T"::Symbol) then return [["T"::Symbol]]
      -- apply rule: x \/ T -> T
      if (b case const) then
          if (b.const.val = "T"::Symbol) then return [["T"::Symbol]]
      -- apply rule: x \/ x -> x
      if a = b then
          return a
      -- apply rule: x \/ _|_ -> x
      if (b case const) then
          if (b.const.val = "F"::Symbol) then return a
      -- apply rule: _|_ \/ x -> x
      if (a case const) then
          if (a.const.val = "F"::Symbol) then return b
      [["OR"::Symbol, a, b]]

  -- implies(a, b) returns the logical implication
  -- of ILogic a and b.
  -- a is premise, b is conclusion, result is false (contradiction)
  -- if premise=true and conclusion=false
  -- does not mean there is a causal connection
  implies(a : %, b : %) ==
      if (a case const) and (b case const) then
          if (a.const.val ~= "F"::Symbol) and (b.const.val = "F"::Symbol) then return [["F"::Symbol]]
          return [["T"::Symbol]]
      [["IMPLY"::Symbol, a, b]]

  -- attempt to simplify theory
  -- apply recursively to subnodes
  -- normally this should not be necessary since logic values are
  -- interpreted when constructed
  --
  -- simplification rules:
  -- ~T -> F
  -- ~(~T) -> T
  -- ~x /\ x -> F
  -- x /\ ~x -> F
  -- x /\ x -> x
  -- F /\ x -> F
  -- x /\ F -> F
  -- x /\ T -> x
  -- T /\ x -> x
  -- T \/ x -> T
  -- x \/ T -> T
  -- x \/ x -> x
  -- x \/ _|_ -> x
  -- _|_ \/ x -> x
  --
  redux(n : %) : % ==
      if n case const then
          return n
      if n case var then
          return n
      if n case binaryOp then
          if n.binaryOp.typ = "IMPLY"::Symbol then
              return implies(redux(n.binaryOp.c1), redux(n.binaryOp.c2))
          if n.binaryOp.typ = "AND"::Symbol then
              return _/_\(redux(n.binaryOp.c1), redux(n.binaryOp.c2))
          if n.binaryOp.typ = "OR"::Symbol then
              return _\_/(redux(n.binaryOp.c1), redux(n.binaryOp.c2))
      if n case unaryOp then
          return ~(redux(n.unaryOp.c1))
      n

  -- splits n into a list of factors which must be true for the
  -- whole to be true.
  -- This assumes that the top level is already a set of factors
  -- seperated by /\ otherwise the result will just be a list with
  -- one entry: 'n'.
  -- This is used when converting ILogic to types by using the
  -- Curry-Howard isomorphism.
  factor(n : %) : List % ==
      if ~(n case binaryOp) then return [n]
      if ~(n.binaryOp.typ = "AND"::Symbol) then return [n]
      ch : List % := getChildren(n)
      concat(factor(first ch), factor(second ch))

  -- remove duplicates. Return elements of 'b' except those that are
  -- in 'a'
  -- I would use duplicate removal built into List but that only
  -- works when the list is defined over SETCAT
  removeDup(a : List %, b : List %) : List % ==
      res : List % := []
      for b1 in b repeat
          fnd : Boolean := false()
          for a1 in a repeat
              if a1 = b1 then fnd := true()
          if not fnd then res := concat(res, b1)
      res

  -- a single iteration for deductions below.
  deductions1(ln : List %) : List % ==
      res : List % := []
      for n in ln repeat
          if n case binaryOp then
              if n.binaryOp.typ = "IMPLY"::Symbol then
                  ch : List % := getChildren(n)
                  for n2 in ln repeat
                      if (first ch) = n2 then res := concat(res, second ch)
      res

  -- assumes ln contains a list of factors which must be true for
  -- the whole to be true (such as the list produced by factor).
  -- From this deductions attempts to produce a list of other
  -- proposition that must also be true by using modus ponens.
  -- This is used to determine the returned type when converting
  -- ILogic to types by using the Curry-Howard isomorphism.
  deductions(ln : List %) : List % ==
      res : List % := []
      thisres : List % := deductions1(ln)
      res := concat(res, thisres)$(List %)
      -- these deductions may lead to further deductions so we
      -- need to apply again until there are no more deductions
      emptyres : Boolean := empty?(thisres)$(List %)
      loopbreaker := 1::NNI
      while not emptyres and (loopbreaker<20)repeat
          allres : List % := concat(ln, res)
          thisres := deductions1(allres)
          thisres := removeDup(res, thisres)
          thisres := removeDup(allres, thisres)
          res := concat(res, thisres)$(List %)
          emptyres := empty?(thisres)$(List %)
          loopbreaker := loopbreaker + 1
      res

  -- if this is a compound op then opType returns the type of that op:
  -- "IMPLY"::Symbol =implies
  -- "AND"::Symbol=/\
  -- "OR"::Symbol=\/
  -- "NOT"::Symbol=~
  -- "OTHER"::Symbol=not compound op
  opType(n : %) : Symbol ==
      if n case binaryOp then return n.binaryOp.typ
      if n case unaryOp then return "NOT"::Symbol
      "OTHER"::Symbol

  -- returns true if this is an atom, that is a leaf node
  -- otherwise return false if this is a compound term
  atom?(n : %) : Boolean == (n case var) or (n case const)

  -- returns:
  --   "F"::Symbol = _|_
  --   "T"::Symbol = T
  --   "E"::Symbol = error
  --   "P"::Symbol = proposition
  --   "C"::Symbol = compound
  value(n : %) : Symbol ==
      if n case const then
          if (n.const.val = "F"::Symbol) then return "F"::Symbol
          if (n.const.val = "T"::Symbol) then return "T"::Symbol
          return "E"::Symbol
      if n case var then
          return "P"::Symbol
      "C"::Symbol

  -- returns child nodes if this is a compound term
  -- otherwise returns []
  getChildren(n : %) : List % ==
      if atom?(n) then return []
      if n case binaryOp then
          return [n.binaryOp.c1, n.binaryOp.c2]
      if n case unaryOp then
          return [n.unaryOp.c1]

  -- returns true (boolean true) if intuitionisticLogic values
  -- are the same. The terms must match exactly not just be
  -- equivalent, that is x /\ 1 is not equal to x
  -- Translates from Intuitionistic Logic to Boolean Logic
  a = b ==
      (a case const) and (b case const) =>
          a.const.val = 'F and b.const.val = 'F => true
          a.const.val = 'T and b.const.val = 'T => true
          false
      (a case var) and (b case var) =>
          -- variable node so compare names
          a.var.str = b.var.str => true
          false
      (a case binaryOp) and (b case binaryOp) =>
          -- binary node which has two subnodes c1 and c2
          a.binaryOp.typ ~= b.binaryOp.typ => false
          (a.binaryOp.c1 = b.binaryOp.c1) and
             (a.binaryOp.c2 = b.binaryOp.c2) => true
          false
      (a case unaryOp) and (b case unaryOp) =>
          -- unary node which has a subnode c1
          a.unaryOp.typ ~= b.unaryOp.typ => false
          a.unaryOp.c1 = b.unaryOp.c1 => true
          false
      false

  parseBracketTerm(t1 : String, pin : NNI) : PR ==
      p1 := pin
      trm : % := logicT()
      ch := qelt(t1, p1)
      if not (ch = char("(")) then
          error "bracket term must start with ("
          return [trm, p1]
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
          error "opening but no closing bracket"
          return [trm, p1]
      r2 := parseILTerm(t1, p1)
      trm := r2.rft
      p1 := r2.pout
      ch := qelt(t1, p1)
      if not (ch = char(")")) then
          error "can't find closing bracket"
          return [trm, p1]
      p1 := p1 + (1::NNI)
      [trm, p1]

  -- parse /\ term
  -- expects first term to be read already
  -- should now be pointing to /\ characters
  parseILand(t1 : String, pin : NNI, firstTerm : %) : PR ==
      p1 := pin
      pt : NNI := pin
      trm : % := logicT()
      ch := qelt(t1, p1)
      if not (ch = char("/")) then
          error "expecting /\"
          return [trm, p1]
      p1 := p1 + (1::NNI)
      ch := qelt(t1, p1)
      if not (ch = char("\")) then
          error "expecting /\"
          return [trm, p1]
      p1 := p1 + (1::NNI)
      --print("st ch="::Symbol << ch)
      r : PR := parseILTerm(t1, p1)
      secondTerm := r.rft
      p1 := r.pout
      [_/_\(firstTerm, secondTerm), p1]

  -- parse \/ term
  -- expects first term to be read already
  -- should now be pointing to \/ characters
  parseILor(t1 : String, pin : NNI, firstTerm : %) : PR ==
      p1 := pin
      pt : NNI := pin
      trm : % := logicT()
      ch := qelt(t1, p1)
      if not (ch = char("\")) then
          error "expecting \/"
          return [trm, p1]
      p1 := p1 + (1::NNI)
      ch := qelt(t1, p1)
      if not (ch = char("/")) then
          error "expecting \/"
          return [trm, p1]
      p1 := p1 + (1::NNI)
      --print("st ch="::Symbol << ch)
      r : PR := parseILTerm(t1, p1)
      secondTerm := r.rft
      p1 := r.pout
      [_\_/(firstTerm, secondTerm), p1]

  -- parse -> term
  -- expects first term to be read already
  -- should now be pointing to -> characters
  parseILfn(t1 : String, pin : NNI, firstTerm : %) : PR ==
      p1 := pin
      pt : NNI := pin
      trm : % := logicT()
      ch := qelt(t1, p1)
      if not (ch = char("-")) then
          error "expecting ->"
          return [trm, p1]
      p1 := p1 + (1::NNI)
      ch := qelt(t1, p1)
      if not (ch = char(">")) then
          error "expecting ->"
          return [trm, p1]
      p1 := p1 + (1::NNI)
      --print("st ch="::Symbol << ch)
      r : PR := parseILTerm(t1, p1)
      secondTerm := r.rft
      p1 := r.pout
      [implies(firstTerm, secondTerm), p1]

  -- construct a type by parsing a string t1
  -- pin is index to string at start of parse
  parseILName(t1 : String, pin : NNI) : PR ==
      vnm : String := ""
      pt : NNI := pin
      ch := qelt(t1, pt)
      --print("st ch="::Symbol << ch::String)
      while alphanumeric?(ch) repeat
          vnm := concat(vnm, ch)
          pt := pt + (1::NNI)
          if pt > maxIndex(t1) then
              return [proposition(vnm), pt]
          ch := qelt(t1, pt)
      [proposition(vnm), pt]

  parseILTerm(t1 : String, pin : NNI) : PR ==
      p1 := pin
      res : % := logicT()
      ch := qelt(t1, p1)
      --print("parseTerm ch=" << ch << " p1=" << string(p1))
      -- first remove leading spaces
      while ch = char(" ") repeat
          p1 := p1 + (1::NNI)
          if p1 > maxIndex(t1) then
              --print("parseTerm(" << t1 << ") 1 giving:" << toString(res))
              return [res, p1]
          ch := qelt(t1, p1)
      r : PR := [res, p1]
      if alphabetic?(ch) then r := parseILName(t1, p1)
      if ch = char("(") then r := parseBracketTerm(t1, p1)
      res := r.rft
      p1 := r.pout
      -- now check for compound term
      if p1 > maxIndex(t1) then
          --print("parseTerm(", t1, ") 2 giving:" << toString(res))
          return [res, p1]
      ch := qelt(t1, p1)
      if ch = char(" ") then
          p1 := p1 + (1::NNI)
          if p1 > maxIndex(t1) then
              --print("parseTerm(" << t1 << ") 3 giving:" << toString(res))
              return [res, p1]
      ch := qelt(t1, p1)
      if ch = char("/") then
          r := parseILand(t1, p1, res)
          res := r.rft
          p1 := r.pout
      if ch = char("\") then
          r := parseILor(t1, p1, res)
          res := r.rft
          p1 := r.pout
      if ch = char("-") then
          r := parseILfn(t1, p1, res)
          res := r.rft
          p1 := r.pout
      [res, p1]

  -- Constructs intuitionistic logic terms from a string
  -- notation assumes format like this:
  -- <term> : := var | <term>/\<term> | <term>\/<term> |
  --            <term>-><term> | "("<term>")"
  parseIL2(t1 : String, pin : NNI) : PR ==
      p1 := pin
      res : % := logicT()
      ch := qelt(t1, p1)
      --print("parseIL ch=" << ch << " p1=" << string(p1))
      -- first remove leading spaces
      while ch = char(" ") repeat
          p1 := p1 + (1::NNI)
          if p1 > maxIndex(t1) then
              --print("parseTerm(", t1, ") 1 giving:"::Symbol << toString(res))
              return [res, p1]
          ch := qelt(t1, p1)
      r : PR := [res, p1]
      if alphabetic?(ch) then r := parseILName(t1, p1)
      if ch = char("(") then r := parseBracketTerm(t1, p1)
      res := r.rft
      p1 := r.pout
      [res, p1]

  -- Constructs intuitionistic logic terms from a string
  -- notation assumes format like this:
  -- <term> : := var | <term>/\<term> | <term>\/<term> |
  --            <term>-><term> | "("<term>")"
  parseIL(t1 : String) : % ==
      r := parseILTerm(t1, minIndex(t1)::NNI)
      --print("parseIL(", t1, ") giving:"::Symbol << r)
      r.rft

  -- return string representation
  toString(n : %) : String ==
      if n case const then
          if (n.const.val = "F"::Symbol) then return "__|__"
          if (n.const.val = "T"::Symbol) then return "T"
          return "?"
      if n case var then
          return n.var.str
          --print("toString case i1="::Symbol << s << n)
      if n case binaryOp then
          -- binary node which has two subnodes c1 and c2
          s1 : String := "->"
          if n.binaryOp.typ = "AND"::Symbol then s1 := "/\"
          if n.binaryOp.typ = "OR"::Symbol then s1 := "\/"
          return concat(["(", toString(n.binaryOp.c1), s1,
                         toString(n.binaryOp.c2), ")"])
      if n case unaryOp then
          -- unary node which has a subnode c1
          return concat(["~(", toString(n.unaryOp.c1), ")"])
      error "toString: unexpected representation"

  -- similar to 'toString' but does not put outer compound terms
  -- in brackets
  toStringUnwrapped(n : %) : String ==
      if n case const then
          if (n.const.val = "F"::Symbol) then return "__|__"
          if (n.const.val = "T"::Symbol) then return "T"
          return "?"
      if n case var then
          return n.var.str
          --print("toString case i1="::Symbol << s << n)
      if n case binaryOp then
          -- binary node which has two subnodes c1 and c2
          s1 : String := "->"
          if n.binaryOp.typ = "AND"::Symbol then s1 := "/\"
          if n.binaryOp.typ = "OR"::Symbol then s1 := "\/"
          return concat([toString(n.binaryOp.c1), s1, toString(n.binaryOp.c2)])
      if n case unaryOp then
          -- unary node which has a subnode c1
          return concat(["~(", toString(n.unaryOp.c1), ")"])
      error "toStringUnwrapped: unexpected representation"

  -- output
  coerce(n : %) : OutputForm ==
      n case const =>
          (n.const.val = "F"::Symbol) => message("__|__")
          n.const.val = "T"::Symbol => message("T")
          message("?")
      n case var => message(n.var.str)
          --print("toString case i1="::Symbol << s << n)
      n case binaryOp =>
          -- binary node which has two subnodes c1 and c2
          s1 : OutputForm := message("->")
          if n.binaryOp.typ = "AND"::Symbol then s1 := message("/\")
          if n.binaryOp.typ = "OR"::Symbol then s1 := message("\/")
          paren(infix(s1, (n.binaryOp.c1)::OutputForm,
                         (n.binaryOp.c2)::OutputForm))
      n case unaryOp =>
          -- unary node which has a subnode c1
          hconcat([message("~("), (n.unaryOp.c1)::OutputForm,
                          message(")")])$OutputForm
      error "coerce: unexpected representation"

)if false
\section{Infinite (unbounded) Lattices}
\subsection{Distributive Lattices}
Not every lattice is distributive but those that are have some interesting
properties which can be investigated by using these domains.

If the lattice is distributive then we can take advantage of this and make
the representation more efficient by representing it as either:

meet-of-joins
\begin{verbatim}
(a\/b\/...) /\ (c\/d\/...) /\ ...
\end{verbatim}

join-of-meets
\begin{verbatim}
(a/\b/\...) \/ (c/\d/\...) \/ ...
\end{verbatim}

So the representation is a list of lists like this:
\begin{verbatim}
Rep := List List Union(_
               const : Record(val : Symbol), _
               var : Record(str : String) _
               )
\end{verbatim}

For a finite lattice then:
if meet is distributive over join,
then join is also distributive over meet.
and
if join is also distributive over meet,
then meet is distributive over join.

We can therefore always convert between join-of-meets and meet-of-joins
by 'multiplying' out the terms and applying the idempotence + absorption
axioms.

We therefore only need one of these domains to represent a distributive
lattice structure. However I have provided both to allow conversions
between the two types to be provided.

I look at this like a polynomial for lattices and these conversions are
like solving a polynomial.

Here is an test session to show how it works:
\begin{verbatim}
-- first setup some variables
MOJ := LatticeMeetOfJoins

   (1)  LatticeMeetOfJoins
                                                              Type: Type
a := variable("a")$MOJ

   (2)  ("a")
                                                Type: LatticeMeetOfJoins
b := variable("b")$MOJ

   (3)  ("b")
                                                Type: LatticeMeetOfJoins
c := variable("c")$MOJ

   (4)  ("c")
                                                Type: LatticeMeetOfJoins
d := variable("d")$MOJ

   (5)  ("d")
                                                Type: LatticeMeetOfJoins
-- test 'and'
land := a /\ b

   (6)  ("a")/\("b")
                                                Type: LatticeMeetOfJoins
-- opposite
landOp := land::LatticeJoinOfMeets

   (7)  ("a"/\"b")
                                                Type: LatticeJoinOfMeets
-- test or
lor := a \/ b

   (8)  ("a"\/"b")
                                                Type: LatticeMeetOfJoins
-- opposite
lorOp := lor::LatticeJoinOfMeets

   (9)  ("a")\/("b")
                                                Type: LatticeJoinOfMeets
-- test idempotence (should return 'a')
a /\ a

   (10)  ("a")
                                                Type: LatticeMeetOfJoins
a \/ a

   (11)  ("a")
                                                Type: LatticeMeetOfJoins
-- test absorption (should return 'a')
a/\(a\/b)

   (12)  ("a")
                                                Type: LatticeMeetOfJoins
a\/(a/\b)

   (13)  ("a")
                                                Type: LatticeMeetOfJoins
-- test composite constructions
landor := land \/ c

   (14)  ("a"\/"c")/\("b"\/"c")
                                                Type: LatticeMeetOfJoins
landorOp := landor::LatticeJoinOfMeets

   (15)  ("a"/\"b")\/("c")
                                                Type: LatticeJoinOfMeets
landorOpOp := landorOp::LatticeMeetOfJoins

   (16)  ("a"\/"c")/\("b"\/"c")
                                                Type: LatticeMeetOfJoins
landorand := landor /\ d

   (17)  ("a"\/"c")/\("b"\/"c")/\("d")
                                                Type: LatticeMeetOfJoins
landorandOp := landorand::LatticeJoinOfMeets

   (18)  ("a"/\"b"/\"d")\/("c"/\"d")
                                                Type: LatticeJoinOfMeets
landorandOpOp := landorandOp::LatticeMeetOfJoins

   (19)  ("a"\/"c")/\("b"\/"c")/\("d")
                                                Type: LatticeMeetOfJoins
(20) -> \end{verbatim}
)endif

