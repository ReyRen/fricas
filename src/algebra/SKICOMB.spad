)abbrev domain SKICOMB SKICombinators
++ Author: Martin Baker
++ Date Created: March 2011
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/prog/scratchpad/mycode/computation/ski/

SKICombinators(UT) : Exports == Implementation where

 UT : VarCat
 NNI==> NonNegativeInteger
 PR ==> Record(rft : %, pout : NNI)
   ++ parse result includes term returned and new index

 Exports == SetCategory with
  ski : (x : %, y : %) -> %
    ++ Constructs a node combinator over combinators
  ski : (t1 : UT) -> %
    ++ Constructs variable combinator
  I : () -> %
    ++ Constructs a I combinator
  K : () -> %
    ++ Constructs a K combinator
  S : () -> %
    ++ Constructs a S combinator
  parseSki : (t1 : String) -> %
    ++ Constructs combinators from a string
  parseTerm : (t1 : String, pin : NNI) -> PR
    ++ parseTerm is used by parseSki. It would rarely be called
    ++ externally but it is here to allow it to call parseSki
    ++ that is to allow circular calls
  getChildren : (n : %) -> List %
    ++ returns child nodes if this is a compound term
    ++ otherwise returns []
  atom? : (n : %) -> Boolean
    ++ returns true if this is an atom, that is a leaf node
    ++ otherwise return false if this is a compound term
  variable? : (n : %) -> Boolean
    ++ returns true if this is an variable
  isI? : (n : %) -> Boolean
    ++ returns true if this is an I combinator node
  isK? : (n : %) -> Boolean
    ++ returns true if this is a K combinator node
  isS? : (n : %) -> Boolean
    ++ returns true if this is a S combinator node
  getVariable : (n : %) -> UT
    ++ returns the variable, if this is not a
    ++ variable then return I
  freeVariable? : (n : %, s : UT) -> Boolean
    ++ the variable indicated by 's' is free if it does
    ++ not appear in node 'n' or any of its subnodes.
  redux : (n : %) -> %
    ++ weak reduction - apply this combinator to rearrange its
    ++ subnodes then apply recursively to its subnodes.
  "=":(x:%, y:%) -> Boolean
    ++ return true if equal (deep search) that is: all terms
    ++ at all levels in tree must be equal to return true
    ++ all terms must be exactly equal, not just equivalent, that is
    ++ SKK=I will return false even though 'SKK' and 'I' have the
    ++ same effect
  toString : (n : %) -> String
    ++ output

 Implementation == add

  Rep := Union(_
         lf : Symbol, _
         nd : Record(c1 : %, c2 : %), _
         vr : UT_
         )
    ++ this allows us to represent a combinator expression
    ++ as a tree structure where the nodes are one of:
    ++
    ++ 1) lf: Symbol
    ++     This node contains the combinator terms themselves currently
    ++     coded as:
    ++     I combinator = "I"::Symbol
    ++     K combinator = "K"::Symbol
    ++     S combinator = "S"::Symbol
    ++
    ++ 2) Record(c1: %, c2: %)
    ++     This represents a branch in the tree.  Adjacent nodes
    ++     represent function application.
    ++
    ++ 3) UT
    ++     this represents a variable (function)
    ++

  -- Constructs a node combinator over another combinators
  ski(x : %, y : %) : % == [[x, y]]

  -- Constructs variable combinator
  ski(t1 : UT) : % ==
    [t1]

  -- Constructs a I combinator
  I() : % == ["I"::Symbol]

  -- Constructs a K combinator
  K() : % == ["K"::Symbol]

  -- Constructs a S combinator
  S() : % == ["S"::Symbol]

  parseBracketTerm(t1 : String, pin : NNI) : PR ==
    p1 := pin
    ch := qelt(t1, p1)
    if not (ch = char("(")) then
      error "bracket term must start with ("
      return [["I"::Symbol],p1]
    p1 := p1 + (1::NNI)
    if p1 > maxIndex(t1) then
      error "opening but no closing bracket"
      return [["I"::Symbol],p1]
    r2 := parseTerm(t1, p1)
    trm := r2.rft
    p1 := r2.pout
    ch := qelt(t1, p1)
    if not (ch = char(")")) then
      error "can't find closing bracket"
      return [["I"::Symbol],p1]
    p1 := p1 + (1::NNI)
    [trm, p1]

  -- t1 is string term to be parsed
  -- pin is an integer pointer to the first character in t1 to be
  -- parsed
  parseCombinatorTerm(t1 : String, pin : NNI) : PR ==
    p1 := pin
    ch := qelt(t1, p1)
    if ch = char("I") then
      return [["I"::Symbol],p1 + (1::NNI)]
    if ch = char("K") then
      return [["K"::Symbol],p1 + (1::NNI)]
    if ch = char("S") then
      return [["S"::Symbol],p1 + (1::NNI)]
    error "invalid combinator"
    [["I"::Symbol],p1 + (1::NNI)]

  -- t1 is string term to be parsed
  -- pin is an integer pointer to the first character in t1 to be
  -- parsed
  parseOneTerm(t1 : String, pin : NNI) : PR ==
    p1 := pin
    res:% := ["I"::Symbol]
    ch := qelt(t1, p1)
    --print(message "parseTerm ch=" << ch << _
    --  message " p1=" << string(p1))
    -- first remove leading spaces
    while ch = char(" ") repeat
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        --print(message "parseTerm(" << t1 << _
        --  message ") 1 giving:" << toString(res))
        return [res, p1]
      ch := qelt(t1, p1)
    if alphabetic?(ch) then
      if upperCase?(ch) then
        r := parseCombinatorTerm(t1, p1)
        res := r.rft
        p1 := r.pout
        --print(message "parseTerm(" << t1 << _
        --  ") 4 giving:" << toString(res))
      if lowerCase?(ch) then
        --print(message "parseTerm(" << t1 << _
        --  message ") 4 giving:" << toString(res))
        r2 := parseVarTerm(t1, p1)$UT
        res := ski(r2.rft)
        p1 := r2.pout
    if ch = char("(") then
      r := parseBracketTerm(t1, p1)
      res := r.rft
      p1 := r.pout
    [res, p1]

  parseTerm(t1 : String, pin : NNI) : PR ==
    p1 := pin
    r := parseOneTerm(t1, p1)
    res : % := r.rft
    p1 := r.pout
    -- now check for compound term
    if p1 > maxIndex(t1) then
      --print(message "parseTerm(" << t1 << _
      --  message ") 2 giving:" << toString(res))
      return [res, p1]
    ch := qelt(t1, p1)
    stck : List % := []
      ++ in order to get association to the left we will put terms
      ++ in a list
    while alphabetic?(ch) or ch = char(" ") or ch = char("(") repeat
      r := parseOneTerm(t1, p1)
      p1 := r.pout
      stck := concat(stck, r.rft)
      --print(message "parseTerm(" << t1 << _
      --  message ") 4 giving:" << toString(res))
      if p1 > maxIndex(t1)
        then ch := char("*")
        else ch := qelt(t1, p1)
    for i in 1..#stck repeat
      res := ski(res, stck.i)
    [res, p1]


  -- Constructs combinators from a string
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  parseSki(t1 : String) : % ==
    r := parseTerm(t1, minIndex(t1)::NNI)
    --print(message "parseSki(" << t1 << _
    --  message ") giving:" << toString(tm))
    r.rft

  -- returns child nodes if this is a compound term
  -- otherwise returns []
  getChildren(n : %) : List % ==
    if atom?(n) then return []
    [n.nd.c1, n.nd.c2]

  -- returns true if this is an atom, that is a leaf node
  -- otherwise return false if this is a compound term
  atom?(n : %) : Boolean == (n case lf) or (n case vr)

  -- returns true if this is an variable
  variable?(n : %) : Boolean == (n case vr)

  -- returns true if this is an I combinator node
  isI?(n : %) : Boolean ==
    if not (n case lf) then return false
    if n.lf = "I"::Symbol then return true
    false

  -- returns true if this is a K combinator node
  isK?(n : %) : Boolean ==
    if not (n case lf) then return false
    if n.lf = "K"::Symbol then return true
    false

  -- returns true if this is a S combinator node
  isS?(n : %) : Boolean ==
    if not (n case lf) then return false
    if n.lf = "S"::Symbol then return true
    false

  -- introspection: returns the variable, if this is not a
  -- variable node then return " "
  getVariable(n : %) : UT ==
    if n case vr then
      return n.vr
    var(" ")$UT

  -- the variable indicated by 's' is free if it does
  -- not appear in node 'n' or any of its subnodes.
  freeVariable?(n : %, s : UT) : Boolean ==
    if n case vr then
      if n.vr = s then return false
    if n case nd then
      if not freeVariable?(n.nd.c1, s) or _
         not freeVariable?(n.nd.c2, s) then return false
    true

  -- return string representation
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  toString(n : %) : String ==
    s:String := ""
    if n case lf then
      -- leaf node so print I, K or S
      if n.lf = "I"::Symbol then s := "I"
      if n.lf = "K"::Symbol then s := "K"
      if n.lf = "S"::Symbol then s := "S"
    if n case nd then
      -- binary node which has two subnodes c1 and c2
      if atom?(n.nd.c2) then
        if variable?(n.nd.c2)
          then
            s := concat([s,toString(n.nd.c1)," ",toString(n.nd.c2)])
          else
            s := concat([s, toString(n.nd.c1), toString(n.nd.c2)])
      else
        s := concat([s,toString(n.nd.c1),"(",toString(n.nd.c2),")"])
    if n case vr then
      -- variable node so print name
      s := toString(n.vr)$UT
    s

  -- weak reduction - apply this combinator to rearrange its
  -- subnodes then apply recursively to its subnodes
  redux1(n : %) : % ==
    if n case nd then
      -- binary node which has two subnodes c1 and c2
      left := redux1(n.nd.c1)
      right := redux1(n.nd.c2)
      --print(message "left=" << toString(left) << _
      --      message " right=" << toString(right))
      if isI?(left) then return right
      if not (left case nd) then return ski(left, right)
      leftleft := left.nd.c1
      leftright := left.nd.c2
      --print(message "leftleft=" << toString(leftleft) << _
      --                    " leftright=" << toString(leftright))
      if isK?(leftleft) then return leftright
      if not (leftleft case nd) then return ski(left, right)
      leftleftleft := leftleft.nd.c1
      leftleftright := leftleft.nd.c2
      --print(message "leftleftleft=" << toString(leftleftleft) << _
      --                    " leftleftright=" << toString(leftleftright))
      if isS?(leftleftleft) then
        return ski(ski(leftleftright, right), ski(leftright, right))
      return ski(left, right)
    n

  -- weak reduction - apply this combinator to rearrange its
  -- subnodes then apply recursively to its subnodes
  redux(n : %) : % ==
    lastResult := ["I"::Symbol]
    thisResult := redux1(n)
    triesLeft : NNI := 20::NNI -- limit tries in case of loop
    while (lastResult ~= thisResult) and (triesLeft > (1::NNI)) repeat
      lastResult := thisResult
      thisResult := redux1(lastResult)
      triesLeft := (triesLeft - 1)::NNI
      print(lastResult::OutputForm)
    thisResult

  -- return true if equal (deep search) that is: all terms
  -- at all levels in tree must be equal to return true
  -- all terms must be exactly equal, not just equivalent, that is
  -- SKK=I will return false even though 'SKK' and 'I' have the
  -- same effect
  x = y ==
    if (x case lf) and (y case lf) then
      -- leaf node so compare I, K or S
      if x.lf = y.lf then return true
      return false
    if (x case vr) and (y case vr) then
      -- variable node so compare names
      if x.vr = y.vr then return true
      return false
    if (x case nd) and (y case nd) then
      -- binary node which has two subnodes c1 and c2
      if (x.nd.c1 = y.nd.c1) and (x.nd.c2 = y.nd.c2) then return true
      return false
    false

  -- output
  coerce(n : %) : OutputForm ==
      s : OutputForm := empty()$OutputForm
      if n case lf then
          -- leaf node so print I, K or S
          s := (n.lf)::OutputForm
      if n case nd then
          -- binary node which has two subnodes c1 and c2
          if atom?(n.nd.c2) then
              if variable?(n.nd.c2) then
                  s := hconcat([s,_
                                (n.nd.c1)::OutputForm,_
                                message(" "),_
                                (n.nd.c2)::OutputForm])$OutputForm
              else
                  s := hconcat([s, (n.nd.c1)::OutputForm,
                                (n.nd.c2)::OutputForm])$OutputForm
          else
              s := hconcat([s,(n.nd.c1)::OutputForm,message("("),_
             (n.nd.c2)::OutputForm,message(")")])$OutputForm
      if n case vr then
          -- variable node so print name
          s := (n.vr)::OutputForm
      s


)if false

\section{Logic Utility Package}

The compUtil package provides utilities to convert between the
computational domains : Lambda, Ski and ILogic.

Both Lambda are Ski are Turing complete and can be coerced to
each other. Lambda and Ski are not equal and they are only
equivalent up to beta-equivalence and beta-equivalence is
undecidable so there is not a direct correspondence between
the nodes in their trees. Also the names of bound variables
and other such constructions may be lost in
\verb'Lambda -> Ski -> Lambda' round trip.

An element of ILogic cannot be coerced to the other types.
However ILogic can be used to produce a theory which can be
concerted to/from the other domains using Curry-Howard
isomorphism.
\section{Tutorial}
First make sure this package is exposed.

(1) -> )expose COMPUTIL

   compUtil is now explicitly exposed in frame frame1

On this page we will be working with 'untyped' variables
in lambda and SKI terms so we create instances called LU and
SU to simplify notation:
\begin{verbatim}
(1) -> LU := Lambda Untyped

   (1)  Lambda(Untyped)
                                                         Type: Type
(2) -> SU := SKICombinators Untyped

   (2)  SKICombinators(Untyped)
                                                         Type: Type
\end{verbatim}
\section{SKI combinators to lambda functions}

We can then create SKI combinators and convert them to lambda functions.

    For a tutorial about working with SKI combinators see:
\url{http://www.euclideanspace.com/prog/scratchpad/mycode/computation/ski/}

    For a tutorial about working with lambda functions see:
\url{http://www.euclideanspace.com/prog/scratchpad/mycode/computation/lambda/}

If the combinators don't have the required parameters then you
will get a warning as follows. The code will attempt to add parameters
as required but this will not work in complicated situations.

Ideally when working with 'abstract' combinatiors we need to add the
required number of parameters, do the conversion then remove the
parameters just added.
\begin{verbatim}
(3) -> I()$SU::LU
   util coerce rule SL1: Ski[I] = \v0.0

   (3)  (\v0.v0)
                                              Type: Lambda(Untyped)
(4) -> K()$SU::LU
   util coerce rule SL2: Ski[K] = \v0.\v1.1

   (4)  (\v0.(\v1.v1))
                                              Type: Lambda(Untyped)
(5) -> S()$SU::LU
   util coerce rule SL3: Ski[S] = \v0.\v1.\v2.(2 0 (1 0))

   (5)  (\v0.(\v1.(\v2.(v2 (v0 (v1 v0))))))
                                              Type: Lambda(Untyped)
\end{verbatim}

In the following examples the combinators are provided with the required
parameters. This conversion works by applying the following rules:
\begin{verbatim}
    rule SL1 : Ski[I] = \x.0
    rule SL2 : Ski[K] = \x.\y.1
    rule SL3 : Ski[S] = \x.\y.\z.(2 0 (1 0))
    rule SL4 : Ski[(E1 E2)] = (Ski[E1] Ski[E2])
\end{verbatim}

So here are some examples:
\begin{verbatim}
(6) -> parseSki("Ia")$SU::LU
   util coerce apply rule SL1 in:I a
   util coerce pass unbound variable a unchanged

   (6)  a
                                              Type: Lambda(Untyped)
(7) -> parseSki("Ka b")$SU::LU
   util coerce apply rule SL2 in:K a b
   util coerce pass unbound variable a unchanged

   (7)  a
                                              Type: Lambda(Untyped)
(8) -> parseSki("K(a b)c")$SU::LU
   util coerce apply rule SL2 in:K(a b) c
   util coerce rule SL4: Ski[(a b)] = (Ski[a] Ski[b])
   util coerce pass unbound variable a unchanged
   util coerce pass unbound variable b unchanged

   (8)  (a b)
                                              Type: Lambda(Untyped)
(9) -> parseSki("Sa b c")$SU::LU
   util coerce apply rule SL3 in:S a b c
   util coerce pass unbound variable a unchanged
   util coerce pass unbound variable c unchanged
   util coerce pass unbound variable b unchanged
   util coerce pass unbound variable c unchanged

   (9)  ((a c) (b c))
                                              Type: Lambda(Untyped)
(10) -> parseSki("S(K(SI))(S(KK)I)")$SU::LU
   util coerce rule SL4: Ski[(S(K(SI)) S(KK)I)] = (Ski[S(K(SI))] Ski[S(KK)I])
   util coerce rule SL4: Ski[(S K(SI))] = (Ski[S] Ski[K(SI)])
   util coerce rule SL3: Ski[S] = \v0.\v1.\v2.(2 0 (1 0))
   util coerce rule SL4: Ski[(K SI)] = (Ski[K] Ski[SI])
   util coerce rule SL2: Ski[K] = \v3.\v4.1
   util coerce rule SL4: Ski[(S I)] = (Ski[S] Ski[I])
   util coerce rule SL3: Ski[S] = \v5.\v6.\v7.(2 0 (1 0))
   util coerce rule SL1: Ski[I] = \v8.0
   util coerce rule SL4: Ski[(S(KK) I)] = (Ski[S(KK)] Ski[I])
   util coerce rule SL4: Ski[(S KK)] = (Ski[S] Ski[KK])
   util coerce rule SL3: Ski[S] = \v9.\v10.\v11.(2 0 (1 0))
   util coerce rule SL4: Ski[(K K)] = (Ski[K] Ski[K])
   util coerce rule SL2: Ski[K] = \v12.\v13.1
   util coerce rule SL2: Ski[K] = \v14.\v15.1
   util coerce rule SL1: Ski[I] = \v16.0

   (10)
   (
     ((\v0.(\v1.(\v2.(v2 (v0 (v1 v0))))))
       ((\v3.(\v4.v4)) ((\v5.(\v6.(\v7.(v7 (v5 (v6 v5)))))) (\v8.v8))))

     (
       ((\v9.(\v10.(\v11.(v11 (v9 (v10 v9))))))
         ((\v12.(\v13.v13)) (\v14.(\v15.v15))))
        (\v16.v16))
     )
                                              Type: Lambda(Untyped)
\end{verbatim}

\section{lambda functions to SKI combinators}

We can then create lambda functions and convert them to SKI combinators.

    For a tutorial about working with SKI combinators see this page.
    For a tutorial about working with lambda functions see this page.

This process is known as abstraction elimination. It is done by
applying the following rules until all lambda terms have been
eliminated.
\begin{verbatim}
    rule LS1 : Lam[x] => x
    rule LS2 : Lam[(E1 E2)] => (Lam[E1] Lam[E2])
    rule LS3 : Lam[\x.E] => (K Lam[E]) (if x does not occur free in E)
    rule LS4 : Lam[\x.x] => I
    rule LS5 : Lam[\x.\y.E] => Lam[\x.Lam[\y.E]] (if x occurs free in E)
    rule LS6 : Lam[\x.(E1 E2)] => (S Lam[\x.E1] Lam[\x.E2])
\end{verbatim}

Here are some examples:
\begin{verbatim}
(11) -> parseLambda("x")$LU::SU
   util coerce rule LS1 applied to:x giving x

   (11)  x
                                      Type: SKICombinators(Untyped)
(12) -> parseLambda("x y")$LU::SU
   util coerce rule LS2 applied to:(x y) giving (x y)
   util coerce rule LS1 applied to:x giving x
   util coerce rule LS1 applied to:y giving y

   (12)  x y
                                      Type: SKICombinators(Untyped)
(13) -> parseLambda("\x.1")$LU::SU
   util coerce rule LS3 applied to:(\x.1) giving K 1
   util coerce rule LS1 applied to:1 giving 1

   (13)  K 1
                                      Type: SKICombinators(Untyped)
(14) -> parseLambda("\x.0")$LU::SU
   util coerce warning could not match any rule to:(\x.x)

   (14)  I
                                      Type: SKICombinators(Untyped)
(15) -> parseLambda("\x.\y.0 1")$LU::SU
   util coerce rule LS5 applied to:(\x.(\y.(x y))) giving \x.(\y.(y x))
   util coerce rule LS6 applied to:(\y.(y x)) giving S \y.y \y.x
   util coerce rule LS1 applied to:y giving y
   util coerce rule LS4' applied to: \y.y giving I
   util coerce rule LS1 applied to:x giving x
   util coerce rule LS3' applied to: \y.x giving K x
   util coerce rule LS5' applied to: \x.SI(K x) giving S \x.SI \x.K x
   util coerce rule LS3' applied to: \x.SI giving K \x.S \x.I
   util coerce rule LS5' applied to: \x.K x giving S \x.K \x.x
   util coerce rule LS3' applied to: \x.K giving K K
   util coerce rule LS4' applied to: \x.x giving I

   (15)  S(K(SI))(S(KK)I)
                                      Type: SKICombinators(Untyped)
\end{verbatim}
\section{SKI combinators to Intuitionistic Logic}

We can then create SKI combinators and convert them to intuitionistic
logic.

    For a tutorial about working with SKI combinators see:
http://www.euclideanspace.com/prog/scratchpad/mycode/computation/ski/
    For a tutorial about working with intuitionistic logic see:
\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/intuitionistic/}


This is known as the Curry-Howard isomorphism it uses the following rules:
\begin{verbatim}
    rule SI1 : Ski[Kab] => a -> (b -> a)
    rule SI2 : Ski[Sabc] => (a -> (b -> c)) -> ((a -> b) -> (a -> c))
    rule SI3 : Ski[a a->b] => b
\end{verbatim}

The last rule is function application (modus ponens). Here are some
examples:
\begin{verbatim}
(16) -> parseSki("Ia")$SU::ILogic
   util coerce apply rule SI1 in:I a
   warning I does not have a parameter to act on
   creating x

   (16)  ((x->x)->(x->x))
                                                       Type: ILogic
parseSki("Ka b")$SU::ILogic
   util coerce apply rule SI2 in:K a b

   (17)  (b->(a->b))
                                                       Type: ILogic
parseSki("K(a b)c")$SU::ILogic
   util coerce apply rule SI2 in:K(a b) c

   (18)  (c->((a\/b)->c))
                                                       Type: ILogic
parseSki("Sa b c")$SU::ILogic
   util coerce apply rule SI3 in:S a b c

   (19)  ((c->(b->a))->((c->b)->(c->a)))
                                                       Type: ILogic
\end{verbatim}

\section{package COMPUTIL compUtil}
)endif

