)abbrev category TSETCAT TriangularSetCategory
++ Author: Marc Moreno Maza (marc@nag.co.uk)
++ Date Created: 04/26/1994
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: polynomial, multivariate, ordered variables set
++ Description:
++ The category of triangular sets of multivariate polynomials
++ with coefficients in an integral domain.
++ Let \spad{R} be an integral domain and \spad{V} a finite ordered set of
++ variables, say \spad{X1 < X2 < ... < Xn}.
++ A set \spad{S} of polynomials in \spad{R[X1, X2, ..., Xn]} is triangular
++ if no elements of \spad{S} lies in \spad{R}, and if two distinct
++ elements of \spad{S} have distinct main variables.
++ Note that the empty set is a triangular set. A triangular set is not
++ necessarily a (lexicographical) Groebner basis and the notion of
++ reduction related to triangular sets is based on the recursive view
++ of polynomials. We recall this notion here and refer to [1] for more details.
++ A polynomial \spad{P} is reduced w.r.t a non-constant polynomial
++ \spad{Q} if the degree of \spad{P} in the main variable of \spad{Q}
++ is less than the main degree of \spad{Q}.
++ A polynomial \spad{P} is reduced w.r.t a triangular set \spad{T}
++ if it is reduced w.r.t. every polynomial of \spad{T}. \newline
++ References:
++  [1] P. AUBRY, D. LAZARD and M. MORENO MAZA "On the Theories
++      of Triangular Sets" Journal of Symbol. Comp. 28:105-124, 1999.
++ Version: 4.

TriangularSetCategory(R : IntegralDomain, E : OrderedAbelianMonoidSup, _
 V : OrderedSet, P : RecursivePolynomialCategory(R, E, V)):
         Category ==
   Join(PolynomialSetCategory(R, E, V, P), finiteAggregate, shallowlyMutable) with

     infRittWu? : (%, %) -> Boolean
         ++ \spad{infRittWu?(ts1, ts2)} returns true iff \spad{ts2} has higher rank
         ++ than \spad{ts1} in Wu Wen Tsun sense.
     basicSet : (List P,((P,P)->Boolean)) -> Union(Record(bas:%,top:List P),"failed")
         ++ \spad{basicSet(ps, redOp?)} returns \spad{[bs, ts]} where
         ++ \spad{concat(bs, ts)} is \spad{ps} and \spad{bs}
         ++ is a basic set in Wu Wen Tsun sense of \spad{ps} w.r.t
         ++ the reduction-test \spad{redOp?}, if no non-zero constant
         ++ polynomial lie in \spad{ps}, otherwise \spad{"failed"} is returned.
     basicSet : (List P,(P->Boolean),((P,P)->Boolean)) -> Union(Record(bas:%,top:List P),"failed")
         ++ \spad{basicSet(ps, pred?, redOp?)} returns the same as \spad{basicSet(qs, redOp?)}
         ++ where \spad{qs} consists of the polynomials of \spad{ps}
         ++ satisfying property \spad{pred?}.
     initials : % -> List P
         ++ \spad{initials(ts)} returns the list of the non-constant initials
         ++ of the members of \spad{ts}.
     degree : % -> NonNegativeInteger
         ++ \spad{degree(ts)} returns the product of main degrees of the
         ++ members of \spad{ts}.
     quasiComponent : % -> Record(close : List P, open : List P)
         ++ \spad{quasiComponent(ts)} returns \spad{[lp, lq]} where \spad{lp} is the list
         ++ of the members of \spad{ts} and \spad{lq}is \spad{initials(ts)}.
     normalized? : (P, %) -> Boolean
         ++ \spad{normalized?(p, ts)} returns true iff \spad{p} and all its iterated initials
         ++ have degree zero w.r.t. the main variables of the polynomials of \spad{ts}
     normalized? : %  -> Boolean
         ++ \spad{normalized?(ts)} returns true iff for every \spad{p} in \spad{ts} we have
         ++ \spad{normalized?(p, us)} where \spad{us} is \spad{collectUnder(ts, mvar(p))}.
     reduced? : (P, %, ((P, P) -> Boolean)) -> Boolean
         ++ \spad{reduced?(p, ts, redOp?)} returns true iff \spad{p} is reduced w.r.t.
         ++ in the sense of the operation \spad{redOp?}, that is if for every \spad{t} in
         ++ \spad{ts} \spad{redOp?(p, t)} holds.
     stronglyReduced? : (P, %) -> Boolean
         ++ \spad{stronglyReduced?(p, ts)} returns true iff \spad{p}
         ++ is reduced w.r.t. \spad{ts}.
     headReduced? : (P, %) -> Boolean
         ++ \spad{headReduced?(p, ts)} returns true iff the head of \spad{p} is
         ++ reduced w.r.t. \spad{ts}.
     initiallyReduced? : (P, %) -> Boolean
         ++ \spad{initiallyReduced?(p, ts)} returns true iff \spad{p} and all its iterated initials
         ++ are reduced w.r.t. to the elements of \spad{ts} with the same main variable.
     autoReduced? : (%, ((P, List(P)) -> Boolean)) -> Boolean
         ++ \spad{autoReduced?(ts, redOp?)} returns true iff every element of \spad{ts} is
         ++ reduced w.r.t to every other in the sense of \spad{redOp?}
     stronglyReduced? : % -> Boolean
         ++ \spad{stronglyReduced?(ts)} returns true iff every element of \spad{ts} is
         ++ reduced w.r.t to any other element of \spad{ts}.
     headReduced? : % -> Boolean
         ++ headReduced?(ts) returns true iff the head of every element of \spad{ts} is
         ++ reduced w.r.t to any other element of \spad{ts}.
     initiallyReduced? : % -> Boolean
         ++ initiallyReduced?(ts) returns true iff for every element \spad{p} of \spad{ts}
         ++ \spad{p} and all its iterated initials are reduced w.r.t. to the other elements
         ++ of \spad{ts} with the same main variable.
     reduce : (P, %, ((P, P) -> P), ((P, P) -> Boolean) ) -> P
         ++ \spad{reduce(p, ts, redOp, redOp?)} returns a polynomial \spad{r}  such that
         ++ \spad{redOp?(r, p)} holds for every \spad{p} of \spad{ts}
         ++ and there exists some product \spad{h} of the initials of the members
         ++ of \spad{ts} such that \spad{h*p - r} lies in the ideal generated by \spad{ts}.
         ++ The operation \spad{redOp} must satisfy the following conditions.
         ++ For every \spad{p} and \spad{q} we have  \spad{redOp?(redOp(p, q), q)}
         ++ and there exists an integer \spad{e} and a polynomial \spad{f} such that
         ++ \spad{init(q)^e*p = f*q + redOp(p, q)}.
     rewriteSetWithReduction : (List P, %, ((P, P) -> P), ((P, P) -> Boolean) ) -> List P
         ++ \spad{rewriteSetWithReduction(lp, ts, redOp, redOp?)} returns a list \spad{lq} of
         ++ polynomials such that \spad{[reduce(p, ts, redOp, redOp?) for p in lp]} and \spad{lp}
         ++ have the same zeros inside the regular zero set of \spad{ts}. Moreover, for every
         ++ polynomial \spad{q} in \spad{lq} and every polynomial \spad{t} in \spad{ts}
         ++ \spad{redOp?(q, t)} holds and there exists a polynomial \spad{p}
         ++ in the ideal generated by \spad{lp} and a product \spad{h} of \spad{initials(ts)}
         ++ such that \spad{h*p - r} lies in the ideal generated by \spad{ts}.
         ++ The operation \spad{redOp} must satisfy the following conditions.
         ++ For every \spad{p} and \spad{q} we have \spad{redOp?(redOp(p, q), q)}
         ++ and there exists an integer \spad{e} and a polynomial \spad{f}
         ++ such that \spad{init(q)^e*p = f*q + redOp(p, q)}.
     stronglyReduce : (P, %) -> P
         ++ \spad{stronglyReduce(p, ts)} returns a polynomial \spad{r}  such that
         ++ \spad{stronglyReduced?(r, ts)} holds and there exists some product
         ++ \spad{h} of \spad{initials(ts)}
         ++ such that \spad{h*p - r} lies in the ideal generated by \spad{ts}.
     headReduce : (P, %) -> P
         ++ \spad{headReduce(p, ts)} returns a polynomial \spad{r}  such that \spad{headReduce?(r, ts)}
         ++ holds and there exists some product \spad{h} of \spad{initials(ts)}
         ++ such that \spad{h*p - r} lies in the ideal generated by \spad{ts}.
     initiallyReduce : (P, %) -> P
         ++ \spad{initiallyReduce(p, ts)} returns a polynomial \spad{r}
         ++ such that  \spad{initiallyReduced?(r, ts)}
         ++ holds and there exists some product \spad{h} of \spad{initials(ts)}
         ++ such that \spad{h*p - r} lies in the ideal generated by \spad{ts}.
     removeZero : (P, %) -> P
         ++ \spad{removeZero(p, ts)} returns \spad{0} if \spad{p} reduces
         ++ to \spad{0} by pseudo-division w.r.t \spad{ts} otherwise
         ++ returns a polynomial \spad{q} computed from \spad{p}
         ++ by removing any coefficient in \spad{p} reducing to \spad{0}.
     collectQuasiMonic : % -> %
         ++ \spad{collectQuasiMonic(ts)} returns the subset of \spad{ts}
         ++ consisting of the polynomials with initial in \spad{R}.
     reduceByQuasiMonic : (P, %) -> P
         ++ \spad{reduceByQuasiMonic(p, ts)} returns the same as
         ++ \spad{remainder(p, collectQuasiMonic(ts)).polnum}.
     zeroSetSplit : List P -> List %
         ++ \spad{zeroSetSplit(lp)} returns a list \spad{lts} of triangular sets such that
         ++ the zero set of \spad{lp} is the union of the closures of the regular zero sets
         ++ of the members of \spad{lts}.
     zeroSetSplitIntoTriangularSystems : List P -> List Record(close : %, open : List P)
         ++ \spad{zeroSetSplitIntoTriangularSystems(lp)} returns a list of triangular
         ++ systems \spad{[[ts1, qs1], ..., [tsn, qsn]]} such that the zero set of \spad{lp}
         ++ is the union of the closures of the \spad{W_i} where \spad{W_i} consists
         ++ of the zeros of \spad{ts} which do not cancel any polynomial in \spad{qsi}.
     first : % -> Union(P,"failed")
         ++ \spad{first(ts)} returns the polynomial of \spad{ts} with greatest main variable
         ++ if \spad{ts} is not empty, otherwise returns \spad{"failed"}.
     last : % -> Union(P,"failed")
         ++ \spad{last(ts)} returns the polynomial of \spad{ts} with smallest main variable
         ++ if \spad{ts} is not empty, otherwise returns \spad{"failed"}.
     rest : % -> Union(%,"failed")
         ++ \spad{rest(ts)} returns the polynomials of \spad{ts} with smaller main variable
         ++ than \spad{mvar(ts)} if \spad{ts} is not empty, otherwise returns "failed"
     algebraicVariables : % -> List(V)
         ++ \spad{algebraicVariables(ts)} returns the decreasingly sorted list of the main
         ++ variables of the polynomials of \spad{ts}.
     algebraic? : (V, %) -> Boolean
         ++ \spad{algebraic?(v, ts)} returns true iff \spad{v} is the main variable of some
         ++ polynomial in \spad{ts}.
     select : (%,V) -> Union(P,"failed")
         ++ \spad{select(ts, v)} returns the polynomial of \spad{ts} with \spad{v} as
         ++ main variable, if any.
     extendIfCan : (%,P) -> Union(%,"failed")
         ++ \spad{extendIfCan(ts, p)} returns a triangular set which encodes the simple
         ++ extension by \spad{p} of the extension of the base field defined by \spad{ts},
         ++ according to the properties of triangular sets of the current domain.
         ++ If the required properties do not hold then "failed" is returned.
         ++ This operation encodes in some sense the properties of the
         ++ triangular sets of the current category. Is is used to implement
         ++ the \spad{construct} operation to guarantee that every triangular
         ++ set build from a list of polynomials has the required properties.
     extend : (%, P) -> %
         ++ \spad{extend(ts, p)} returns a triangular set which encodes the simple
         ++ extension by \spad{p} of the extension of the base field defined by \spad{ts},
         ++ according to the properties of triangular sets of the current category
         ++ If the required properties do not hold an error is returned.
     if V has Finite
     then
       coHeight : % -> NonNegativeInteger
           ++ \spad{coHeight(ts)} returns \spad{size()\$V} minus \spad{\#ts}.
  add

     B ==> Boolean
     RBT ==> Record(bas : %, top : List P)

     import from Integer
     import from List(V)
     import from List(P)

     ts : % = us : % ==
       empty?(ts)$% => empty?(us)$%
       empty?(us)$% => false
       first(ts)::P =$P first(us)::P => rest(ts)::% =$% rest(us)::%
       false

     infRittWu?(ts, us) ==
       empty?(us)$% => not empty?(ts)$%
       empty?(ts)$% => false
       p : P := (last(ts))::P
       q : P := (last(us))::P
       infRittWu?(p, q)$P => true
       supRittWu?(p, q)$P => false
       v : V := mvar(p)
       infRittWu?(collectUpper(ts, v), collectUpper(us, v))$%

     reduced?(p, ts, redOp?) ==
       lp : List P := members(ts)
       while (not empty? lp) and (redOp?(p, first(lp))) repeat
         lp := rest lp
       empty? lp

     basicSet(ps, redOp?) ==
       ps := remove(zero?, ps)
       any?(ground?,ps) => "failed"::Union(RBT,"failed")
       ps := sort(infRittWu?, ps)
       p, b : P
       bs := empty()$%
       ts : List P := []
       while not empty? ps repeat
         b := first(ps)
         bs := extend(bs, b)$%
         ps := rest ps
         while (not empty? ps) and (not reduced?((p := first(ps)), bs, redOp?)) repeat
           ts := cons(p, ts)
           ps := rest ps
       ([bs,ts]$RBT)::Union(RBT,"failed")

     basicSet(ps, pred?, redOp?) ==
       ps := remove(zero?, ps)
       any?(ground?,ps) => "failed"::Union(RBT,"failed")
       gps : List P := []
       bps : List P := []
       while not empty? ps repeat
         p := first ps
         ps := rest ps
         if pred?(p)
           then
             gps := cons(p, gps)
           else
             bps := cons(p, bps)
       gps := sort(infRittWu?, gps)
       p, b : P
       bs := empty()$%
       ts : List P := []
       while not empty? gps repeat
         b := first(gps)
         bs := extend(bs, b)$%
         gps := rest gps
         while (not empty? gps) and (not reduced?((p := first(gps)), bs, redOp?)) repeat
           ts := cons(p, ts)
           gps := rest gps
       ts := sort(infRittWu?, concat(ts, bps))
       ([bs,ts]$RBT)::Union(RBT,"failed")

     initials ts ==
       lip : List P := []
       empty? ts => lip
       lp := members(ts)
       while not empty? lp repeat
          p := first(lp)
          if not ground?((ip := init(p)))
            then
              lip := cons(primPartElseUnitCanonical(ip), lip)
          lp := rest lp
       removeDuplicates lip

     degree ts ==
       empty? ts => 0$NonNegativeInteger
       lp := members ts
       d : NonNegativeInteger := mdeg(first lp)
       while not empty? (lp := rest lp) repeat
         d := d * mdeg(first lp)
       d

     quasiComponent ts ==
       [members(ts), initials(ts)]

     normalized?(p, ts) ==
       normalized?(p, members(ts))$P

     stronglyReduced? (p, ts) ==
       reduced?(p, members(ts))$P

     headReduced? (p, ts) ==
       stronglyReduced?(head(p), ts)

     initiallyReduced? (p, ts) ==
       lp : List (P) := members(ts)
       red : Boolean := true
       while (not empty? lp) and (not ground?(p)$P) and red repeat
         while (not empty? lp) and (mvar(first(lp)) > mvar(p)) repeat
           lp := rest lp
         if (not empty? lp)
           then
             if  (mvar(first(lp)) = mvar(p))
               then
                 if reduced?(p, first(lp))
                   then
                     lp := rest lp
                     p := init(p)
                   else
                     red := false
               else
                 p := init(p)
       red

     reduce(p : P, ts, redOp, redOp?) ==
       (empty? ts) or (ground? p) => p
       ts0 := ts
       while (not empty? ts) and (not ground? p) repeat
          reductor := (first ts)::P
          ts := (rest ts)::%
          if not redOp?(p, reductor)
            then
              p := redOp(p, reductor)
              ts := ts0
       p

     rewriteSetWithReduction(lp, ts, redOp, redOp?) ==
       trivialIdeal? ts => lp
       lp := remove(zero?, lp)
       empty? lp => lp
       any?(ground?, lp) => [1$P]
       rs : List P := []
       while not empty? lp repeat
         p := first lp
         lp := rest lp
         p := primPartElseUnitCanonical reduce(p, ts, redOp, redOp?)
         if not zero? p
           then
             if ground? p
               then
                 lp := []
                 rs := [1$P]
               else
                 rs := cons(p, rs)
       removeDuplicates rs

     stronglyReduce(p, ts) ==
       reduce (p, ts, lazyPrem, reduced?)

     headReduce(p, ts) ==
       reduce (p, ts, headReduce, headReduced?)

     initiallyReduce(p, ts) ==
       reduce (p, ts, initiallyReduce, initiallyReduced?)

     removeZero(p, ts) ==
       (ground? p) or (empty? ts) => p
       v := mvar(p)
       ts_v_- := collectUnder(ts, v)
       if algebraic?(v, ts)
         then
           q := lazyPrem(p, select(ts, v)::P)
           zero? q => return q
           zero? removeZero(q, ts_v_-) => return 0
       empty? ts_v_- => p
       q : P := 0
       while positive? degree(p, v) repeat
          q := removeZero(init(p), ts_v_-) * mainMonomial(p) + q
          p := tail(p)
       q + removeZero(p, ts_v_-)

     reduceByQuasiMonic(p, ts) ==
       (ground? p) or (empty? ts) => p
       remainder(p, collectQuasiMonic(ts)).polnum

     autoReduced?(ts : %, redOp? : ((P, List(P)) -> Boolean)) ==
       empty? ts => true
       lp : List (P) := members(ts)
       p : P := first(lp)
       lp := rest lp
       while (not empty? lp) and redOp?(p, lp) repeat
          p := first lp
          lp := rest lp
       empty? lp

     stronglyReduced? ts ==
       autoReduced? (ts, reduced?)

     normalized? ts ==
       autoReduced? (ts, normalized?)

     headReduced? ts ==
       autoReduced? (ts, headReduced?)

     initiallyReduced?  ts ==
       autoReduced? (ts, initiallyReduced?)

     mvar ts ==
       empty? ts => error"Error from TSETCAT in mvar : #1 is empty"
       mvar((first(ts))::P)$P

     first ts ==
       empty? ts => "failed"::Union(P,"failed")
       lp : List(P) := sort(supRittWu?, members(ts))$(List P)
       first(lp)::Union(P,"failed")

     last ts ==
       empty? ts => "failed"::Union(P,"failed")
       lp : List(P) := sort(infRittWu?, members(ts))$(List P)
       first(lp)::Union(P,"failed")

     rest ts ==
       empty? ts => "failed"::Union(%,"failed")
       lp : List(P) := sort(supRittWu?, members(ts))$(List P)
       construct(rest(lp))::Union(%,"failed")

     coerce (ts : %) : List(P) ==
       sort(supRittWu?, members(ts))$(List P)

     algebraicVariables ts ==
       [mvar(p) for p in members(ts)]

     algebraic? (v, ts) ==
       member?(v, algebraicVariables(ts))

     select(ts : %, v : V) : Union(P, "failed") ==
       lp : List (P) := sort(supRittWu?, members(ts))$(List P)
       while (not empty? lp) and (not (v = mvar(first lp))) repeat
         lp := rest lp
       empty? lp => "failed"::Union(P,"failed")
       (first lp)::Union(P,"failed")

     collectQuasiMonic ts ==
       lp : List(P) := members(ts)
       newlp : List(P) := []
       while (not empty? lp) repeat
         if ground? init(first(lp)) then newlp := cons(first(lp), newlp)
         lp := rest lp
       construct(newlp)

     collectUnder (ts, v) ==
       lp : List (P) := sort(supRittWu?, members(ts))$(List P)
       while (not empty? lp) and (not (v > mvar(first lp))) repeat
         lp := rest lp
       construct(lp)

     collectUpper  (ts, v) ==
       lp1 : List(P) := sort(supRittWu?, members(ts))$(List P)
       lp2 : List(P) := []
       while (not empty? lp1) and  (mvar(first lp1) > v) repeat
         lp2 := cons(first(lp1), lp2)
         lp1 := rest lp1
       construct(reverse lp2)

     construct(lp : List(P)) ==
       rif := retractIfCan(lp)@Union(%,"failed")
       not (rif case %) => error"in construct : LP -> % from TSETCAT : bad arg"
       rif::%

     retractIfCan(lp : List(P)) ==
       empty? lp => (empty()$%)::Union(%,"failed")
       lp := sort(supRittWu?, lp)
       rif := retractIfCan(rest(lp))@Union(%,"failed")
       not (rif case %) => error"in retractIfCan : LP -> ... from TSETCAT : bad arg"
       extendIfCan(rif::%,first(lp))@Union(%,"failed")

     extend(ts : %, p : P) : % ==
       eif := extendIfCan(ts,p)@Union(%,"failed")
       not (eif case %) =>
           error "in extend : (%, P) -> % from TSETCAT : bad args"
       eif::%

     if V has Finite
     then

       coHeight ts ==
         n := size()$V
         m := #(members ts)
         subtractIfCan(n, m)$NonNegativeInteger::NonNegativeInteger


