20842               (MAKEPROP '|ExpressionSpace| 'NILADIC T)
(|ExpressionSpace|)
|category|
(((|ExpressionSpace|) (|Category|)) (T |ExpressionSpace|))
(|Join| (|Comparable|) (|RetractableTo| (|Kernel| $))
        (|InnerEvalable| (|Kernel| $) $) (|Evalable| $)
        (CATEGORY |domain| (SIGNATURE |elt| ($ (|BasicOperator|) $))
         (SIGNATURE |elt| ($ (|BasicOperator|) $ $))
         (SIGNATURE |elt| ($ (|BasicOperator|) $ $ $))
         (SIGNATURE |elt| ($ (|BasicOperator|) $ $ $ $))
         (SIGNATURE |elt| ($ (|BasicOperator|) $ $ $ $ $))
         (SIGNATURE |elt| ($ (|BasicOperator|) $ $ $ $ $ $))
         (SIGNATURE |elt| ($ (|BasicOperator|) $ $ $ $ $ $ $))
         (SIGNATURE |elt| ($ (|BasicOperator|) $ $ $ $ $ $ $ $))
         (SIGNATURE |elt| ($ (|BasicOperator|) $ $ $ $ $ $ $ $ $))
         (SIGNATURE |elt| ($ (|BasicOperator|) (|List| $)))
         (SIGNATURE |subst| ($ $ (|Equation| $)))
         (SIGNATURE |subst| ($ $ (|List| (|Equation| $))))
         (SIGNATURE |subst| ($ $ (|List| (|Kernel| $)) (|List| $)))
         (SIGNATURE |box| ($ $)) (SIGNATURE |paren| ($ $))
         (SIGNATURE |distribute| ($ $)) (SIGNATURE |distribute| ($ $ $))
         (SIGNATURE |height| ((|NonNegativeInteger|) $))
         (SIGNATURE |mainKernel| ((|Union| (|Kernel| $) "failed") $))
         (SIGNATURE |kernels| ((|List| (|Kernel| $)) $))
         (SIGNATURE |kernels| ((|List| (|Kernel| $)) (|List| $)))
         (SIGNATURE |tower| ((|List| (|Kernel| $)) $))
         (SIGNATURE |tower| ((|List| (|Kernel| $)) (|List| $)))
         (SIGNATURE |operators| ((|List| (|BasicOperator|)) $))
         (SIGNATURE |operator| ((|BasicOperator|) (|BasicOperator|)))
         (SIGNATURE |belong?| ((|Boolean|) (|BasicOperator|)))
         (SIGNATURE |is?| ((|Boolean|) $ (|BasicOperator|)))
         (SIGNATURE |is?| ((|Boolean|) $ (|Symbol|)))
         (SIGNATURE |kernel| ($ (|BasicOperator|) $))
         (SIGNATURE |kernel| ($ (|BasicOperator|) (|List| $)))
         (SIGNATURE |map| ($ (|Mapping| $ $) (|Kernel| $)))
         (SIGNATURE |freeOf?| ((|Boolean|) $ $))
         (SIGNATURE |freeOf?| ((|Boolean|) $ (|Symbol|)))
         (SIGNATURE |eval| ($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ $))))
         (SIGNATURE |eval|
          ($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ (|List| $)))))
         (SIGNATURE |eval| ($ $ (|Symbol|) (|Mapping| $ (|List| $))))
         (SIGNATURE |eval| ($ $ (|Symbol|) (|Mapping| $ $)))
         (SIGNATURE |eval|
          ($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ $))))
         (SIGNATURE |eval|
          ($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ (|List| $)))))
         (SIGNATURE |eval| ($ $ (|BasicOperator|) (|Mapping| $ (|List| $))))
         (SIGNATURE |eval| ($ $ (|BasicOperator|) (|Mapping| $ $)))
         (IF (|has| $ (|Ring|))
             (PROGN
              (SIGNATURE |minPoly|
               ((|SparseUnivariatePolynomial| $) (|Kernel| $)))
              (SIGNATURE |definingPolynomial| ($ $)))
             |noBranch|)
         (IF (|has| $ (|RetractableTo| (|Integer|)))
             (PROGN
              (SIGNATURE |even?| ((|Boolean|) $))
              (SIGNATURE |odd?| ((|Boolean|) $)))
             |noBranch|)))
"/git/fricas/src/algebra/ES.spad"
((|elt| (*1 *1 *2 *1)
  (AND (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|BasicOperator|))))
 (|elt| (*1 *1 *2 *1 *1)
  (AND (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|BasicOperator|))))
 (|elt| (*1 *1 *2 *1 *1 *1)
  (AND (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|BasicOperator|))))
 (|elt| (*1 *1 *2 *1 *1 *1 *1)
  (AND (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|BasicOperator|))))
 (|elt| (*1 *1 *2 *1 *1 *1 *1 *1)
  (AND (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|BasicOperator|))))
 (|elt| (*1 *1 *2 *1 *1 *1 *1 *1 *1)
  (AND (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|BasicOperator|))))
 (|elt| (*1 *1 *2 *1 *1 *1 *1 *1 *1 *1)
  (AND (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|BasicOperator|))))
 (|elt| (*1 *1 *2 *1 *1 *1 *1 *1 *1 *1 *1)
  (AND (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|BasicOperator|))))
 (|elt| (*1 *1 *2 *1 *1 *1 *1 *1 *1 *1 *1 *1)
  (AND (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|BasicOperator|))))
 (|elt| (*1 *1 *2 *3)
  (AND (|isDomain| *2 (|BasicOperator|)) (|isDomain| *3 (|List| *1))
       (|ofCategory| *1 (|ExpressionSpace|))))
 (|subst| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|Equation| *1)) (|ofCategory| *1 (|ExpressionSpace|))))
 (|subst| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|List| (|Equation| *1)))
       (|ofCategory| *1 (|ExpressionSpace|))))
 (|subst| (*1 *1 *1 *2 *3)
  (AND (|isDomain| *2 (|List| (|Kernel| *1))) (|isDomain| *3 (|List| *1))
       (|ofCategory| *1 (|ExpressionSpace|))))
 (|box| (*1 *1 *1) (|ofCategory| *1 (|ExpressionSpace|)))
 (|paren| (*1 *1 *1) (|ofCategory| *1 (|ExpressionSpace|)))
 (|distribute| (*1 *1 *1) (|ofCategory| *1 (|ExpressionSpace|)))
 (|distribute| (*1 *1 *1 *1) (|ofCategory| *1 (|ExpressionSpace|)))
 (|height| (*1 *2 *1)
           (AND (|ofCategory| *1 (|ExpressionSpace|))
                (|isDomain| *2 (|NonNegativeInteger|))))
 (|mainKernel| (*1 *2 *1)
  (|partial| AND (|isDomain| *2 (|Kernel| *1))
   (|ofCategory| *1 (|ExpressionSpace|))))
 (|kernels| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|Kernel| *1)))
       (|ofCategory| *1 (|ExpressionSpace|))))
 (|kernels| (*1 *2 *3)
  (AND (|isDomain| *3 (|List| *1)) (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|List| (|Kernel| *1)))))
 (|tower| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|Kernel| *1)))
       (|ofCategory| *1 (|ExpressionSpace|))))
 (|tower| (*1 *2 *3)
  (AND (|isDomain| *3 (|List| *1)) (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|List| (|Kernel| *1)))))
 (|operators| (*1 *2 *1)
  (AND (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|List| (|BasicOperator|)))))
 (|operator| (*1 *2 *2)
  (AND (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|BasicOperator|))))
 (|belong?| (*1 *2 *3)
  (AND (|ofCategory| *1 (|ExpressionSpace|)) (|isDomain| *3 (|BasicOperator|))
       (|isDomain| *2 (|Boolean|))))
 (|is?| (*1 *2 *1 *3)
  (AND (|ofCategory| *1 (|ExpressionSpace|)) (|isDomain| *3 (|BasicOperator|))
       (|isDomain| *2 (|Boolean|))))
 (|is?| (*1 *2 *1 *3)
  (AND (|ofCategory| *1 (|ExpressionSpace|)) (|isDomain| *3 (|Symbol|))
       (|isDomain| *2 (|Boolean|))))
 (|kernel| (*1 *1 *2 *1)
  (AND (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|BasicOperator|))))
 (|kernel| (*1 *1 *2 *3)
  (AND (|isDomain| *2 (|BasicOperator|)) (|isDomain| *3 (|List| *1))
       (|ofCategory| *1 (|ExpressionSpace|))))
 (|map| (*1 *1 *2 *3)
  (AND (|isDomain| *2 (|Mapping| *1 *1)) (|isDomain| *3 (|Kernel| *1))
       (|ofCategory| *1 (|ExpressionSpace|))))
 (|freeOf?| (*1 *2 *1 *1)
  (AND (|ofCategory| *1 (|ExpressionSpace|)) (|isDomain| *2 (|Boolean|))))
 (|freeOf?| (*1 *2 *1 *3)
  (AND (|ofCategory| *1 (|ExpressionSpace|)) (|isDomain| *3 (|Symbol|))
       (|isDomain| *2 (|Boolean|))))
 (|eval| (*1 *1 *1 *2 *3)
         (AND (|isDomain| *2 (|List| (|Symbol|)))
              (|isDomain| *3 (|List| (|Mapping| *1 *1)))
              (|ofCategory| *1 (|ExpressionSpace|))))
 (|eval| (*1 *1 *1 *2 *3)
         (AND (|isDomain| *2 (|List| (|Symbol|)))
              (|isDomain| *3 (|List| (|Mapping| *1 (|List| *1))))
              (|ofCategory| *1 (|ExpressionSpace|))))
 (|eval| (*1 *1 *1 *2 *3)
         (AND (|isDomain| *2 (|Symbol|))
              (|isDomain| *3 (|Mapping| *1 (|List| *1)))
              (|ofCategory| *1 (|ExpressionSpace|))))
 (|eval| (*1 *1 *1 *2 *3)
         (AND (|isDomain| *2 (|Symbol|)) (|isDomain| *3 (|Mapping| *1 *1))
              (|ofCategory| *1 (|ExpressionSpace|))))
 (|eval| (*1 *1 *1 *2 *3)
         (AND (|isDomain| *2 (|List| (|BasicOperator|)))
              (|isDomain| *3 (|List| (|Mapping| *1 *1)))
              (|ofCategory| *1 (|ExpressionSpace|))))
 (|eval| (*1 *1 *1 *2 *3)
         (AND (|isDomain| *2 (|List| (|BasicOperator|)))
              (|isDomain| *3 (|List| (|Mapping| *1 (|List| *1))))
              (|ofCategory| *1 (|ExpressionSpace|))))
 (|eval| (*1 *1 *1 *2 *3)
         (AND (|isDomain| *2 (|BasicOperator|))
              (|isDomain| *3 (|Mapping| *1 (|List| *1)))
              (|ofCategory| *1 (|ExpressionSpace|))))
 (|eval| (*1 *1 *1 *2 *3)
         (AND (|isDomain| *2 (|BasicOperator|))
              (|isDomain| *3 (|Mapping| *1 *1))
              (|ofCategory| *1 (|ExpressionSpace|))))
 (|minPoly| (*1 *2 *3)
  (AND (|isDomain| *3 (|Kernel| *1)) (|ofCategory| *1 (|Ring|))
       (|ofCategory| *1 (|ExpressionSpace|))
       (|isDomain| *2 (|SparseUnivariatePolynomial| *1))))
 (|definingPolynomial| (*1 *1 *1)
  (AND (|ofCategory| *1 (|Ring|)) (|ofCategory| *1 (|ExpressionSpace|))))
 (|even?| (*1 *2 *1)
  (AND (|ofCategory| *1 (|RetractableTo| (|Integer|)))
       (|ofCategory| *1 (|ExpressionSpace|)) (|isDomain| *2 (|Boolean|))))
 (|odd?| (*1 *2 *1)
  (AND (|ofCategory| *1 (|RetractableTo| (|Integer|)))
       (|ofCategory| *1 (|ExpressionSpace|)) (|isDomain| *2 (|Boolean|)))))
((~= (((|Boolean|) $ $) 6))
 (|tower| (((|List| (|Kernel| $)) $) 6) (((|List| (|Kernel| $)) (|List| $)) 6))
 (|subst| (($ $ (|Equation| $)) 6) (($ $ (|List| (|Equation| $))) 6)
  (($ $ (|List| (|Kernel| $)) (|List| $)) 6))
 (|smaller?| (((|Boolean|) $ $) 6))
 (|retractIfCan| (((|Union| (|Kernel| $) "failed") $) 6))
 (|retract| (((|Kernel| $) $) 6)) (|paren| (($ $) 6))
 (|operators| (((|List| (|BasicOperator|)) $) 6))
 (|operator| (((|BasicOperator|) (|BasicOperator|)) 6))
 (|odd?| (((|Boolean|) $) 6 (|has| $ (|RetractableTo| (|Integer|)))))
 (|minPoly|
  (((|SparseUnivariatePolynomial| $) (|Kernel| $)) 6 (|has| $ (|Ring|))))
 (|map| (($ (|Mapping| $ $) (|Kernel| $)) 6))
 (|mainKernel| (((|Union| (|Kernel| $) "failed") $) 6))
 (|latex| (((|String|) $) 6))
 (|kernels| (((|List| (|Kernel| $)) $) 6)
  (((|List| (|Kernel| $)) (|List| $)) 6))
 (|kernel| (($ (|BasicOperator|) $) 6) (($ (|BasicOperator|) (|List| $)) 6))
 (|is?| (((|Boolean|) $ (|BasicOperator|)) 6) (((|Boolean|) $ (|Symbol|)) 6))
 (|height| (((|NonNegativeInteger|) $) 6))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) 6))
 (|hash| (((|SingleInteger|) $) 6))
 (|freeOf?| (((|Boolean|) $ $) 6) (((|Boolean|) $ (|Symbol|)) 6))
 (|even?| (((|Boolean|) $) 6 (|has| $ (|RetractableTo| (|Integer|)))))
 (|eval| (($ $ (|Kernel| $) $) 6) (($ $ (|List| (|Kernel| $)) (|List| $)) 6)
         (($ $ (|List| (|Equation| $))) 6) (($ $ (|Equation| $)) 6)
         (($ $ $ $) 6) (($ $ (|List| $) (|List| $)) 6)
         (($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ $))) 6)
         (($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ (|List| $)))) 6)
         (($ $ (|Symbol|) (|Mapping| $ (|List| $))) 6)
         (($ $ (|Symbol|) (|Mapping| $ $)) 6)
         (($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ $))) 6)
         (($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ (|List| $)))) 6)
         (($ $ (|BasicOperator|) (|Mapping| $ (|List| $))) 6)
         (($ $ (|BasicOperator|) (|Mapping| $ $)) 6))
 (|elt| (($ (|BasicOperator|) $) 6) (($ (|BasicOperator|) $ $) 6)
  (($ (|BasicOperator|) $ $ $) 6) (($ (|BasicOperator|) $ $ $ $) 6)
  (($ (|BasicOperator|) $ $ $ $ $) 6) (($ (|BasicOperator|) $ $ $ $ $ $) 6)
  (($ (|BasicOperator|) $ $ $ $ $ $ $) 6)
  (($ (|BasicOperator|) $ $ $ $ $ $ $ $) 6)
  (($ (|BasicOperator|) $ $ $ $ $ $ $ $ $) 6)
  (($ (|BasicOperator|) (|List| $)) 6))
 (|distribute| (($ $) 6) (($ $ $) 6))
 (|definingPolynomial| (($ $) 6 (|has| $ (|Ring|))))
 (|coerce| (((|OutputForm|) $) 6) (($ (|Kernel| $)) 6)) (|box| (($ $) 6))
 (|belong?| (((|Boolean|) (|BasicOperator|)) 6)) (= (((|Boolean|) $ $) 6)))
ES
(((|Comparable|) . T) ((|RetractableTo| (|Kernel| $)) . T)
 ((|InnerEvalable| (|Kernel| $) $) . T) ((|Evalable| $) . T))
(((|BasicType|) . T) ((|CoercibleTo| (|OutputForm|)) . T) ((|Comparable|) . T)
 ((|Evalable| $) . T) ((|InnerEvalable| |t#1| |t#1|) . T)
 ((|InnerEvalable| (|Kernel| $) $) . T) ((|RetractableTo| (|Kernel| $)) . T)
 ((|SetCategory|) . T))
((|constructor|
  (NIL
   "An expression space is a set which is closed under certain operators."))
 (|odd?|
  (((|Boolean|) $)
   "\\spad{odd? x} is \\spad{true} if \\spad{x} is an odd integer."))
 (|even?|
  (((|Boolean|) $)
   "\\spad{even? x} is \\spad{true} if \\spad{x} is an even integer."))
 (|definingPolynomial|
  (($ $)
   "\\spad{definingPolynomial(x)} returns an expression \\spad{p} such that \\spad{p(x) = 0}."))
 (|minPoly|
  (((|SparseUnivariatePolynomial| $) (|Kernel| $))
   "\\spad{minPoly(k)} returns \\spad{p} such that \\spad{p(k) = 0}."))
 (|eval|
  (($ $ (|BasicOperator|) (|Mapping| $ $))
   "\\spad{eval(x,{} s,{} f)} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.")
  (($ $ (|BasicOperator|) (|Mapping| $ (|List| $)))
   "\\spad{eval(x,{} s,{} f)} replaces every \\spad{s(a1,{} ..,{} am)} in \\spad{x} by \\spad{f(a1,{} ..,{} am)} for any \\spad{a1},{} ...,{} \\spad{am}.")
  (($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ (|List| $))))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a1,{} ...,{} an)} in \\spad{x} by \\spad{\\spad{fi}(a1,{} ...,{} an)} for any \\spad{a1},{} ...,{} \\spad{an}.")
  (($ $ (|List| (|BasicOperator|)) (|List| (|Mapping| $ $)))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a)} in \\spad{x} by \\spad{\\spad{fi}(a)} for any \\spad{a}.")
  (($ $ (|Symbol|) (|Mapping| $ $))
   "\\spad{eval(x,{} s,{} f)} replaces every \\spad{s(a)} in \\spad{x} by \\spad{f(a)} for any \\spad{a}.")
  (($ $ (|Symbol|) (|Mapping| $ (|List| $)))
   "\\spad{eval(x,{} s,{} f)} replaces every \\spad{s(a1,{} ..,{} am)} in \\spad{x} by \\spad{f(a1,{} ..,{} am)} for any \\spad{a1},{} ...,{} \\spad{am}.")
  (($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ (|List| $))))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a1,{} ...,{} an)} in \\spad{x} by \\spad{\\spad{fi}(a1,{} ...,{} an)} for any \\spad{a1},{} ...,{} \\spad{an}.")
  (($ $ (|List| (|Symbol|)) (|List| (|Mapping| $ $)))
   "\\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \\spad{\\spad{si}(a)} in \\spad{x} by \\spad{\\spad{fi}(a)} for any \\spad{a}."))
 (|freeOf?|
  (((|Boolean|) $ (|Symbol|))
   "\\spad{freeOf?(x,{} s)} tests if \\spad{x} does not contain any operator whose name is \\spad{s}.")
  (((|Boolean|) $ $)
   "\\spad{freeOf?(x,{} y)} tests if \\spad{x} does not contain any occurrence of \\spad{y},{} where \\spad{y} is a single kernel."))
 (|map|
  (($ (|Mapping| $ $) (|Kernel| $))
   "\\spad{map(f,{} k)} returns \\spad{op(f(x1),{} ...,{} f(xn))} where \\spad{k = op(x1,{} ...,{} xn)}."))
 (|kernel|
  (($ (|BasicOperator|) (|List| $))
   "\\spad{kernel(op,{} [f1,{} ...,{} fn])} constructs \\spad{op(f1,{} ...,{} fn)} without evaluating it.")
  (($ (|BasicOperator|) $)
   "\\spad{kernel(op,{} x)} constructs \\spad{op}(\\spad{x}) without evaluating it."))
 (|is?|
  (((|Boolean|) $ (|Symbol|))
   "\\spad{is?(x,{} s)} tests if \\spad{x} is a kernel and if the name of its operator is \\spad{s}.")
  (((|Boolean|) $ (|BasicOperator|))
   "\\spad{is?(x,{} op)} tests if \\spad{x} is a kernel and if its operator is op."))
 (|belong?|
  (((|Boolean|) (|BasicOperator|))
   "\\spad{belong?(op)} tests if \\% accepts \\spad{op} as applicable to its elements."))
 (|operator|
  (((|BasicOperator|) (|BasicOperator|))
   "\\spad{operator(op)} returns a copy of \\spad{op} with the domain-dependent properties appropriate for \\%."))
 (|operators|
  (((|List| (|BasicOperator|)) $)
   "\\spad{operators(f)} returns all the basic operators appearing in \\spad{f},{} no matter what their levels are."))
 (|tower|
  (((|List| (|Kernel| $)) (|List| $))
   "\\spad{tower([f1,{}...,{}fn])} returns all the kernels appearing in \\spad{f1},{} ...,{} \\spad{fn} no matter what their levels are.")
  (((|List| (|Kernel| $)) $)
   "\\spad{tower(f)} returns all the kernels appearing in \\spad{f},{} no matter what their levels are."))
 (|kernels|
  (((|List| (|Kernel| $)) (|List| $))
   "\\spad{kernels([f1,{}...,{}fn])} returns the list of all the top-level kernels appearing in \\spad{f1},{} ...,{} \\spad{fn} but not the ones appearing in the arguments of the top-level kernels.")
  (((|List| (|Kernel| $)) $)
   "\\spad{kernels(f)} returns the list of all the top-level kernels appearing in \\spad{f},{} but not the ones appearing in the arguments of the top-level kernels."))
 (|mainKernel|
  (((|Union| (|Kernel| $) "failed") $)
   "\\spad{mainKernel(f)} returns a kernel of \\spad{f} with maximum nesting level,{} or \"failed\" if \\spad{f} has no kernels (\\spadignore{i.e.} \\spad{f} is a constant)."))
 (|height|
  (((|NonNegativeInteger|) $)
   "\\spad{height(f)} returns the highest nesting level appearing in \\spad{f}. Constants have height 0. Symbols have height 1. For any operator op and expressions \\spad{f1},{} ...,{} \\spad{fn},{} \\spad{op(f1,{} ...,{} fn)} has height equal to \\spad{1 + max(height(f1),{} ...,{} height(fn))}."))
 (|distribute|
  (($ $ $)
   "\\spad{distribute(f,{} g)} expands all the kernels in \\spad{f} that contain \\spad{g} in their arguments and that are formally enclosed by a \\spadfunFrom{box}{ExpressionSpace} or a \\spadfunFrom{paren}{ExpressionSpace} expression.")
  (($ $)
   "\\spad{distribute(f)} expands all the kernels in \\spad{f} that are formally enclosed by a \\spadfunFrom{box}{ExpressionSpace} or \\spadfunFrom{paren}{ExpressionSpace} expression."))
 (|paren|
  (($ $)
   "\\spad{paren(f)} returns (\\spad{f}). This prevents \\spad{f} from being evaluated when operators are applied to it. For example,{} \\spad{log(1)} returns 0,{} but \\spad{log(paren 1)} returns the formal kernel log((1))."))
 (|box|
  (($ $)
   "\\spad{box(f)} returns \\spad{f} with a 'box' around it that prevents \\spad{f} from being evaluated when operators are applied to it. For example,{} \\spad{log(1)} returns 0,{} but \\spad{log(box 1)} returns the formal kernel log(1)."))
 (|subst|
  (($ $ (|List| (|Kernel| $)) (|List| $))
   "\\spad{subst(f,{} [k1...,{} kn],{} [g1,{} ...,{} gn])} replaces the kernels \\spad{k1},{} ...,{} \\spad{kn} by \\spad{g1},{} ...,{} \\spad{gn} formally in \\spad{f}.")
  (($ $ (|List| (|Equation| $)))
   "\\spad{subst(f,{} [k1 = g1,{} ...,{} kn = gn])} replaces the kernels \\spad{k1},{} ...,{} \\spad{kn} by \\spad{g1},{} ...,{} \\spad{gn} formally in \\spad{f}.")
  (($ $ (|Equation| $))
   "\\spad{subst(f,{} k = g)} replaces the kernel \\spad{k} by \\spad{g} formally in \\spad{f}."))
 (|elt|
  (($ (|BasicOperator|) (|List| $))
   "\\spad{elt(op,{} [x1,{} ...,{} xn])} or \\spad{op}([\\spad{x1},{} ...,{} \\spad{xn}]) applies the \\spad{n}-ary operator \\spad{op} to \\spad{x1},{} ...,{} \\spad{xn}.")
  (($ (|BasicOperator|) $ $ $ $ $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r,{} q,{} p,{} o)} applies the 9-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t},{} \\spad{s},{} \\spad{r},{} \\spad{q},{} \\spad{p} and \\spad{o}")
  (($ (|BasicOperator|) $ $ $ $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r,{} q,{} p)} applies the 8-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t},{} \\spad{s},{} \\spad{r},{} \\spad{q} and \\spad{p}")
  (($ (|BasicOperator|) $ $ $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r,{} q)} applies the 7-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t},{} \\spad{s},{} \\spad{r} and \\spad{q}")
  (($ (|BasicOperator|) $ $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r)} applies the 6-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t},{} \\spad{s} and \\spad{r}")
  (($ (|BasicOperator|) $ $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t,{} s)} applies the 5-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t} and \\spad{s}")
  (($ (|BasicOperator|) $ $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z,{} t)} or \\spad{op}(\\spad{x},{} \\spad{y},{} \\spad{z},{} \\spad{t}) applies the 4-ary operator \\spad{op} to \\spad{x},{} \\spad{y},{} \\spad{z} and \\spad{t}.")
  (($ (|BasicOperator|) $ $ $)
   "\\spad{elt(op,{} x,{} y,{} z)} or \\spad{op}(\\spad{x},{} \\spad{y},{} \\spad{z}) applies the ternary operator \\spad{op} to \\spad{x},{} \\spad{y} and \\spad{z}.")
  (($ (|BasicOperator|) $ $)
   "\\spad{elt(op,{} x,{} y)} or \\spad{op}(\\spad{x},{} \\spad{y}) applies the binary operator \\spad{op} to \\spad{x} and \\spad{y}.")
  (($ (|BasicOperator|) $)
   "\\spad{elt(op,{} x)} or \\spad{op}(\\spad{x}) applies the unary operator \\spad{op} to \\spad{x}.")))
(("documentation" 0 12194) ("ancestors" 0 11956) ("parents" 0 11835)
 ("abbreviation" 0 11832) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 9231) ("modemaps" 0 3262) ("sourceFile" 0 3228)
 ("constructorCategory" 0 151) ("constructorModemap" 0 92)
 ("constructorKind" 0 81) ("constructorForm" 0 61) ("NILADIC" 0 20))