)abbrev package INTFACT IntegerFactorizationPackage
++ This Package contains basic methods for integer factorization.
++ The factor operation employs trial division up to 10, 000.  It
++ then tests to see if n is a perfect power before using Pollards
++ rho method.  Because Pollards method may fail, the result
++ of factor may contain composite factors.  We should also employ
++ Lenstra's eliptic curve method.

IntegerFactorizationPackage(I) : Exports == Implementation where
  I : IntegerNumberSystem

  B      ==> Boolean
  FF     ==> Factored I
  NNI    ==> NonNegativeInteger
  LMI    ==> ListMultiDictionary I
  FFE    ==> Record(flag : Union("nil", "sqfr", "irred", "prime"),
                    factor : I, exponent : NonNegativeInteger)

  Exports ==>  with
    factor : I -> FF
      ++ factor(n) returns the full factorization of integer n
    squareFree   : I -> FF
      ++ squareFree(n) returns the square free factorization of integer n
    BasicMethod : I -> FF
      ++ BasicMethod(n) returns the factorization
      ++ of integer n by trial division
    PollardSmallFactor : I -> Union(I,"failed")
       ++ PollardSmallFactor(n) returns a factor
       ++ of n or "failed" if no one is found

  Implementation ==> add
    import from IntegerRoots(I)

    BasicSieve : (I, I) -> FF

    squareFree(n : I) : FF ==
       u : I
       if n<0 then (m := -n; u := -1)
              else (m := n; u := 1)
       (m > 1) and ((v := perfectSqrt m) case I) =>
          for rec in (l := factorList(sv := squareFree(v::I))) repeat
            rec.exponent := 2 * rec.exponent
          makeFR(u * unit sv, l)
    -- avoid using basic sieve when the lim is too big
       lim := 1 + approxNthRoot(m, 3)
       lim > (100000::I) => makeFR(u, factorList factor m)
       x := BasicSieve(m, lim)
       y :=
         ((m := unit x) = 1) => factorList x
         (v := perfectSqrt m) case I =>
            concat(["sqfr", v, 2]$FFE, factorList x)
         concat(["sqfr", m, 1]$FFE, factorList x)
       makeFR(u, y)

    -- Pfun(y: I, n: I): I == (y^2 + 5) rem n
    PollardSmallFactor(n:I):Union(I,"failed") ==
       -- Use the Brent variation
       x0 := random(n)$I
       m := 100::I
       y := x0
       r : I := 1
       q : I := 1
       G : I := 1
       l : I
       k : I
       until G > 1 repeat
          x := y
          ys := y
          for i in 1..convert(r)@Integer repeat
             y := (y*y+5::I) rem n
             q := (q*abs(x-y)) rem n
          k := 0::I
          G := gcd(q, n)
          until (k>=r) or (G>1) repeat
             ys := y
             for i in 1..convert(min(m, r-k))@Integer repeat
                y := (y*y+5::I) rem n
                q := (q*abs(x-y)) rem n
             G := gcd(q, n)
             k := k+m
          k := k + r
          r := 2*r
       if G = n then
          l := k - m
          G := 1::I
          until G>1 repeat
             ys := (ys*ys+5::I) rem n
             G := gcd(abs(x-ys), n)
             l := l + 1
          if G = n then
             y := x0
             x := x0
             for i in 1..convert(l)@Integer repeat
               y := (y*y+5::I) rem n
             G := gcd(abs(x-y), n)
             until G>1 repeat
               y := (y*y+5::I) rem n
               x := (x*x+5::I) rem n
               G := gcd(abs(x-y), n)
       G = n => "failed"
       G

    PollardSmallFactor20(n:I):Union(I,"failed") ==
       for i in 1..20 repeat
          r := PollardSmallFactor n
          r case I => return r
       r

    BasicSieve(r, lim) ==
       l : List(I) :=
          [1::I, 2::I, 2::I, 4::I, 2::I, 4::I, 2::I, 4::I, 6::I, 2::I, 6::I]
       concat!(l, rest(l, 3))
       d := 2::I
       n := r
       ls := empty()$List(FFE)
       for s in l repeat
          d > lim => return makeFR(n, ls)
          if n<d*d then
             if n>1 then ls := concat(["prime", n, 1]$FFE, ls)
             return makeFR(1, ls)
          for m in 0.. while zero?(n rem d) repeat n := n quo d
          if m>0 then ls := concat(["prime", d, m]$FFE, ls)
          d := d+s

    BasicMethod n ==
       u : I
       if n<0 then (m := -n; u := -1)
              else (m := n; u := 1)
       x := BasicSieve(m, 1 + approxSqrt m)
       makeFR(u, factorList x)

    factor m ==
       u : I
       zero? m => 0
       if negative? m then (n := -m; u := -1)
                      else (n := m; u := 1)
       b := BasicSieve(n, 10000::I)
       flb := factorList b
       ((n := unit b) = 1) => makeFR(u, flb)
       a : LMI := dictionary() -- numbers yet to be factored
       b : LMI := dictionary() -- prime factors found
       f : LMI := dictionary() -- number which could not be factored
       insert!(n, a)
       while not empty? a repeat
          n := inspect a; c := count(n, a); remove!(n, a)
          prime?(n)$IntegerPrimesPackage(I) => insert!(n, b, c)
          -- test for a perfect power
          (s := perfectNthRoot n).exponent > 1 =>
            insert!(s.base, a, c * s.exponent)
          -- test for a difference of square
          x := approxSqrt n
          if (x^2<n) then x := x+1
          (y := perfectSqrt (x^2-n)) case I =>
                insert!(x+y, a, c)
                insert!(x-y, a, c)
          (d := PollardSmallFactor20 n) case I =>
             for m in 0.. while zero?(n rem d) repeat n := n quo d
             insert!(d, a, m * c)
             if n > 1 then insert!(n, a, c)
          -- an elliptic curve factorization attempt should be made here
          insert!(n, f, c)
       -- insert prime factors found
       while not empty? b repeat
          n := inspect b; c := count(n, b); remove!(n, b)
          flb := concat(["prime", n, c]$FFE, flb)
       -- insert non-prime factors found
       while not empty? f repeat
          n := inspect f; c := count(n, f); remove!(n, f)
          flb := concat(["nil", n, c]$FFE, flb)
       makeFR(u, flb)

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
