10911               (|SplittingNode| V C)
|domain|
(((|SplittingNode| |#1| |#2|)
  (|Join| (|SetCategory|)
          (CATEGORY |domain| (SIGNATURE |empty| ($))
           (SIGNATURE |empty?| ((|Boolean|) $)) (SIGNATURE |value| (|#1| $))
           (SIGNATURE |condition| (|#2| $))
           (SIGNATURE |status| ((|Boolean|) $))
           (SIGNATURE |construct| ($ |#1| |#2| (|Boolean|)))
           (SIGNATURE |construct| ($ |#1| |#2|))
           (SIGNATURE |construct|
            ($ (|Record| (|:| |val| |#1|) (|:| |tower| |#2|))))
           (SIGNATURE |construct|
            ((|List| $)
             (|List| (|Record| (|:| |val| |#1|) (|:| |tower| |#2|)))))
           (SIGNATURE |construct| ((|List| $) |#1| (|List| |#2|)))
           (SIGNATURE |copy| ($ $)) (SIGNATURE |setValue!| ($ $ |#1|))
           (SIGNATURE |setCondition!| ($ $ |#2|))
           (SIGNATURE |setStatus!| ($ $ (|Boolean|)))
           (SIGNATURE |setEmpty!| ($ $))
           (SIGNATURE |infLex?|
            ((|Boolean|) $ $ (|Mapping| (|Boolean|) |#1| |#1|)
             (|Mapping| (|Boolean|) |#2| |#2|)))
           (SIGNATURE |subNode?|
            ((|Boolean|) $ $ (|Mapping| (|Boolean|) |#2| |#2|)))))
  (|Join| (|SetCategory|) (|Aggregate|))
  (|Join| (|SetCategory|) (|Aggregate|)))
 (T |SplittingNode|))
(|Join| (|SetCategory|)
        (CATEGORY |domain| (SIGNATURE |empty| ($))
         (SIGNATURE |empty?| ((|Boolean|) $)) (SIGNATURE |value| (|#1| $))
         (SIGNATURE |condition| (|#2| $)) (SIGNATURE |status| ((|Boolean|) $))
         (SIGNATURE |construct| ($ |#1| |#2| (|Boolean|)))
         (SIGNATURE |construct| ($ |#1| |#2|))
         (SIGNATURE |construct|
          ($ (|Record| (|:| |val| |#1|) (|:| |tower| |#2|))))
         (SIGNATURE |construct|
          ((|List| $) (|List| (|Record| (|:| |val| |#1|) (|:| |tower| |#2|)))))
         (SIGNATURE |construct| ((|List| $) |#1| (|List| |#2|)))
         (SIGNATURE |copy| ($ $)) (SIGNATURE |setValue!| ($ $ |#1|))
         (SIGNATURE |setCondition!| ($ $ |#2|))
         (SIGNATURE |setStatus!| ($ $ (|Boolean|)))
         (SIGNATURE |setEmpty!| ($ $))
         (SIGNATURE |infLex?|
          ((|Boolean|) $ $ (|Mapping| (|Boolean|) |#1| |#1|)
           (|Mapping| (|Boolean|) |#2| |#2|)))
         (SIGNATURE |subNode?|
          ((|Boolean|) $ $ (|Mapping| (|Boolean|) |#2| |#2|)))))
"/git/fricas/src/algebra/SPLNODE.spad"
((|empty| (*1 *1)
  (AND (|isDomain| *1 (|SplittingNode| *2 *3))
       (|ofCategory| *2 (|Join| (|SetCategory|) (|Aggregate|)))
       (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))))
 (|empty?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SplittingNode| *3 *4))
       (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))
       (|ofCategory| *4 (|Join| (|SetCategory|) (|Aggregate|)))))
 (|value| (*1 *2 *1)
  (AND (|ofCategory| *2 (|Join| (|SetCategory|) (|Aggregate|)))
       (|isDomain| *1 (|SplittingNode| *2 *3))
       (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))))
 (|condition| (*1 *2 *1)
  (AND (|ofCategory| *2 (|Join| (|SetCategory|) (|Aggregate|)))
       (|isDomain| *1 (|SplittingNode| *3 *2))
       (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))))
 (|status| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SplittingNode| *3 *4))
       (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))
       (|ofCategory| *4 (|Join| (|SetCategory|) (|Aggregate|)))))
 (|construct| (*1 *1 *2 *3 *4)
              (AND (|isDomain| *4 (|Boolean|))
                   (|isDomain| *1 (|SplittingNode| *2 *3))
                   (|ofCategory| *2 (|Join| (|SetCategory|) (|Aggregate|)))
                   (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))))
 (|construct| (*1 *1 *2 *3)
              (AND (|isDomain| *1 (|SplittingNode| *2 *3))
                   (|ofCategory| *2 (|Join| (|SetCategory|) (|Aggregate|)))
                   (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))))
 (|construct| (*1 *1 *2)
              (AND (|isDomain| *2 (|Record| (|:| |val| *3) (|:| |tower| *4)))
                   (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))
                   (|ofCategory| *4 (|Join| (|SetCategory|) (|Aggregate|)))
                   (|isDomain| *1 (|SplittingNode| *3 *4))))
 (|construct| (*1 *2 *3)
              (AND
               (|isDomain| *3
                           (|List| (|Record| (|:| |val| *4) (|:| |tower| *5))))
               (|ofCategory| *4 (|Join| (|SetCategory|) (|Aggregate|)))
               (|ofCategory| *5 (|Join| (|SetCategory|) (|Aggregate|)))
               (|isDomain| *2 (|List| (|SplittingNode| *4 *5)))
               (|isDomain| *1 (|SplittingNode| *4 *5))))
 (|construct| (*1 *2 *3 *4)
              (AND (|isDomain| *4 (|List| *5))
                   (|ofCategory| *5 (|Join| (|SetCategory|) (|Aggregate|)))
                   (|isDomain| *2 (|List| (|SplittingNode| *3 *5)))
                   (|isDomain| *1 (|SplittingNode| *3 *5))
                   (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))))
 (|copy| (*1 *1 *1)
  (AND (|isDomain| *1 (|SplittingNode| *2 *3))
       (|ofCategory| *2 (|Join| (|SetCategory|) (|Aggregate|)))
       (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))))
 (|setValue!| (*1 *1 *1 *2)
  (AND (|isDomain| *1 (|SplittingNode| *2 *3))
       (|ofCategory| *2 (|Join| (|SetCategory|) (|Aggregate|)))
       (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))))
 (|setCondition!| (*1 *1 *1 *2)
  (AND (|isDomain| *1 (|SplittingNode| *3 *2))
       (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))
       (|ofCategory| *2 (|Join| (|SetCategory|) (|Aggregate|)))))
 (|setStatus!| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SplittingNode| *3 *4))
       (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))
       (|ofCategory| *4 (|Join| (|SetCategory|) (|Aggregate|)))))
 (|setEmpty!| (*1 *1 *1)
  (AND (|isDomain| *1 (|SplittingNode| *2 *3))
       (|ofCategory| *2 (|Join| (|SetCategory|) (|Aggregate|)))
       (|ofCategory| *3 (|Join| (|SetCategory|) (|Aggregate|)))))
 (|infLex?| (*1 *2 *1 *1 *3 *4)
  (AND (|isDomain| *3 (|Mapping| (|Boolean|) *5 *5))
       (|isDomain| *4 (|Mapping| (|Boolean|) *6 *6))
       (|ofCategory| *5 (|Join| (|SetCategory|) (|Aggregate|)))
       (|ofCategory| *6 (|Join| (|SetCategory|) (|Aggregate|)))
       (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SplittingNode| *5 *6))))
 (|subNode?| (*1 *2 *1 *1 *3)
  (AND (|isDomain| *3 (|Mapping| (|Boolean|) *5 *5))
       (|ofCategory| *5 (|Join| (|SetCategory|) (|Aggregate|)))
       (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SplittingNode| *4 *5))
       (|ofCategory| *4 (|Join| (|SetCategory|) (|Aggregate|))))))
((~= (((|Boolean|) $ $) 41)) (|value| ((|#1| $) 15))
 (|subNode?| (((|Boolean|) $ $ (|Mapping| (|Boolean|) |#2| |#2|)) 36))
 (|status| (((|Boolean|) $) 17)) (|setValue!| (($ $ |#1|) 28))
 (|setStatus!| (($ $ (|Boolean|)) 30)) (|setEmpty!| (($ $) 31))
 (|setCondition!| (($ $ |#2|) 29)) (|latex| (((|String|) $) NIL))
 (|infLex?|
  (((|Boolean|) $ $ (|Mapping| (|Boolean|) |#1| |#1|)
    (|Mapping| (|Boolean|) |#2| |#2|))
   35))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) NIL))
 (|hash| (((|SingleInteger|) $) NIL)) (|empty?| (((|Boolean|) $) 14))
 (|empty| (($) 10)) (|copy| (($ $) 27))
 (|construct| (($ |#1| |#2| (|Boolean|)) 18) (($ |#1| |#2|) 19)
              (($ (|Record| (|:| |val| |#1|) (|:| |tower| |#2|))) 21)
              (((|List| $)
                (|List| (|Record| (|:| |val| |#1|) (|:| |tower| |#2|))))
               24)
              (((|List| $) |#1| (|List| |#2|)) 26))
 (|condition| ((|#2| $) 16)) (|coerce| (((|OutputForm|) $) 49))
 (= (((|Boolean|) $ $) 39)))
SPLNODE
(((|SetCategory|) . T))
(((|BasicType|) . T) ((|CoercibleTo| (|OutputForm|)) . T) ((|SetCategory|) . T))
((|constructor|
  (NIL
   "This domain exports a modest implementation for the vertices of splitting trees. These vertices are called here splitting nodes. Every of these nodes store 3 informations. The first one is its value,{} that is the current expression to evaluate. The second one is its condition,{} that is the hypothesis under which the value has to be evaluated. The last one is its status,{} that is a boolean flag which is \\spad{true} iff the value is the result of its evaluation under its condition. Two splitting vertices are equal iff they have the sane values and the same conditions (so their status do not matter)."))
 (|subNode?|
  (((|Boolean|) $ $ (|Mapping| (|Boolean|) |#2| |#2|))
   "\\spad{subNode?(n1,{} n2,{} o2)} returns \\spad{true} iff \\spad{value(n1) = value(n2)} and \\spad{o2(condition(n1),{} condition(n2))}"))
 (|infLex?|
  (((|Boolean|) $ $ (|Mapping| (|Boolean|) |#1| |#1|)
    (|Mapping| (|Boolean|) |#2| |#2|))
   "\\spad{infLex?(n1,{} n2,{} o1,{} o2)} returns \\spad{true} iff \\spad{o1(value(n1),{} value(n2))} or \\spad{value(n1) = value(n2)} and \\spad{o2(condition(n1),{} condition(n2))}."))
 (|setEmpty!|
  (($ $) "\\spad{setEmpty!(n)} replaces \\spad{n} by \\spad{empty()\\$\\%}."))
 (|setStatus!|
  (($ $ (|Boolean|))
   "\\spad{setStatus!(n,{} b)} returns \\spad{n} whose status has been replaced by \\spad{b} if it is not empty,{} else an error is produced."))
 (|setCondition!|
  (($ $ |#2|)
   "\\spad{setCondition!(n,{} t)} returns \\spad{n} whose condition has been replaced by \\spad{t} if it is not empty,{} else an error is produced."))
 (|setValue!|
  (($ $ |#1|)
   "\\spad{setValue!(n,{} v)} returns \\spad{n} whose value has been replaced by \\spad{v} if it is not empty,{} else an error is produced."))
 (|copy| (($ $) "\\spad{copy(n)} returns a copy of \\spad{n}."))
 (|construct|
  (((|List| $) |#1| (|List| |#2|))
   "\\spad{construct(v,{} lt)} returns the same as \\spad{[construct(v,{} t) for t in lt]}")
  (((|List| $) (|List| (|Record| (|:| |val| |#1|) (|:| |tower| |#2|))))
   "\\spad{construct(lvt)} returns the same as \\spad{[construct(vt.val,{} vt.tower) for vt in lvt]}")
  (($ (|Record| (|:| |val| |#1|) (|:| |tower| |#2|)))
   "\\spad{construct(vt)} returns the same as \\spad{construct(vt.val,{} vt.tower)}")
  (($ |#1| |#2|)
   "\\spad{construct(v,{} t)} returns the same as \\spad{construct(v,{} t,{} false)}")
  (($ |#1| |#2| (|Boolean|))
   "\\spad{construct(v,{} t,{} b)} returns the non-empty node with value \\spad{v},{} condition \\spad{t} and flag \\spad{b}"))
 (|status|
  (((|Boolean|) $)
   "\\spad{status(n)} returns the status of the node \\spad{n}."))
 (|condition|
  ((|#2| $)
   "\\spad{condition(n)} returns the condition of the node \\spad{n}."))
 (|value|
  ((|#1| $) "\\spad{value(n)} returns the value of the node \\spad{n}."))
 (|empty?|
  (((|Boolean|) $)
   "\\spad{empty?(n)} returns \\spad{true} iff the node \\spad{n} is \\spad{empty()\\$\\%}."))
 (|empty|
  (($)
   "\\spad{empty()} returns the same as \\spad{[empty()\\$V,{} empty()\\$C,{} false]\\$\\%}")))
(("documentation" 0 7842) ("ancestors" 0 7761) ("parents" 0 7737)
 ("abbreviation" 0 7729) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 6736) ("modemaps" 0 2385) ("sourceFile" 0 2346)
 ("constructorCategory" 0 1298) ("constructorModemap" 0 51)
 ("constructorKind" 0 42) ("constructorForm" 0 20))