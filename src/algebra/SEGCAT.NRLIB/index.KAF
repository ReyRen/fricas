4986                (|SegmentCategory| S)
|category|
(((|SegmentCategory| |#1|) (|Category|) (|Type|)) (T |SegmentCategory|))
(|Join| (|Type|)
        (CATEGORY |domain| (SIGNATURE SEGMENT ($ |t#1| |t#1|))
         (SIGNATURE BY ($ $ (|Integer|))) (SIGNATURE |low| (|t#1| $))
         (SIGNATURE |high| (|t#1| $)) (SIGNATURE |incr| ((|Integer|) $))
         (SIGNATURE |segment| ($ |t#1| |t#1|)) (SIGNATURE |convert| ($ |t#1|))
         (IF (|has| |t#1| (|SetCategory|))
             (ATTRIBUTE (|SetCategory|))
             |noBranch|)
         (IF (|has| |t#1| (|ConvertibleTo| (|InputForm|)))
             (ATTRIBUTE (|ConvertibleTo| (|InputForm|)))
             |noBranch|)
         (IF (|has| |t#1| (|AbelianSemiGroup|))
             (PROGN (SIGNATURE + ($ |t#1| $)) (SIGNATURE + ($ $ |t#1|)))
             |noBranch|)
         (IF (|has| |t#1| (|AbelianGroup|))
             (SIGNATURE - ($ $ |t#1|))
             |noBranch|)
         (IF (|has| |t#1| (|OrderedRing|))
             (SIGNATURE |reverse| ($ $))
             |noBranch|)))
"/git/fricas/src/algebra/SEGCAT.spad"
((SEGMENT (*1 *1 *2 *2)
  (AND (|ofCategory| *1 (|SegmentCategory| *2)) (|ofCategory| *2 (|Type|))))
 (BY (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|Integer|)) (|ofCategory| *1 (|SegmentCategory| *3))
       (|ofCategory| *3 (|Type|))))
 (|low| (*1 *2 *1)
  (AND (|ofCategory| *1 (|SegmentCategory| *2)) (|ofCategory| *2 (|Type|))))
 (|high| (*1 *2 *1)
  (AND (|ofCategory| *1 (|SegmentCategory| *2)) (|ofCategory| *2 (|Type|))))
 (|incr| (*1 *2 *1)
  (AND (|ofCategory| *1 (|SegmentCategory| *3)) (|ofCategory| *3 (|Type|))
       (|isDomain| *2 (|Integer|))))
 (|segment| (*1 *1 *2 *2)
  (AND (|ofCategory| *1 (|SegmentCategory| *2)) (|ofCategory| *2 (|Type|))))
 (|convert| (*1 *1 *2)
            (AND (|ofCategory| *1 (|SegmentCategory| *2))
                 (|ofCategory| *2 (|Type|))))
 (+ (*1 *1 *2 *1)
    (AND (|ofCategory| *1 (|SegmentCategory| *2)) (|ofCategory| *2 (|Type|))
         (|ofCategory| *2 (|AbelianSemiGroup|))))
 (+ (*1 *1 *1 *2)
    (AND (|ofCategory| *1 (|SegmentCategory| *2)) (|ofCategory| *2 (|Type|))
         (|ofCategory| *2 (|AbelianSemiGroup|))))
 (- (*1 *1 *1 *2)
    (AND (|ofCategory| *1 (|SegmentCategory| *2)) (|ofCategory| *2 (|Type|))
         (|ofCategory| *2 (|AbelianGroup|))))
 (|reverse| (*1 *1 *1)
  (AND (|ofCategory| *1 (|SegmentCategory| *2)) (|ofCategory| *2 (|Type|))
       (|ofCategory| *2 (|OrderedRing|)))))
((~= (((|Boolean|) $ $) 6 (|has| |#1| (|SetCategory|))))
 (|segment| (($ |#1| |#1|) 6))
 (|reverse| (($ $) 6 (|has| |#1| (|OrderedRing|)))) (|low| ((|#1| $) 6))
 (|latex| (((|String|) $) 6 (|has| |#1| (|SetCategory|))))
 (|incr| (((|Integer|) $) 6)) (|high| ((|#1| $) 6))
 (|hashUpdate!|
  (((|HashState|) (|HashState|) $) 6 (|has| |#1| (|SetCategory|))))
 (|hash| (((|SingleInteger|) $) 6 (|has| |#1| (|SetCategory|))))
 (|convert| (($ |#1|) 6)
            (((|InputForm|) $) 6 (|has| |#1| (|ConvertibleTo| (|InputForm|)))))
 (|coerce| (((|OutputForm|) $) 6 (|has| |#1| (|SetCategory|))))
 (SEGMENT (($ |#1| |#1|) 6)) (BY (($ $ (|Integer|)) 6))
 (= (((|Boolean|) $ $) 6 (|has| |#1| (|SetCategory|))))
 (- (($ $ |#1|) 6 (|has| |#1| (|AbelianGroup|))))
 (+ (($ |#1| $) 6 (|has| |#1| (|AbelianSemiGroup|)))
    (($ $ |#1|) 6 (|has| |#1| (|AbelianSemiGroup|)))))
SEGCAT
(((|Type|) . T) ((|SetCategory|) |has| |#1| (|SetCategory|))
 ((|ConvertibleTo| (|InputForm|)) |has| |#1| (|ConvertibleTo| (|InputForm|))))
(((|BasicType|) |has| |#1| (|SetCategory|))
 ((|CoercibleTo| (|OutputForm|)) |has| |#1| (|SetCategory|))
 ((|ConvertibleTo| (|InputForm|)) |has| |#1| (|ConvertibleTo| (|InputForm|)))
 ((|SetCategory|) |has| |#1| (|SetCategory|)) ((|Type|) . T))
((|constructor|
  (NIL
   "This category provides operations on ranges,{} or {\\em segments} as they are called."))
 (|reverse|
  (($ $) "\\spad{reverse(s)} returns segment \\spad{s} in reverse order."))
 (-
  (($ $ |#1|) "\\spad{(l..h)\\spad{-i}} returns segment \\spad{l-i .. h-i}."))
 (+ (($ $ |#1|) "\\spad{(l..h)\\spad{+i}} returns segment \\spad{l+i .. h+i}.")
    (($ |#1| $) "\\spad{i+(l..h)} returns segment \\spad{i+l .. i+h}."))
 (|convert| (($ |#1|) "\\spad{convert(i)} creates the segment \\spad{i..i}."))
 (|segment|
  (($ |#1| |#1|)
   "\\spad{segment(i,{} j)} is an alternate way to create the segment \\spad{i..j}."))
 (|incr|
  (((|Integer|) $)
   "\\spad{incr(s)} returns \\spad{n},{} where \\spad{s} is a segment in which every \\spad{n}\\spad{-}th element is used. Note: \\spad{incr(l..h by n) = n}."))
 (|high|
  ((|#1| $)
   "\\spad{high(s)} returns the second endpoint of \\spad{s}. Note: \\spad{high(l..h) = h}."))
 (|low|
  ((|#1| $)
   "\\spad{low(s)} returns the first endpoint of \\spad{s}. Note: \\spad{low(l..h) = l}."))
 (BY
  (($ $ (|Integer|))
   "\\spad{s by n} creates a new segment in which only every \\spad{n}\\spad{-}th element is used."))
 (SEGMENT
  (($ |#1| |#1|)
   "\\spad{l..h} creates a segment with \\spad{l} and \\spad{h} as the endpoints.")))
(("documentation" 0 3693) ("ancestors" 0 3448) ("parents" 0 3308)
 ("abbreviation" 0 3301) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 2441) ("modemaps" 0 1081) ("sourceFile" 0 1043)
 ("constructorCategory" 0 126) ("constructorModemap" 0 53)
 ("constructorKind" 0 42) ("constructorForm" 0 20))