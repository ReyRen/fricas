)abbrev package INTPAR2 ParametricIntegration
ParametricIntegration(R, F) : Exports == Implementation where
  R : Join(GcdDomain, Comparable, CharacteristicZero,
           RetractableTo Integer, LinearlyExplicitOver Integer)
  F : Join(AlgebraicallyClosedField, TranscendentalFunctionCategory,
           FunctionSpace R)

  Q   ==> Fraction(Integer)
  SE  ==> Symbol
  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  UP  ==> SparseUnivariatePolynomial F
  RF  ==> Fraction UP
  OPDIFF ==> '%diff
  Partial_C ==>  Union(Vector F, "failed")
  Both_C ==> Record(particular : Partial_C, basis : List Vector F)
  Param_Rec_F ==> Record(ratpart : F, coeffs : Vector F)
  L_Param_F ==> List Param_Rec_F
  Partial_F ==>  Union(Param_Rec_F, "failed")
  Both_F ==> Record(particular : Partial_F, basis : L_Param_F)
  Param_Rec_Q ==> Record(ratpart : RF, coeffs : Vector F)
  L_Param_Q ==> List Param_Rec_Q
  Param_Rec_QF ==> Record(logands : List F, basis : List Vector Q)
  Param_Rec_Q2 ==> Record(logands : List RF, basis : List Vector Q)

  Exports ==> with
    extendedint : (SE, List K, List F) -> L_Param_F
      ++ extendedint(x, [k1, ..., kn], [g1, ..., gn]) returns
      ++ a basis of the homogeneous system
      ++ \spad{dh/dx + c1*g1 + ... + cn*gn = 0}.  Solutions are
      ++ in the field generated by k1, ..., kn.
    extendedint : (F, SE, List K, List F) -> Both_F
      ++ extendedint(f, x, [k1, ..., kn], [g1, ..., gn]) is like
      ++ extendedint(f, [k1, ..., kn], [g1, ..., gn]) but looks for
      ++ solutions in the field generated by k1, ..., kn.
    extendedint : (F, SE, List F) -> Both_F
      ++ extendedint(f, x, [g1, ..., gn]) returns
      ++ solution of the system  \spad{f = dh/dx + c1*g1 + ... + cn*gn} and
      ++ and a basis of the associated homogeneous system
      ++ \spad{dh/dx + c1*g1 + ... + cn*gn = 0}.  Solutions are
      ++ in the field generated by kernels of f and g1, ..., gn.
    logextint : (SE, List K, List F) -> Param_Rec_QF
      ++ logextint(x, lk, lg) returns [[u1, ..., um], bas] giving
      ++ basis of solution of
      ++ the homogeneous systym
      ++ \spad{c1*g1 + ... + cn*gn + c_{n+1}u1'/u1 + ... c_{n+m}um'/um  = 0}

  Implementation ==> add
    import from IntegrationTools(R, F)
    import from AlgebraicManipulations(R, F)
    import from FunctionSpacePrimitiveElement(R, F)
    import from PolynomialCategoryQuotientFunctions(IndexedExponents K,
                                                             K, R, P, F)

    PRIM := 'prim
    ALGOP := '%alg

    algextint : (SE, K, List K, List F) -> L_Param_F
    primextint : (SE, K, List K, List F) -> L_Param_F
    expextint : (SE, K, List K, List F) -> L_Param_F
    diffextint : (SE, K,  List K, List F) -> L_Param_F
    unkextint : (SE, K,  List K, List F) -> L_Param_F

    alglfint    : (F, K, List K, SE) -> IR
    algprimint  : (F, K, K, SE) -> IR
    algexpint   : (F, K, K, SE) -> IR
    primint     : (F, SE, K) -> IR
    expint      : (F, SE, K) -> IR
    lambint     : (F, SE, K) -> IR
    prim?       : (K, SE)  -> Boolean
    isx?        : (F, SE)  -> Boolean
    addx        : (IR, F) -> IR
    cfind       : (F, LLG) -> F
    lfintegrate0 : (F, SE) -> IR

    prim?(k, x)      == is?(k, 'log) or has?(operator k, PRIM)

    csolve2(m : Matrix(F)) : List Vector Q ==
        n := nrows(m)
        v := new(n, 0)$Vector(F)
        (solveLinearlyOverQ(m, v)$IntegerLinearDependence(F)).basis

    EFACT ==> ExpressionFactorPolynomial(R, F)

    primlogextint(x : SE, k : K, l : List(K), lg : List F) : Param_Rec_QF ==
        rec1 := (lg1 : List F) : Param_Rec_QF +->
                logextint(x, l, lg1)
        rec := (lg2 : List UP) : Param_Rec_Q2 +->
                monologextint(lg2, csolve2, rec1
                              )$ParametricTranscendentalIntegration(F, UP)
        d1 := (x1 : F) : F +-> differentiate(x1, x)
        der := (x1 : UP) : UP+->differentiate(x1, d1,
                differentiate(k::F, x)::UP)
        uf : UP -> Factored(UP) := factorPolynomial$EFACT
        (ll, bl) := logextint(der, uf, csolve2,
                      rec, [univariate(g, k) for g in lg]
                      )$ParametricTranscendentalIntegration(F, UP)
        [[multivariate(le, k) for le in ll], bl]

    explogextint1(lg : List(UP), eta : F, rec1 : List F -> Param_Rec_QF
                 ) : Param_Rec_Q2 ==
        lg1 := concat(lg, eta::UP)
        (ll, bl) := monologextint(lg1, csolve2, rec1
                           )$ParametricTranscendentalIntegration(F, UP)
        ll1 := cons(monomial(1, 1)$UP::RF, ll)
        [ll1, bl]

    explogextint(x : SE, k : K, l : List(K), lg : List F) : Param_Rec_QF ==
        eta := differentiate(first(argument(k)), x)
        d1 := (x1 : F) : F +-> differentiate(x1, x)
        der := (x1 : UP) : UP +-> differentiate(x1, d1,
                 monomial(eta, 1)$UP)
        rec1 := (lg1 : List F) : Param_Rec_QF +->
                logextint(x, l, lg1)
        rec := (lg2 : List UP) : Param_Rec_Q2 +->
            explogextint1(lg2, eta, rec1)
        uf : UP -> Factored(UP) := factorPolynomial$EFACT
        (ll, bl) := logextint(der, uf, csolve2,
                      rec, [univariate(g, k) for g in lg]
                      )$ParametricTranscendentalIntegration(F, UP)
        [[multivariate(le, k) for le in ll], bl]

    alglogextint(x : SE, k : K, l : List(K), lg : List F) : Param_Rec_QF ==
        every?((g : F) : Boolean +-> not(member?(k, kernels(g))), lg) =>
            logextint(x, l, lg)
        error "alglogextint: unimplemented"

    logextint(x, l, lg) ==
        empty?(l) =>
            cb := csolve2(matrix([lg])$Matrix(F))
            [[], cb]
        k := kmax(l)
        l := [k1 for k1 in l | k1 ~= k]
        symbolIfCan(k) case SE or prim?(k, x) =>
            primlogextint(x, k, l, lg)
        is?(k, 'exp) => explogextint(x, k, l, lg)
        has?(operator k, ALGOP)$BasicOperator => alglogextint(x, k, l, lg)
        error "logextint: unhandled kernel"

    extendedint(f : F, x : SE, lg : List F) ==
        l := varselect(tower(cons(x::F, cons(f, lg))), x)
        extendedint(f, x, l, lg)

    extendedint(x : SE, l : List K, lg : List F) ==
        empty?(l) =>
            cb := nullSpace(matrix([lg])$Matrix(F))
            [[0, kv] for kv in cb]
        k := kmax(l)
        l := [k1 for k1 in l | k1 ~= k]
        symbolIfCan(k) case SE or prim?(k, x) =>
            primextint(x, k, l, lg)
        is?(k, 'exp) =>
            expextint(x, k, l, lg)
        has?(operator k, ALGOP) =>
            algextint(x, k, l, lg)
        is?(k, OPDIFF) =>
            diffextint(x, k, l, lg)
        unkextint(x, k, l, lg)

    extendedint(f, x, l, lg) ==
        dehomogenize(extendedint(x, l, cons(-f, lg))
                    )$LinearCombinationUtilities(F, UP)

    csolve1(m : Matrix F, d1 : F -> F) : List Vector(F) ==
        nullSpaceOverConstants(m, [d1])$ConstantLinearDependence(R, F)

    wrapfn(fn : List F -> L_Param_F, k : K) : List RF -> L_Param_Q ==
        (lrf : List RF) : L_Param_Q +->
            lf := [multivariate(rf, k) for rf in lrf]
            r1 := fn(lf)
            la := [univariate(be.ratpart, k) for be in r1]
            [[a, be.coeffs] for a in la for be in r1]

    algextint(x, k, l, lg) ==
        import from LinearCombinationUtilities(F, UP)
        k1 := kmax(l)
        l := [k2 for k2 in l | k2 ~= k1]
        symbolIfCan(k1) case SE or prim?(k1, x) or is?(k1, 'exp) =>
            d1 := (x1 : F) : F +-> differentiate(x1, x)
            cs1 := (x2 : Matrix F) : List Vector(F) +-> csolve1(x2, d1)
            dk : UP :=
                is?(k1, 'exp) =>
                   monomial(differentiate(first argument k1, x), 1)
                differentiate(k1::F, x)::UP
            der1 := (x1 : UP) : UP+->differentiate(x1, d1, dk)
            symbolIfCan(k1) case SE =>
                algextint_base(k1, k, der1, cs1, lg
                              )$AlgebraicIntegration(R, F)
            ext1 := (x3 : List F) : L_Param_F +->
                      extendedint(x, cons(k1, l), x3)
            ext2 := (x4 : List K, x3 : List F) : L_Param_F +->
                      extendedint(x, x4, x3)
            logi := (x2 : List K, x3 : List F) : Param_Rec_QF +->
                      logextint(x, x2, x3)
            rde1 := (x6 : F, x3 : List F) : L_Param_F +->
                param_rde2(x6, x3, x, cons(k1, l), ext2, logi
                          )$ParametricRischDE(R, F)
            rde2 := (x5 : RF, x4 : List RF) : L_Param_Q +->
                wrapfn((x3 : List F) : L_Param_F +->
                    rde1(multivariate(x5, k1), x3), k1)(x4)
            algextint(k1, k, der1, wrapfn(ext1, k1), rde2, cs1, lg
                     )$AlgebraicIntegration(R, F)
        has?(operator k1, ALGOP) =>
            is?(operator k, 'nthRoot) and is?(operator k1, 'nthRoot) and
              not(member?(k1, tower(k::F))) =>
                l := [k2 for k2 in l | k2 ~= k1]
                al :=  alg_split_roots(lg, k, k1
                         )$RootFSSplit(R, F)
                n := #lg
                ca := [0$F for i in 1..n]
                cb := [new(n, 0)$Vector(F) for i in 1..n]
                for i in 1..n for bv in cb repeat
                    bv(i) := 1
                for rec in al repeat
                    lg1 := [lin_comb(bv, rec.funs) for bv in cb]
                    res1 : L_Param_F
                    if rec.npow1 + rec.npow2 > 0 then
                        nrr := retract(rec.nroot)@K
                        res1 := extendedint(x, cons(nrr, l), lg1)
                        oroot := (k::F)^rec.npow1*(k1::F)^rec.npow2
                        na1 := [eval(be.ratpart, nrr, oroot)
                                 for be in res1]
                    else
                        res1 := extendedint(x, l, lg1)
                        na1 := [be.ratpart for be in res1]
                    nca := [lin_comb(be.coeffs, ca) + a1 for be in res1
                              for a1 in na1]
                    ca := nca
                    ncb := [lin_comb(be.coeffs, cb) for be in res1]
                    cb := ncb
                [[a1, bv] for a1 in ca for bv in cb]
            rec := primitiveElement(k1::F, k::F)
            y   := rootOf(rec.prim)
            yk  := retract(y)@K
            nk1 := (rec.pol1) y
            nk  := (rec.pol2) y
            lg1 := [eval(g, [k1, k], [nk1, nk]) for g in lg]
            res1 := algextint(x, yk, l, lg1)
            [[eval(be.ratpart, yk, rec.primelt), be.coeffs] for be in res1]
        error "algextint unimplemented kernel"

    primextint(x, k, l, lu) ==
        d1 := (x1 : F) : F +-> differentiate(x1, x)
        der := (x1 : UP) : UP+->differentiate(x1, d1,
                differentiate(k::F, x)::UP)
        ext := (x3 : List F) : L_Param_F +->
                      extendedint(x, l, x3)
        cs1 := (x4 : Matrix F) : List Vector F +->
                      csolve1(x4, d1)
        res1 := primextint(der, ext, cs1,
                  [univariate(u, k) for u in lu]
                 )$ParametricTranscendentalIntegration(F, UP)
        [[multivariate(si.ratpart, k), si.coeffs]
           for si in res1]

    expextint(x, k, l, lu) ==
        eta := first argument k
        d1 := (x1 : F) : F +-> differentiate(x1, x)
        der := (x1 : UP) : UP+->differentiate(x1, d1,
                monomial(differentiate(eta, x), 1))
        ext := (x2 : List K, x3 : List F) : L_Param_F +->
                      extendedint(x, x2, x3)
        logi := (x2 : List K, x3 : List F) : Param_Rec_QF +->
                      logextint(x, x2, x3)
        rde := (x1 : Integer, x3 : List F) : L_Param_F +->
                 param_rde(x1, eta, x3, x, l, ext, logi
                          )$ParametricRischDE(R, F)
        cs1 := (x4 : Matrix F) : List Vector F +->
                      csolve1(x4, d1)
        res1 := expextint(der, rde, cs1,
                  [univariate(u, k) for u in lu]
                  )$ParametricTranscendentalIntegration(F, UP)
        [[multivariate(si.ratpart, k), si.coeffs]
           for si in res1]

    diffextint1(lup : List UP, x : SE, k : K, lk : List K,
                  csolve : Matrix(F) -> List Vector(F)) : L_Param_F ==
        import from LinearCombinationUtilities(F, UP)
        args := argument(k)
        #args ~= 3 => error "internal error, k is not a diff"
        arg3 := args(3)
        (da3 := differentiate(arg3, x)) = 0 =>
            m1 : Matrix(UP) := matrix([lup])
            rs1 : Matrix(F) := reducedSystem(m1)
            b0 := csolve(rs1)
            [[0, bv] for bv in b0]
        lg0 := [coefficient(up, 0) for up in lup]
        lg1 := [coefficient(up, 1) for up in lup]
        k1 := eval(args(1), retract(args(2))@K, arg3)
        dv := new()$Symbol
        dvf := dv::F
        lg2 := [eval(g/da3, k1, dvf) for g in lg1]
        lek := [eval(ki::F, k1, dvf) for ki in lk]
        lk1 := varselect(tower(cons(dvf, append(lg2, lek))), dv)
        res1 := extendedint(dv, lk1, lg2)
        empty?(res1) => []
        cb0 := [be.coeffs for be in res1]
        d1 := (x1 : F) : F +-> differentiate(x1, x)
        (m2, cb) := constant_subspace(cb0, [d1]
                                     )$ConstantLinearDependence(R, F)
        empty?(cb) => []
        v2 := vector([be.ratpart for be in res1])$Vector(F)
        v3 := m2*v2
        lca := entries(v3)
        lg3 := [lin_comb(bv, lg1) for bv in cb]
        nlg0 := [lin_comb(bv, lg0) for bv in cb]
        lca := map((x1 : F) : F+->eval(x1, kernel(dv), k1::F), lca)
        nlg : List(F) := []
        for ca in lca for g1 in lg3 for g0 in nlg0 repeat
            du := univariate(differentiate(ca, x), k)
            nu := numer(du)
            denom(du) ~= 1 or degree(nu) > 1 => return []
            g1 + coefficient(nu, 1) ~= 0 => return []
            ng := g0 + coefficient(nu, 0)
            nlg := cons(ng, nlg)
        nlg := reverse!(nlg)
        res2 := extendedint(x, lk, nlg)
        empty?(res2) => []
        cb1 := [be.coeffs for be in res2]
        nlca := [be.ratpart for be in res2]
        ncb := [lin_comb(bv, cb) for bv in cb1]
        nlca := [be.ratpart + lin_comb(bv, lca) for bv in cb1 for be in res2]
        [[ba, bv] for ba in nlca for bv in ncb]

    diffextint(x, k, l, lg) ==
        d1 := (x1 : F) : F +-> differentiate(x1, x)
        cs1 := (x4 : Matrix F) : List Vector F +->
                      csolve1(x4, d1)
        diffi1 := (x1 : List UP) : L_Param_F +->
                 diffextint1(x1, x, k, l, cs1)
        diffextint(diffi1, cs1, [univariate(u, k) for u in lg]
                  )$ParametricTranscendentalIntegration(F, UP)

    unkextint(x, k, l, lg) ==
        d1 := (x1 : F) : F +-> differentiate(x1, x)
        cs1 := (x4 : Matrix F) : List Vector F +->
                      csolve1(x4, d1)
        ext := (x3 : List F) : L_Param_F +->
                      extendedint(x, l, x3)
        unkextint(ext, cs1, [univariate(u, k) for u in lg]
                 )$ParametricTranscendentalIntegration(F, UP)
