)abbrev package ODESYS SystemODESolver
++ Author: Manuel Bronstein
++ Date Created: 11 June 1991
++ Description: SystemODESolver provides tools for triangulating
++ and solving some systems of linear ordinary differential equations.
++ Keywords: differential equation, ODE, system
SystemODESolver(F, LO) : Exports == Implementation where
  F : Field
  LO : LinearOrdinaryDifferentialOperatorCategory F

  N   ==> NonNegativeInteger
  Z   ==> Integer
  MF  ==> Matrix F
  M   ==> Matrix LO
  V   ==> Vector F
  UF  ==> Union(F, "failed")
  UV  ==> Union(V, "failed")
  REC ==> Record(mat : M, vec : V)
  FSL ==> Record(particular : UF, basis : List F)
  VSL ==> Record(particular : UV, basis : List V)
  SOL ==> Record(particular : F, basis : List F)
  USL ==> Union(SOL, "failed")
  ER  ==> Record(C : MF, g : V, eq : LO, rh : F)
  ER2 ==> Record(C : MF, lg : List V, eq : LO, lrh : List F)
  Param_Rec_F ==> Record(ratpart : F, coeffs : Vector F)
  Param_Rec_V ==> Record(ratpart : V, coeffs : Vector F)
  FPL ==> Record(particular : List Param_Rec_F, basis : List F)
  VPL ==> Record(particular : List Param_Rec_V, basis : List V)

  Exports ==> with
    triangulate : (MF, V) -> Record(A : MF, eqs : List ER)
      ++ triangulate(M, v) returns
      ++ \spad{A, [[C_1, g_1, L_1, h_1], ..., [C_k, g_k, L_k, h_k]]}
      ++ such that under the change of variable \spad{y = A z}, the first
      ++ order linear system \spad{D y = M y + v} is uncoupled as
      ++ \spad{D z_i = C_i z_i + g_i} and each \spad{C_i} is a companion
      ++ matrix corresponding to the scalar equation \spad{L_i z_j = h_i}.
    triangulate : (MF, List V) ->  Record(A : MF, eqs : List ER2)
      ++ triangulate(A, lv) is a parametric version of triangulate(A, v).
    triangulate : (M, V) -> REC
      ++ triangulate(m, v) returns \spad{[m_0, v_0]} such that \spad{m_0}
      ++ is upper triangular and the system \spad{m_0 x = v_0} is equivalent
      ++ to \spad{m x = v}.
    triangulate : (M, List V) -> Record(mat : M, vecs : List V)
      ++ triangulate(m, [v1, ..., vn]) returns  \spad{[m_0, [w1, ..., wn]]}
      ++ such that for any constant \spad{c1, ..., cn} the system
      ++ \spad{m_0 x = c1*w1 + ... + cn*wn} is equivalent to
      ++ to \spad{m x = c1*v1 + ... + cn*vn}
    solve : (MF,V,(LO,F)->USL) -> Union(Record(particular:V, basis:MF), "failed")
      ++ solve(m, v, solve) returns \spad{[v_p, bm]} such that
      ++ the solutions in \spad{F} of the system \spad{D x = m x + v} are
      ++ \spad{v_p + c_1 v_1 + ... + c_m v_m} where the \spad{c_i's} are
      ++ constants, and the \spad{v_i's} are columns of \spad{bm} and
      ++ form a basis for the solutions of \spad{D x = m x}.
      ++ Argument \spad{solve} is a function for solving a single linear
      ++ ordinary differential equation in \spad{F}.
    solve : (MF, List V, (LO, List F) -> FPL) -> VPL
      ++ solve(m, lv, solve) is a parametric version of
      ++ solve(m, v, solve)
    solveInField : (M, V, (LO, F) -> FSL) -> VSL
      ++ solveInField(m, v, solve) returns \spad{[[v_1, ..., v_m], v_p]} such that
      ++ the solutions in \spad{F} of the system \spad{m x = v} are
      ++ \spad{v_p + c_1 v_1 + ... + c_m v_m} where the \spad{c_i's} are
      ++ constants, and the \spad{v_i's} form a basis for the solutions of
      ++ \spad{m x = 0}.
      ++ Argument \spad{solve} is a function for solving a single linear
      ++ ordinary differential equation in \spad{F}.
    solveInField : (M, List V, (LO, List F) -> FPL) -> VPL
      ++ solveInField(m, lv, solve) is a parametric version of
      ++ solveInField(m, v, solve)

  Implementation ==> add
    import from PseudoLinearNormalForm F
    import from LinearCombinationUtilities(F, SparseUnivariatePolynomial(F))

    M2F         : M -> Union(MF, "failed")

    diff := D()$LO

    solve(mm : MF, lv : List V, solf : (LO, List F) -> FPL) ==
        rec  := triangulate(mm, lv)
        nv := #lv
        mA := rec.A
        n := ncols(mA)
        k : N := 0             -- sum of sizes of visited companionblocks
        i : N := 0             -- number of companionblocks
        cb : List V := [new(nv, 0)$V for v in lv]
        pl : List V := [new(n, 0)$V for v in lv]
        base_vecs : List V := []
        l : Integer
        for i in 1..nv for bv in cb repeat
            bv(i) := 1
        for e in rec.eqs repeat
            crh := [lin_comb(bv, e.lrh) for bv in cb]
            u := solf(e.eq, crh)
            np1 := u.particular
            ncb := [lin_comb(be.coeffs, cb) for be in np1]
            nn := nrows(e.C) -- size of active companionblock
            for s in u.basis repeat
                base_vec : V := new(n, 0)
                base_vec(k + 1) := s
                for l in 2..nn repeat
                    base_vec(k + l) := diff base_vec(k + l - 1)
                base_vecs := cons(base_vec, base_vecs)
            npl := [lin_comb(be.coeffs, pl) for be in np1]
            for be in np1 for np in npl for bv in ncb repeat
                g1 := lin_comb(bv, e.lg)
                np(k + 1) := be.ratpart
                for l in 2..nn repeat
                    np(k + l) := diff np(k + l - 1) - g1(l - 1)
            k := k + nn
            pl := npl
            cb := ncb
        base_vecs := reverse!(base_vecs)
        [[[mA*np, bv] for np in pl for bv in cb],
         [mA*bvec for bvec in base_vecs]]

    USL_to_FPL(u : USL) : FPL ==
        u case "failed" => [[], []]
        us := u::SOL
        [[[us.particular, new(1, 1)]], us.basis]

    solve(mm : MF, v : V, solf : (LO,F)->USL) ==
        res1 := solve(mm, [v], (lo, lf) +-> USL_to_FPL(solf(lo, first(lf))))
        part := res1.particular
        empty?(part) => "failed"
        part1 := first(part)
        c1inv := inv((part1.coeffs)(1))
        s1 := c1inv*part1.ratpart
        bm := matrix([entries(bv) for bv in res1.basis])
        [s1, transpose(bm)]

    triangulate(m : MF, lv : List V) ==
      k : N := 0       -- sum of companion-dimensions
      rat := normalForm(m, 1, (f1 : F) : F +-> - diff f1)
      l   := companionBlocks(rat.R, [rat.Ainv * v for v in lv])
      ler : List(ER2) := []
      for er in l repeat
        n := nrows(er.C)         -- dimension of this companion vectorspace
        op : LO := 0               -- compute homogeneous equation
        for j in 0..n-1 repeat op := op + monomial((er.C)(n, j + 1), j)
        op := monomial(1, n) - op
        lh : List F := []
        for g in er.lg repeat
            sum : V := new(n::N, 0)    -- compute inhomogen Vector (25)
            for j in 1..n-1 repeat sum(j+1) := diff(sum(j)) + g(j)
            h0 : F := 0                 -- compute inhomogenity (26)
            for j in 1..n repeat h0 := h0 - (er.C)(n, j) * sum j
            h0 := h0 + diff(sum(n)) + g(n)
            lh := cons(h0, lh)
        lh := reverse!(lh)
        ler := concat([er.C, er.lg, op, lh], ler)
        k := k + n
      [rat.A, ler]

    triangulate(m : MF, v : V) ==
        res1 := triangulate(m, [v])
        ler : List(ER) := []
        for er2 in res1.eqs repeat
            ler := cons([er2.C, first(er2.lg), er2.eq, first(er2.lrh)], ler)
        ler := reverse!(ler)
        [res1.A, ler]

    import from OrePolynomialMatrixOperations(F, LO)

    solveInField(m : M, lv : List V, solf : (LO, List F) -> FPL) ==
      ((n := nrows m) = ncols m) and
         ((u := M2F(diagonalMatrix [diff for i in 1..n] - m)) case MF) =>
             solve(u::MF, lv, solf)
      rec := solve(m, 0, lv, solf)
      rec case "failed" => error "solveInField: system is underdeterminded"
      rec::VPL

    M2F m ==
        mf : MF := new(nrows m, ncols m, 0)
        for i in minRowIndex m .. maxRowIndex m repeat
            for j in minColIndex m .. maxColIndex m repeat
                (u := retractIfCan(m(i, j))@Union(F, "failed")) case "failed" =>
                     return "failed"
                mf(i, j) := u::F
        mf

    triangulate(m : M, lv : List V) == rowEchelon(m, 0, lv)

    triangulate(m : M, v : V) ==
        res1 := triangulate(m, [v])
        [res1.mat, first(res1.vecs)]

