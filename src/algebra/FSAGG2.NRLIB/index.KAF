3156                (|FiniteSetAggregateFunctions2| S A R B)
|package|
(((|FiniteSetAggregateFunctions2| |#1| |#2| |#3| |#4|)
  (CATEGORY |package| (SIGNATURE |map| (|#4| (|Mapping| |#3| |#1|) |#2|))
   (SIGNATURE |reduce| (|#3| (|Mapping| |#3| |#1| |#3|) |#2| |#3|))
   (SIGNATURE |scan| (|#4| (|Mapping| |#3| |#1| |#3|) |#2| |#3|)))
  (|SetCategory|) (|FiniteSetAggregate| |#1|) (|SetCategory|)
  (|FiniteSetAggregate| |#3|))
 (T |FiniteSetAggregateFunctions2|))
(CATEGORY |package| (SIGNATURE |map| (|#4| (|Mapping| |#3| |#1|) |#2|))
 (SIGNATURE |reduce| (|#3| (|Mapping| |#3| |#1| |#3|) |#2| |#3|))
 (SIGNATURE |scan| (|#4| (|Mapping| |#3| |#1| |#3|) |#2| |#3|)))
"/git/fricas/src/algebra/FSAGG2.spad"
((|scan| (*1 *2 *3 *4 *5)
  (AND (|isDomain| *3 (|Mapping| *5 *6 *5)) (|ofCategory| *6 (|SetCategory|))
       (|ofCategory| *5 (|SetCategory|))
       (|ofCategory| *2 (|FiniteSetAggregate| *5))
       (|isDomain| *1 (|FiniteSetAggregateFunctions2| *6 *4 *5 *2))
       (|ofCategory| *4 (|FiniteSetAggregate| *6))))
 (|reduce| (*1 *2 *3 *4 *2)
  (AND (|isDomain| *3 (|Mapping| *2 *5 *2)) (|ofCategory| *5 (|SetCategory|))
       (|ofCategory| *2 (|SetCategory|))
       (|isDomain| *1 (|FiniteSetAggregateFunctions2| *5 *4 *2 *6))
       (|ofCategory| *4 (|FiniteSetAggregate| *5))
       (|ofCategory| *6 (|FiniteSetAggregate| *2))))
 (|map| (*1 *2 *3 *4)
  (AND (|isDomain| *3 (|Mapping| *6 *5)) (|ofCategory| *5 (|SetCategory|))
       (|ofCategory| *6 (|SetCategory|))
       (|ofCategory| *2 (|FiniteSetAggregate| *6))
       (|isDomain| *1 (|FiniteSetAggregateFunctions2| *5 *4 *6 *2))
       (|ofCategory| *4 (|FiniteSetAggregate| *5)))))
((|scan| ((|#4| (|Mapping| |#3| |#1| |#3|) |#2| |#3|) 22))
 (|reduce| ((|#3| (|Mapping| |#3| |#1| |#3|) |#2| |#3|) 20))
 (|map| ((|#4| (|Mapping| |#3| |#1|) |#2|) 17)))
FSAGG2
((|constructor|
  (NIL
   "\\spad{FiniteSetAggregateFunctions2} provides functions involving two finite set aggregates where the underlying domains might be different. An example of this is to create a set of rational numbers by mapping a function across a set of integers,{} where the function divides each integer by 1000."))
 (|scan|
  ((|#4| (|Mapping| |#3| |#1| |#3|) |#2| |#3|)
   "\\spad{scan(f,{} a,{} r)} successively applies \\spad{reduce(f,{} x,{} r)} to more and more leading sub-aggregates \\spad{x} of aggregate \\spad{a}. More precisely,{} if \\spad{a} is \\spad{[a1,{} a2,{} ...]},{} then \\spad{scan(f,{} a,{} r)} returns \\spad {[reduce(f,{} [a1],{} r),{} reduce(f,{} [a1,{} a2],{} r),{} ...]}."))
 (|reduce|
  ((|#3| (|Mapping| |#3| |#1| |#3|) |#2| |#3|)
   "\\spad{reduce(f,{} a,{} r)} applies function \\spad{f} to each successive element of the aggregate \\spad{a} and an accumulant initialised to \\spad{r}. For example,{} \\spad{reduce(_+\\$Integer,{} [1,{} 2,{} 3],{} 0)} does a \\spad{3+(2+(1+0))}. Note: third argument \\spad{r} may be regarded as an identity element for the function."))
 (|map|
  ((|#4| (|Mapping| |#3| |#1|) |#2|)
   "\\spad{map(f,{} a)} applies function \\spad{f} to each member of aggregate \\spad{a},{} creating a new aggregate with a possibly different underlying domain.")))
(("documentation" 0 1829) ("ancestors" 0 NIL) ("parents" 0 NIL)
 ("abbreviation" 0 1822) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 1653) ("modemaps" 0 706) ("sourceFile" 0 668)
 ("constructorCategory" 0 465) ("constructorModemap" 0 71)
 ("constructorKind" 0 61) ("constructorForm" 0 20))