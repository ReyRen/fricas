3344                (|FiniteLinearAggregateFunctions2| S A R B)
|package|
(((|FiniteLinearAggregateFunctions2| |#1| |#2| |#3| |#4|)
  (CATEGORY |package| (SIGNATURE |map| (|#4| (|Mapping| |#3| |#1|) |#2|))
   (SIGNATURE |reduce| (|#3| (|Mapping| |#3| |#1| |#3|) |#2| |#3|))
   (SIGNATURE |scan| (|#4| (|Mapping| |#3| |#1| |#3|) |#2| |#3|)))
  (|Type|) (|Join| (|LinearAggregate| |#1|) (|finiteAggregate|)) (|Type|)
  (|Join| (|LinearAggregate| |#3|) (|finiteAggregate|)))
 (T |FiniteLinearAggregateFunctions2|))
(CATEGORY |package| (SIGNATURE |map| (|#4| (|Mapping| |#3| |#1|) |#2|))
 (SIGNATURE |reduce| (|#3| (|Mapping| |#3| |#1| |#3|) |#2| |#3|))
 (SIGNATURE |scan| (|#4| (|Mapping| |#3| |#1| |#3|) |#2| |#3|)))
"/git/fricas/src/algebra/FLAGG2.spad"
((|scan| (*1 *2 *3 *4 *5)
  (AND (|isDomain| *3 (|Mapping| *5 *6 *5)) (|ofCategory| *6 (|Type|))
       (|ofCategory| *5 (|Type|))
       (|ofCategory| *2 (|Join| (|LinearAggregate| *5) (|finiteAggregate|)))
       (|isDomain| *1 (|FiniteLinearAggregateFunctions2| *6 *4 *5 *2))
       (|ofCategory| *4 (|Join| (|LinearAggregate| *6) (|finiteAggregate|)))))
 (|reduce| (*1 *2 *3 *4 *2)
  (AND (|isDomain| *3 (|Mapping| *2 *5 *2)) (|ofCategory| *5 (|Type|))
       (|ofCategory| *2 (|Type|))
       (|isDomain| *1 (|FiniteLinearAggregateFunctions2| *5 *4 *2 *6))
       (|ofCategory| *4 (|Join| (|LinearAggregate| *5) (|finiteAggregate|)))
       (|ofCategory| *6 (|Join| (|LinearAggregate| *2) (|finiteAggregate|)))))
 (|map| (*1 *2 *3 *4)
  (AND (|isDomain| *3 (|Mapping| *6 *5)) (|ofCategory| *5 (|Type|))
       (|ofCategory| *6 (|Type|))
       (|ofCategory| *2 (|Join| (|LinearAggregate| *6) (|finiteAggregate|)))
       (|isDomain| *1 (|FiniteLinearAggregateFunctions2| *5 *4 *6 *2))
       (|ofCategory| *4 (|Join| (|LinearAggregate| *5) (|finiteAggregate|))))))
((|scan| ((|#4| (|Mapping| |#3| |#1| |#3|) |#2| |#3|) 23))
 (|reduce| ((|#3| (|Mapping| |#3| |#1| |#3|) |#2| |#3|) 15))
 (|map| ((|#4| (|Mapping| |#3| |#1|) |#2|) 21)))
FLAGG2
((|constructor|
  (NIL
   "\\spad{FiniteLinearAggregateFunctions2} provides functions involving two FiniteLinearAggregates where the underlying domains might be different. An example of this might be creating a list of rational numbers by mapping a function across a list of integers where the function divides each integer by 1000."))
 (|scan|
  ((|#4| (|Mapping| |#3| |#1| |#3|) |#2| |#3|)
   "\\spad{scan(f,{} a,{} r)} successively applies \\spad{reduce(f,{} x,{} r)} to more and more leading sub-aggregates \\spad{x} of aggregrate \\spad{a}. More precisely,{} if \\spad{a} is \\spad{[a1,{} a2,{} ...]},{} then \\spad{scan(f,{} a,{} r)} returns \\spad{[reduce(f,{} [a1],{} r),{} reduce(f,{} [a1,{} a2],{} r),{} ...]}."))
 (|reduce|
  ((|#3| (|Mapping| |#3| |#1| |#3|) |#2| |#3|)
   "\\spad{reduce(f,{} a,{} r)} applies function \\spad{f} to each successive element of the aggregate \\spad{a} and an accumulant initialized to \\spad{r}. For example,{} \\spad{reduce(_+\\$Integer,{} [1,{} 2,{} 3],{} 0)} does \\spad{3+(2+(1+0))}. Note: third argument \\spad{r} may be regarded as the identity element for the function \\spad{f}."))
 (|map|
  ((|#4| (|Mapping| |#3| |#1|) |#2|)
   "\\spad{map(f,{} a)} applies function \\spad{f} to each member of aggregate \\spad{a} resulting in a new aggregate over a possibly different underlying domain.")))
(("documentation" 0 1999) ("ancestors" 0 NIL) ("parents" 0 NIL)
 ("abbreviation" 0 1992) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 1823) ("modemaps" 0 753) ("sourceFile" 0 715)
 ("constructorCategory" 0 512) ("constructorModemap" 0 74)
 ("constructorKind" 0 64) ("constructorForm" 0 20))