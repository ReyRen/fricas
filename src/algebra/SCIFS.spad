)abbrev domain SCIFS SceneIFS
++ Author: Martin Baker (some parts adapted from NumericTubePlot by
++         Clifton J. Williamson)
++ Date Created: September 2010
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: Generates various surfaces (2 dimensional subsets
++ of 3D space). When 1 dimensional subspace (a line) needs to be
++ represented in a 3D editor then we convert the line into a tube.
++ Many of the functions here are from NumericTubePlot and related
++ packages. However I needed them to be defined over SPointCategory
++ so I adapted them here.
SceneIFS(PT) : Exports == Implementation where
 PT : SPointCategory

 NNI==> NonNegativeInteger
 DF==> DoubleFloat
 SEG ==> Segment DF
 Triad ==> Record(tang : PT, norm : PT, bin : PT)
 Clipd ==> Record(source : DF -> PT, _
                   ranges : List SEG, _
                   knots : List DF, _
                   points : List PT)

 Exports== with
  smesh : (ptin : List List PT, clos : Boolean) -> %
    ++ smesh(ptin, clos) constructs a ifs representation of a mesh from
    ++ a 2 dimensional array of points
  singleFace : (ptin : List PT) -> %
    ++ singleFace(ptin) constructs a ifs representation of a face from
    ++ an array of points
  subdivide : (me : %) -> %
    ++ subdivide(me) for each face calculate a new point in the centre
    ++ of the face, then build a new set of faces which include the new
    ++ point.
  sierpinskiDivide : (me : %, level : NNI) -> %
    ++ sierpinskiDivide(me, level) for each edge of each face calculate
    ++ a new point in the centre of the edge, then build a new set of
    ++ faces which include the new points.
  stube : (functions : List Clipd, r : DF, n : Integer) -> %
    ++ stube(functions: List Clipd, r, n) creates a tube of radius r around
    ++ the curve functions.
  curveLoops : (pts1 : List PT, r : DF, nn : Integer) ->List List PT
    ++ curveLoops(pts1, r, nn) generates ifs from line given by pts1
  indexes : (me : %) -> List List NNI
    ++ indexes(me) returns indexes into pointList(me)
  pointList : (me : %) -> List PT
    ++ pointList(me) returns points at vertices of this mesh.
  coerce : (me : %) -> OutputForm
    ++ coerce(me) list this instance to the command line

 Implementation == add
  Rep := Record(inx : List List NNI, pts : List PT)

  -- returns indexes
  indexes(me : %) : List List NNI == me.inx

  -- returns points
  pointList(me : %) : List PT == me.pts

  meshIndex(i : Integer, j : Integer, c : Integer) : NNI == ((j*(c)) + i)::NNI

  -- construct a ifs representation of a mesh from a 2 dimensional
  -- array of points
  smesh(ptin : List List PT, clos : Boolean) : % ==
   pt2 : List PT := []
   in2 : List List NNI := []
   rowLength := #ptin
   colLength := #(first ptin)
   j := 0
   for lpt in ptin repeat
     i := 0
     for p in lpt repeat
       pt2 := concat(pt2, p)
       if i > 0 and j > 0 then
         thisLine : List NNI := [meshIndex(i-1, j-1, colLength), _
                               meshIndex(i, j-1, colLength), _
                               meshIndex(i, j, colLength), _
                               meshIndex(i-1, j, colLength)]
         in2 := concat(in2, thisLine)
       i := i+ 1
     if clos and j > 0 then
       thisLine : List NNI := [meshIndex(i-1, j-1, colLength), _
                               meshIndex(0, j-1, colLength), _
                               meshIndex(0, j, colLength), _
                               meshIndex(i-1, j, colLength)]
       in2 := concat(in2, thisLine)
     j := j+1
   [in2, pt2]

  -- construct a ifs representation of a face from an array of points
  singleFace(ptin : List PT) : % ==
   pt2 : List PT := ptin
   --in2: List List NNI := [concat([i for i in 0..(#ptin - 1)], 0)]
   in2 : List List NNI := [[i for i in 0..(#ptin - 1)]]
   [in2, pt2]

  -- for each face calculate a new point in the centre of the face, then
  -- build a new set of faces which include the new point.
  subdivide(me : %) : % ==
    indexSize : NNI := #(me.pts)
    pt2 : List PT := [(me.pts).i for i in 1..indexSize]
    in2 : List List NNI := []
    for faceIx in me.inx repeat
      -- create new point as the average value of all the points in the face
      newPt := sipnt(0, 0, 0)
      for ptIx in faceIx repeat
        newPt := newPt + pt2.(ptIx+1)
      newPt := (1 / #faceIx)::DF * newPt
      -- add new point to list of points
      pt2 := concat(pt2, newPt)
      indexPos := 1
      -- build face indexes
      for ptIx in faceIx repeat
        newFace : List NNI := [faceIx.j for j in 1..(#(faceIx))]
        newFace.indexPos := indexSize
        indexPos := indexPos + 1
        in2 := concat(in2, newFace)
      indexSize := indexSize + 1
    [in2, pt2]

  -- for each edge of each face calculate a new point in the centre of
  -- the edge, then build a new set of faces which include the new points.
  sierpinskiDivide(me : %, level : NNI) : % ==
    indexSize : NNI := #(me.pts)
    pt2 : List PT := [(me.pts).i for i in 1..indexSize]
    in2 : List List NNI := []
    for faceIx in me.inx repeat
      -- create new point as the average value of edge ends
      for offset in 1..#faceIx repeat
        ix1 : NNI := offset
        ix2 : NNI := offset+1
        if ix2 > #faceIx then ix2 := 1
        newPt := pt2.((faceIx.ix1) + 1) + pt2.((faceIx.ix2) + 1)
        newPt := 0.5::DF * newPt
        pt2 := concat(pt2, newPt)
      index1 : NNI := ((#faceIx) - 1)::NNI
      index2 : NNI := 0
      -- build face indexes
      for offset in 1..#faceIx repeat
        ix3 := indexSize+index1
        ix4 := indexSize+index2
        newFace : List NNI := [faceIx.offset, ix3, ix4]
        index1 := index1 + 1
        if index1 = #faceIx then index1 := 0
        index2 := index2 + 1
        if index2 = #faceIx then index2 := 0
        in2 := concat(in2, newFace)
      indexSize := indexSize + #faceIx
    if level < 1 then return [in2, pt2]
    sierpinskiDivide([in2, pt2], (level-1)::NNI)

  -- listBranches(c) returns a list of lists of points, representing the
  -- branches of the curve c.
  listBranches(functions : List Clipd) : List List PT ==
    outList : List List PT := []
    for curve in functions repeat
      outList := concat(curve.points, outList)
    outList

  LINMAX := convert(0.995)@DF
  XHAT := sipnt(1, 0, 0)
  YHAT := sipnt(0, 1, 0)
  PREV0 := sipnt(1, 1, 0)
  PREV := PREV0

  orthog(x : PT, y : PT) : PT ==
      if colinearity(x, y) > LINMAX then y := PREV
      if colinearity(x, y) > LINMAX then
        y := (colinearity(x, XHAT) < LINMAX => XHAT; YHAT)
      a : DF := -parallel(x, y)/parallel(x, x)
      PREV := a*x + y

  poTriad(pl : PT, po : PT, pr : PT) : Triad ==
      -- use divided difference for t.
      t := unitVector(pr - pl)
      -- compute n as orthogonal to t in plane containing po.
      pol := pl - po
      n := unitVector orthog(t, pol)
      [t, n, perpendicular(t, n)]

  curveTriads(l : List PT) : List Triad ==
      (k := #l) < 2 => error "Need at least 2 points to specify a curve"
      PREV := PREV0
      k = 2 =>
        t := unitVector(second l - first l)
        n := unitVector(t - XHAT)
        b := perpendicular(t, n)
        triad : Triad := [t, n, b]
        [triad, triad]
      -- compute interior triads using divided differences
      midtriads : List Triad :=
        [poTriad(pl, po, pr) for pl in l for po in rest l _
               for pr in rest rest l]
      -- compute first triad using a forward difference
      x := first midtriads
      t := unitVector(second l - first l)
      n := unitVector orthog(t, x.norm)
      begtriad : Triad := [t, n, perpendicular(t, n)]
      -- compute last triad using a backward difference
      x := last midtriads
      -- efficiency!!
      t := unitVector(l.k - l.(k-1))
      n := unitVector orthog(t, x.norm)
      endtriad : Triad := [t, n, perpendicular(t, n)]
      concat(begtriad, concat(midtriads, endtriad))

  -- cosSinInfo(n) returns the list of lists of values for n, in the
  -- form: [[cos(n - 1) a, sin(n - 1) a], ..., [cos 2 a, sin 2 a], [cos a, sin a]]
  -- where a = 2 pi/n. Note: n should be greater than 2.
  cosSinInfo(n : Integer) : List List DF ==
      ans : List List DF := []
      theta : DF := 2 * pi()/n
      for i in 1..(n-1) repeat --!! make more efficient
        angle := i * theta
        ans := concat([cos angle, sin angle], ans)
      ans

  -- loopPoints(p, n, b, r, lls) creates and returns a list of points
  -- which form the loop with radius r, around the centre point
  -- indicated by the point p, with the principal normal vector of
  -- the space curve at point p given by the point(vector) n, and the
  -- binormal vector given by the point(vector) b, and a list of lists,
  -- lls, which is the \spadfun{cosSinInfo} of the number of points
  -- defining the loop.
  loopPoints(ctr : PT, pNorm : PT, bNorm : PT, rad : DF, cosSin : List List DF) : List PT ==
      ans : List PT := []
      while not(empty?(cosSin)) repeat
        cossin := first cosSin; cos := first cossin; sin := second cossin
        ans := cons(ctr + rad * (cos * pNorm + sin * bNorm), ans)
        cosSin := rest cosSin
      pt := ctr + rad * pNorm
      concat(pt, concat(ans, pt))

  curveLoops(pts1 : List PT, r : DF, nn : Integer) : List List PT ==
      triads := curveTriads pts1
      cosSin := cosSinInfo nn
      loops : List List PT := []
      for pt in pts1 for triad in triads repeat
        n := triad.norm; b := triad.bin
        loops := concat(loopPoints(pt, n, b, r, cosSin), loops)
      reverse! loops

  -- stube(functions, r, n) creates a tube of radius r around the
  -- curve functions.
  stube(functions : List Clipd, r : DF, n : Integer) : % ==
    n < 3 => error "tube: n should be at least 3"
    brans := listBranches functions
    loops : List List PT := []
    for bran in brans repeat
      loops := concat(loops, curveLoops(bran, r, n))
    smesh(loops, true)

  -- list this instance to the command line
  coerce(me : %) : OutputForm ==
    r : OutputForm := empty()
    for p in me.pts repeat
      r := hconcat(r, p::OutputForm)
      r := hconcat(r, message(" "))
    res : List OutputForm := [r] -- string to hold result
    for faceIx in me.inx repeat
      r := empty()
      for pIx in faceIx repeat
        r := hconcat(r, pIx::OutputForm)
        r := hconcat(r, message(" "))
      res := concat(res, r)
    vconcat(res)

)if false

\section{SceneNamedPoints}
The aim of the 'named points' node and associated domain is to provide
better support for drawing graphs (that is 'graphs' as in graph theory)
and diagrams of trees, latices and category theory arrow diagrams.
In other words, diagrams with named nodes and arrows or lines between
these nodes.

These diagrams can already be drawn, using this graphics framework
without this feature, however this requires that the coordinates
are supplied for each end of each line or arrow. If we want to stop
the arrow short of the nodes, to avoid overwriting the node name, then
the new coordinates would have to be recalculated using boilerplate
code.

So the aim is to separate the mathematical structure of the diagram
from the actual coordinates and issues of making the diagram more human
readable. Eventually we might also have some intelligent code that
places the node positions to minimise crossing the arrows and so on.

For example, imagine we wanted to add support for graph theory in
FriCAS (seems like it would be an interesting project) then we
could implement a GraphTheory domain and it might contain a
'draw' function to draw the graph to a SVG file. This code will have
a set of node names, say "a","b"... and the 'draw' function will
draw the appropriate arrows between them, however we don't want the
code to be cluttered up with specific coordinates so we put all that
in a 'named points' node (here called np). We can then then draw the
arrows thus:
\begin{verbatim}
addSceneArrow(np,"a","b"....
\end{verbatim}
\section{SceneNamedPoints Tutorial}
We can create a 'named points' domain to hold a list of names and
the points they map to:
\begin{verbatim}
(1) -> PT ==> SCartesian(2)
                                                             Type : Void

(2) -> ptin : List PT := [sipnt(100, 100)$PT, _
                                   sipnt(100, 200)$PT, sipnt(200, 200)$PT]
   (2)  [pt(100.0, 100.0), pt(100.0, 200.0), pt(200.0, 200.0)]
                                              Type : List(SCartesian(2))

(3) -> nmin: List String := ["a","b","c"]
   (3)  ["a","b","c"]
                                                     Type : List(String)

(4) -> namedPts : SceneNamedPoints PT := namedPoints(ptin, nmin)
   (4)  pt:"a":pt(100.0,100.0),"b":pt(100.0,200.0),"c":pt(200.0,200.0)
                                  Type : SceneNamedPoints(SCartesian(2))
\end{verbatim}
We can then use this 'named points' domain in the scene like this:
\begin{verbatim}
(5) -> view := boxBoundary(sipnt(0, 0)$PT, sipnt(1000, 1000)$PT)
   (5)  bound box : pt(0.0, 0.0)->pt(1000.0, 1000.0)
                                         Type : SBoundary(SCartesian(2))

(6) -> sc := createSceneRoot(view)$Scene(PT)
   (6)  scene root bound box : pt(0.0, 0.0)->pt(1000.0, 1000.0) #ch = 0
                                             Type : Scene(SCartesian(2))

(7) -> np := addSceneNamedPoints(sc, namedPts)$Scene(PT)
   (7)
   scene namedpoints n=
     pt:"a":pt(100.0,100.0),"b":pt(100.0,200.0),"c":pt(200.0,200.0)
      #ch = 0
                                             Type : Scene(SCartesian(2))

(8) -> nt := addSceneText(np,["a","b","c"],12::NNI,sipnt(50,50)$PT)
   (8)  scene text="a" sz = 12 p = pt(50.0,50.0) npt=["a","b","c"] #ch = 0
                                             Type : Scene(SCartesian(2))

(9) -> a1 := addSceneArrow(np,"a","b",_
                             sipnt(50,50)$PT,"fixed"::Symbol,2.0::DoubleFloat)
   (9)  scene arrows str="a" ena="b" ofs = pt(50.0,50.0) md = fixed sz = 2.0 #ch = 0
                                             Type : Scene(SCartesian(2))

(10) -> a2 := addSceneArrow(np,"b","c",_
                             sipnt(50,50)$PT,"fixed"::Symbol,2.0::DoubleFloat)
   (10)  scene arrows str="b" ena="c" ofs = pt(50.0,50.0) md = fixed sz = 2.0 #ch = 0
                                             Type : Scene(SCartesian(2))

(11) -> writeSvg(sc,"testGraph/examplenamed.svg")
                                                                   Type : Void
\end{verbatim}
Further information here:
\url{http://www.euclideanspace.com/prog/scratchpad/mycode/graph/tutorial/named/}
\section{domain SceneNamedPoints}
)endif

