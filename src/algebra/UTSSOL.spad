)abbrev package UTSSOL TaylorSolve
TaylorSolve(F, UTSF, UTSSMPF) : Exports == Implementation where
    F : Field
    SMPF  ==> SparseMultivariatePolynomialExpressions F
    UTSF : UnivariateTaylorSeriesCategory F
    UTSSMPF : UnivariateTaylorSeriesCategory SMPF
    NNI  ==> NonNegativeInteger

    Exports == with
        seriesSolve : (UTSSMPF -> UTSSMPF, List F) -> UTSF

    Implementation == add

)if false

[[coeffs]] is the stream of coefficients of the solution.  We store in [[st.2]]
the stream of all coefficients, and in [[st.1]] the stream starting with the
first coefficient that has possibly not yet been computed.

Consider an arbitrary equation $f\big(x, y(x)\big)=0$. When setting $x = 0$, we
obtain $f\big(0, y(0)\big)=0$. It is not necessarily the case that this
determines $y(0)$ uniquely, so we need one initial value that satisfies this
equation.
\begin{ToDo}
  [[seriesSolve]] should check that the given initial values satisfy $f\big(0, y(0),
  y'(0), ...\big) = 0$.
\end{ToDo}
Now consider the derivatives of $f$, where we write $y$ instead of $y(x)$ for
better readability:
\begin{equation*}
  \frac{d}{dx}f(x, y)=f_1(x, y) + f_2(x, y)y^\prime
\end{equation*}
and
\begin{align*}
  \frac{d^2}{dx^2}f(x, y)&=f_{1, 1}(x, y)\\
                         &+f_{1, 2}(x, y)y^\prime\\
                         &+f_{2, 1}(x, y)y^\prime\\
                         &+f_{2, 2}(x, y)(y^\prime)^2\\
                         &+f_2(x, y)y^{\prime\prime}.
\end{align*}
In general, $\frac{d^2}{dx^2}f(x, y)$ depends only linearly on
$y^{\prime\prime}$.

\begin{ToDo}
  This points to another possibility : Since we know that we only need to solve
  linear equations, we could compute two values and then use interpolation.
  This might be a bit slower, but more importantly : can we still check that we
  have enough initial values? Furthermore, we then really need that $f$ is
  analytic, i.e., operators are not necessarily allowed anymore. However, it
  seems that composition is allowed.
\end{ToDo}

)endif

        seriesSolve(f, l) ==
            l1 := [e::SMPF for e in l]::Stream SMPF
            s1 : Stream Integer := stream(inc, 0)$Stream(Integer)
            l2 := map(i +-> monomial(1, monomial(1, i::NNI)
                                                $IndexedExponents(NNI))
                            $SMPF, s1)$StreamFunctions2(Integer, SMPF)

            coeffs : Stream SMPF := concat(l1, l2)
            st : List Stream SMPF := [coeffs, coeffs]

            next : () -> F :=
                nr : Stream SMPF := st.1
                res : F

                if ground?(coeff : SMPF := first nr)$SMPF then
-- If the next element was already calculated, we can simply return it:

                    res := ground coeff
                    st.1 := rest nr
                else

-- Otherwise, we have to find the first non-satisfied relation and solve it.  It
-- should be linear, or a single non-constant monomial. That is, the solution
-- should be unique.
                    eqs : Stream SMPF := coefficients f series(st.2)
                    eq : SMPF
                    while zero?(eq := first eqs) repeat eqs := rest eqs

                    vars := variables eq
                    if not member?(retract(coeff)@NNI, vars) then
                        output("The variable is:",
                                       coeff::OutputForm)$OutputPackage
                        output("The next equations are:",
                                       (st.2)::OutputForm)$OutputPackage

                        if empty? vars then
                            error "seriesSolve: there is no solution with"
                                  " the given initial values"
                        else
                            error "seriesSolve: coefficient does not appear"
                                  " in equation"

                    if not one?(# vars) or degree(eq, first vars) > 1 then
                        if monomial? eq then
                            for var in vars repeat
                                i : Integer := 1
                                while ground?(nr.i) or
                                      (retract(nr.i)@NNI ~= var) repeat
                                    i := i+1
                                nr.i := 0
                            st.1 := rest nr
                            res := 0
                        else
                            output("The variable is:",
                                           coeff::OutputForm)$OutputPackage
                            output("The equation is:",
                                           eq::OutputForm)$OutputPackage
                            error "seriesSolve: coefficient not uniquely"
                                  " determined"
                    else
                        res := (-coefficient(eq,
                                             monomial(0$NNI, first vars
                                                     )$IndexedExponents(NNI)
                                            )$(SMPF)
                                 /coefficient(eq,
                                              monomial(1$NNI, first vars
                                                      )$IndexedExponents(NNI)
                                             )$(SMPF))

                        nr.1 := res::SMPF
                        st.1 := rest nr

                res

            series stream next


)if false

\section{package EXPRSOL ExpressionSolve}

\begin{ToDo}
  I'd really like to be able to specify a function that works for all domains
  in a category. For example, [[x +-> y(x)^2 + sin x + x]] should \lq work\rq\
  for [[EXPR INT]] as well as for [[UTS INT]], both being domains having
  [[TranscendentalFunctionCategory]].
\end{ToDo}
)endif

