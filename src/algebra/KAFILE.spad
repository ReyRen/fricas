)abbrev domain KAFILE KeyedAccessFile
++ Author: Stephen M. Watt
++ Date Created: 1985
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
++  This domain allows a random access file to be viewed both as a table
++  and as a file object.


KeyedAccessFile(Entry) : KAFcategory == KAFcapsule where
    Name  ==> FileName
    Key   ==> String
    Entry :   SetCategory

    KAFcategory ==
        Join(FileCategory(Name, Record(key : Key, entry : Entry)),
             TableAggregate(Key, Entry), finiteAggregate) with
                 pack! : % -> %
                     ++ pack!(f) reorganizes the file f on disk to recover
                     ++ unused space.

    KAFcapsule == add

        FileState ==> SExpression
        IOMode    ==> String


        Cons := Record(car : SExpression, cdr : SExpression)
        Rep := Record(fileName :    Name,     _
                      fileState :   FileState,   _
                      fileIOmode :  IOMode)

        defstream(fn : Name, mode : IOMode) : FileState ==
            mode = "input"  =>
                rMkIstream(fn::String)$Lisp
            mode = "output" =>
                rMkOstream(fn::String)$Lisp
            error ["IO mode must be input or output", mode]

        ---- From Set ----
        f1 = f2 ==
            f1.fileName = f2.fileName
        coerce(f : %) : OutputForm ==
            f.fileName::OutputForm

        ---- From FileCategory ----
        open fname ==
            open(fname, "either")
        open(fname, mode) ==
            mode = "either" =>
                exists? fname =>
                    open(fname, "input")
                reopen!(open(fname, "output"), "input")
            [fname, defstream(fname, mode), mode]
        reopen!(f, mode) ==
            close! f
            if mode ~= "closed" then
                f.fileState := defstream(f.fileName, mode)
                f.fileIOmode  := mode
            f
        close! f  ==
            if f.fileIOmode ~= "closed" then
                RSHUT(f.fileState)$Lisp
                f.fileIOmode  := "closed"
            f
        read! f ==
            f.fileIOmode ~= "input" => error ["File not in read state",f]
            ks : List Symbol := RKEYIDS(f.fileName)$Lisp
            empty?(ks) => error ["Attempt to read empty file", f]
            ix := random(#ks)$Integer
            k : String := PNAME(ks.ix)$Lisp
            [k, SPADRREAD(k, f.fileState)$Lisp]
        write!(f, pr) ==
            f.fileIOmode ~= "output" => error ["File not in write state",f]
            SPADRWRITE(pr.key, pr.entry, f.fileState)$Lisp
            pr
        name f ==
            f.fileName
        iomode f ==
            f.fileIOmode

        ---- From TableAggregate ----
        empty() ==
            fn := new("", "kaf", "sdata")$Name
            open fn
        keys f ==
            close! f
            l : List SExpression := RKEYIDS(f.fileName)$Lisp
            [PNAME(n)$Lisp for n in l]
        # f ==
            # keys f
        elt(f, k) ==
            reopen!(f, "input")
            SPADRREAD(k, f.fileState)$Lisp
        setelt!(f, k, e) ==
            -- Leaves f in a safe, closed state.  For speed use "write".
            reopen!(f, "output")
            UNWIND_-PROTECT(write!(f, [k, e]), close! f)$Lisp
            close! f
            e
        search(k, f) ==
            not member?(k, keys f) => "failed"   -- can't trap RREAD error
            reopen!(f, "input")
            (SPADRREAD(k, f.fileState)$Lisp)@Entry
        remove!(k : String, f : %)  ==
            result := search(k, f)
            result case "failed" => result
            close! f
            RDROPITEMS(NAMESTRING(f.fileName)$Lisp, LIST(k)$Lisp)$Lisp
            result
        pack! f ==
            close! f
            f

