)abbrev category LNAGG LinearAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A linear aggregate is an aggregate whose elements are indexed by integers.
++ Examples of linear aggregates are strings, lists, and arrays.
++ Most of the exported operations for linear aggregates are non-destructive
++ but are not always efficient for a particular aggregate.
++ For example, \spadfun{concat} of two lists needs only to copy its first
++ argument, whereas \spadfun{concat} of two arrays needs to copy both arguments.
++ Most of the operations exported here apply to infinite objects (e.g. streams)
++ as well to finite ones.
++ If the aggregate is a finite aggregate then it has several additional
++ exports such as
++ \spadfun{reverse}, \spadfun{sort}, and so on.
LinearAggregate(S : Type) : Category ==
  Join(IndexedAggregate(Integer, S), Collection(S),
       Eltable(UniversalSegment Integer, %)) with
   new : (NonNegativeInteger, S) -> %
     ++ new(n, x) returns a new aggregate of size n all of whose
     ++ entries are x.
   concat : (%, S) -> %
     ++ concat(u, x) returns aggregate u with additional element x at the end.
     ++ Note: for lists, \spad{concat(u, x) = concat(u, [x])}.
   concat : (S, %) -> %
     ++ concat(x, u) returns aggregate u with additional element x at the front.
     ++ Note: for lists: \spad{concat(x, u) = concat([x], u)}.
   concat : (%, %) -> %
      ++ concat(u, v) returns an aggregate consisting of the elements of u
      ++ followed by the elements of v.
      ++ Note: if \spad{w = concat(u, v)} then
      ++ \spad{w.i = u.i for i in indices u}
      ++ and \spad{w.(j + maxIndex u) = v.j for j in indices v}.
   concat : List % -> %
      ++ concat(u), where u is a list of aggregates \spad{[a, b, ..., c]},
      ++ returns a single aggregate consisting of the elements of \spad{a}
      ++ followed by those
      ++ of b followed ... by the elements of c.
      ++ Note: \spad{concat([a, b, ..., c]) = concat(a, concat([b, ..., c]))}.
   map : ((S, S) -> S, %, %) -> %
     ++ map(f, u, v) returns a new aggregate w with elements
     ++ \spad{z = f(x, y)} for corresponding elements x and y from u and v.
     ++ Note: \spad{w.i = f(u.i, v.i)}.
   delete : (%, Integer) -> %
      ++ delete(u, i) returns a copy of u with the \spad{i}th element deleted.
      ++ Note:
      ++ \spad{delete(u, i) = concat(u(minIndex(u)..i - 1), u(i + 1..))}.
   delete : (%, UniversalSegment(Integer)) -> %
      ++ delete(u, i..j) returns a copy of u with the \spad{i}th through
      ++ \spad{j}th element deleted.
      ++ Note: \spad{delete(u, i..j) = concat(u(minIndex(u)..i-1), u(j+1..))}.
   first : (%, NonNegativeInteger) -> %
      ++ first(u, n) returns a copy of the first n
      ++ elements of u.  Error: if u has less than n elements.
   insert : (S, %, Integer) -> %
      ++ insert(x, u, i) returns a copy of u having x as its \spad{i}th
      ++ element.
      ++ Note:
      ++ \spad{insert(x, u, i) = concat(u(minIndex(u)..i-1), concat(x, u(i..)))}.
   insert : (%, %, Integer) -> %
      ++ insert(v, u, i) returns a copy of u having v inserted beginning at the
      ++ \spad{i}th element.
      ++ Note:
      ++ \spad{insert(v, u, i) = concat(u(minIndex(u)..i-1), concat(v, u(i..)))}.
   if % has shallowlyMutable then
      setelt! : (%, UniversalSegment(Integer), S) -> S
       ++ setelt!(u, i..j, x) (also written: \spad{u(i..j) := x}) destructively
       ++ replaces each element in the segment \spad{u(i..j)} by x.
       ++ The value x is returned.
       ++ Note: u is destructively changed so
       ++ that \spad{u.k := x for k in i..j};
       ++ its length remains unchanged.
   if % has finiteAggregate then
      merge : ((S, S) -> Boolean, %, %) -> %
       ++ merge(p, a, b) returns an aggregate c which merges \spad{a} and b.
       ++ The result is produced by examining each element x of \spad{a} and y
       ++ of b successively. If \spad{p(x, y)} is true, then x is inserted into
       ++ the result; otherwise y is inserted. If x is chosen, the next element
       ++ of \spad{a} is examined, and so on. When all the elements of one
       ++ aggregate are examined, the remaining elements of the other
       ++ are appended.
       ++ For example, \spad{merge(<, [1, 3], [2, 7, 5])} returns
       ++ \spad{[1, 2, 3, 7, 5]}.
      reverse : % -> %
       ++ reverse(a) returns a copy of \spad{a} with elements in reverse order.
      sort : ((S, S) -> Boolean, %) -> %
       ++ sort(p, a) returns a copy of \spad{a} sorted using total ordering
       ++ predicate p.
      sorted? : ((S, S) -> Boolean, %) -> Boolean
       ++ sorted?(p, a) tests if \spad{a} is sorted according to predicate p.
      position : (S -> Boolean, %) -> Integer
       ++ position(p, a) returns the index i of the first x in \spad{a}
       ++ such that \spad{p(x)} is true, and \spad{minIndex(a) - 1} if
       ++ there is no such x.
      if S has BasicType then
         position : (S, %) -> Integer
          ++ position(x, a) returns the index i of the first occurrence
          ++ of x in a, and \spad{minIndex(a) - 1} if there is no such x.
         position : (S, %, Integer) -> Integer
          ++ position(x, a, n) returns the index i of the first occurrence
          ++ of x in \spad{a} where \spad{i >= n}, and \spad{minIndex(a) - 1}
          ++ if no such x is found.
         leftTrim : (%, S) -> %
          ++ leftTrim(u, x) returns a copy of u with all leading x deleted.
          ++ For example, \spad{leftTrim("  abc  ", char " ")} returns
          ++ \spad{"abc  "}.
         rightTrim : (%, S) -> %
          ++ rightTrim(u, x) returns a copy of u with all trailing occurrences
          ++ of x deleted.  For example, \spad{rightTrim("  abc  ", char " ")}
          ++ returns \spad{"  abc"}.
         trim : (%, S) -> %
          ++ trim(u, x) returns a copy of u with all occurrences of x deleted
          ++ from right and left ends.
          ++ For example, \spad{trim(" abc ", char " ")} returns \spad{"abc"}.
      if S has Comparable then Comparable
      if S has OrderedSet then
         OrderedSet
         merge : (%, %) -> %
          ++ merge(u, v) merges u and v in ascending order.
          ++ Note: \spad{merge(u, v) = merge(<=, u, v)}.
         sort : % -> %
          ++ sort(u) returns an u with elements in ascending order.
          ++ Note: \spad{sort(u) = sort(<=, u)}.
         sorted? : % -> Boolean
          ++ sorted?(u) tests if the elements of u are in ascending order.
      if % has shallowlyMutable then
         copyInto! : (%, %, Integer) -> %
          ++ copyInto!(u, v, i) returns aggregate u containing a copy of
          ++ v inserted at element i.
         reverse! : % -> %
          ++ reverse!(u) returns u with its elements in reverse order.
         sort! : ((S, S) -> Boolean, %) -> %
          ++ sort!(p, u) returns u with its elements ordered by p.
         if S has OrderedSet then sort! : % -> %
          ++ sort!(u) returns u with its elements in ascending order.
 add
  indices a      == [i for i in minIndex a .. maxIndex a]
  index?(i, a)   == i >= minIndex a and i <= maxIndex a
  concat(a : %, x : S)      == concat(a, new(1, x))
  concat(x : S, y : %)      == concat(new(1, x), y)
  insert(x : S, a : %, i : Integer) == insert(new(1, x), a, i)
  first(x, n) == x(minIndex(x)+(0..(n-1)))

  if % has finiteAggregate then

    maxIndex l == #l - 1 + minIndex l

    if S has BasicType then
        position(x : S, t : %) == position(x, t, minIndex t)

        leftTrim(u, x) ==
            n := maxIndex u
            for i in minIndex u .. n while u.i = x repeat 0
            u(i..n)

        rightTrim(u, x) ==
            mn := minIndex u
            for j in maxIndex u .. mn by -1 while u.j = x repeat 0
            u(mn..j)

        trim(u, x) ==
            n := maxIndex u
            mn := minIndex u
            for i in mn .. n while u.i = x repeat 0
            for j in n .. i by -1 while u.j = x repeat 0
            u(i..j)

    if S has SetCategory then
        hashUpdate!(s : HashState, x : %) : HashState ==
            for i in minIndex x..maxIndex x repeat
                s := hashUpdate!(s, qelt(x, i))$S
            s

    if S has OrderedSet then
        sorted? l   == sorted?(_<_=$S, l)
        merge(x, y) == merge(_<$S, x, y)
        sort l      == sort(_<$S, l)

    if % has shallowlyMutable then
        reverse x  == reverse! copy x
        sort(f, l) == sort!(f, copy l)

        if S has OrderedSet then
            sort! l == sort!(_<$S, l)

