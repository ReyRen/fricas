)abbrev package ELIPIDF DoubleFloatEllipticIntegrals
)boot $tryRecompileArguments := nil
++ Description:
++  \spad{DoubleFloatEllipticIntegrals} implements machine
++  A package for computing machine precision real and
++  complex elliptic integrals, using algorithms given by Carlson.
++  Note: Complex versions may misbehave for very large/small
++  arguments and close to branch cuts.
++ References:
++   B.C. Carlson, Numerical computation of real or complex
++   elliptic integrals, Numerical Algorithms 10 (1995) 13-26.

DoubleFloatEllipticIntegrals : Exports == Implementation where
  RF ==> DoubleFloat
  CF ==> Complex(DoubleFloat)

  Exports ==> with
      ellipticRC : (RF, RF) -> RF
        ++ ellipticRC(x, y) computes integral from 0 to infinity of
        ++ \spad{(1/2)*(t+x)^(-1/2)*(t+y)^(-1)dt}.
      ellipticRD : (RF, RF, RF) -> RF
        ++ ellipticRD(x, y, z) computes integral from 0 to infinity of
        ++ \spad{(3/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-3/2)dt}.
      ellipticRF : (RF, RF, RF) -> RF
        ++ ellipticRF(x, y, z) computes integral from 0 to infinity of
        ++ \spad{(1/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-1/2)dt}.
      ellipticRJ : (RF, RF, RF, RF) -> RF
        ++ ellipticRJ(x, y, z, p) computes integral from 0 to infinity of
        ++ \spad{(3/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-1/2)*(t+p)^(-1)dt}.
      ellipticF : (RF, RF) -> RF
        ++ ellipticF(z, m) is the incomplete elliptic integral of the
        ++ first kind.
      ellipticK : RF -> RF
        ++ ellipticK(z, m) is the complete elliptic integral of the
        ++ first kind.
      ellipticE : (RF, RF) -> RF
        ++ ellipticE(z, m) is the incomplete elliptic integral of the
        ++ second kind.
      ellipticE : RF -> RF
        ++ ellipticE(m) is the complete elliptic integral of the
        ++ second kind
      ellipticPi : (RF, RF, RF) -> RF
        ++ ellipticPi(z, n, m) is the incomplete elliptic integral of the
        ++ third kind.
      ellipticRC : (CF, CF) -> CF
        ++ ellipticRC(x, y) computes integral from 0 to infinity of
        ++ \spad{(1/2)*(t+x)^(-1/2)*(t+y)^(-1)dt}.
      ellipticRD : (CF, CF, CF) -> CF
        ++ ellipticRD(x, y, z) computes integral from 0 to infinity of
        ++ \spad{(3/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-3/2)dt}.
      ellipticRF : (CF, CF, CF) -> CF
        ++ ellipticRF(x, y, z) computes integral from 0 to infinity of
        ++ \spad{(1/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-1/2)dt}.
      ellipticRJ : (CF, CF, CF, CF) -> CF
        ++ ellipticRF(x, y, z, p) computes integral from 0 to infinity of
        ++ \spad{(3/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-1/2)*(t+p)^(-1)dt}.
      ellipticF : (CF, CF) -> CF
        ++ ellipticF(z, m) is the incomplete elliptic integral of the
        ++ first kind.
      ellipticK : CF -> CF
        ++ ellipticK(z, m) is the incomplete elliptic integral of the
        ++ first kind.
      ellipticE : (CF, CF) -> CF
        ++ ellipticE(z, m) is the incomplete elliptic integral of the
        ++ second kind.
      ellipticE : CF -> CF
        ++ ellipticE(m) is the complete elliptic integral of the
        ++ second kind
      ellipticPi : (CF, CF, CF) -> CF
        ++ ellipticPi(z, n, m) is the incomplete elliptic integral of the
        ++ third kind.

  Implementation ==> add

      half : RF := 1/2::RF
      one_third : RF := 1/3::RF
      one_fourth : RF := 1/4::RF
      one_fifth : RF := 1/5::RF

      c2_RC : RF := 3::RF/10::RF
      c3_RC : RF := 1/7::RF
      c4_RC : RF := 3::RF/8::RF
      c5_RC : RF := 9::RF/22::RF
      c6_RC : RF := 159::RF/208::RF
      c7_RC : RF := 9::RF/8::RF
      inv_err_RC := 94::RF -- roughly (3*2.0^-54)^(-1/8)

      c1_RF : RF := 1/24::RF
      c2_RF : RF := 1/10::RF
      c3_RF : RF := 3::RF/44::RF
      c4_RF : RF := 1/14::RF
      inv_err_RF := 427::RF -- roughly (3*2.0^-54)^(-1/6)

      c1_RD := -3::RF/14::RF
      c2_RD := 1/6::RF
      c3_RD := 9::RF/22::RF
      c4_RD := 3::RF/26::RF
      c5_RD := 3::RF/2::RF
      inv_err_RJ := 646::RF -- roughly (2.0^-54/4)^(-1/6)

      c1_RJ : RF := 3::RF/14::RF
      c3_RJ : RF := 3::RF/22::RF
      c4_RJ : RF := 3::RF/26::RF
      c5_RJ : RF := 9::RF/88::RF
      c6_RJ : RF := 9::RF/52::RF

      Funs ==>
          ellipticRC(x : DF, y : DF) : DF ==
              mu := one_third*(x + y + y)
              Q := inv_err_RC*rabs(mu - x)
              repeat
                  Q < rabs(mu) =>
                      mu_inv := 1/mu
                      sn := mu_inv*(y - mu)
                      sn2 := sn*sn
                      S1 := c3_RC::DF + sn2*(c5_RC::DF + sn2*c7_RC::DF)
                      S0 := c2_RC::DF + sn2*(c4_RC::DF + sn2*c6_RC::DF)
                      return qsqrt(mu_inv)*(1 + sn2*(S0 + sn*S1))
                  lambda := (2::DF)*qsqrt(x)*qsqrt(y) + y
                  x := one_fourth*(x + lambda)
                  y := one_fourth*(y + lambda)
                  mu := one_fourth*(mu + lambda)
                  Q := one_fourth*Q

          ellipticRF(x : DF, y : DF, z : DF) : DF ==
              mu := one_third*(x + y + z)
              xadev := rabs(mu - x)
              yadev := rabs(mu - y)
              zadev := rabs(mu - z)
              Q := inv_err_RF*max(xadev, max(yadev, zadev))
              repeat
                  Q < rabs(mu) =>
                      mu_inv := 1/mu
                      xndev := (mu - x)*mu_inv
                      yndev := (mu - y)*mu_inv
                      zndev := (mu - z)*mu_inv
                      e2 := xndev*yndev - zndev*zndev
                      e3 := xndev*yndev*zndev
                      s := 1 + (c1_RF*e2 - c2_RF::DF - c3_RC*e3)*e2 + c4_RF*e3
                      return s*qsqrt(mu_inv)
                  xnroot := qsqrt(x)
                  ynroot := qsqrt(y)
                  znroot := qsqrt(z)
                  lambda := xnroot*(ynroot + znroot) + ynroot*znroot
                  x := one_fourth*(x + lambda)
                  y := one_fourth*(y + lambda)
                  z := one_fourth*(z + lambda)
                  mu := one_fourth*(mu + lambda)
                  Q := one_fourth*Q

          ellipticRD(x : DF, y : DF, z : DF) : DF ==
              sigma : DF := 0
              power4 : DF := 1
              mu := one_fifth*(x + y + 3::DF*z)
              xadev := rabs(mu - x)
              yadev := rabs(mu - y)
              zadev := rabs(mu - z)
              Q := inv_err_RJ*max(xadev, max(yadev, zadev))
              repeat
                  Q < rabs(mu) =>
                      mu_inv := 1/mu
                      xndev := (mu - x)*mu_inv
                      yndev := (mu - y)*mu_inv
                      zndev := (mu - z)*mu_inv
                      ea := xndev*yndev
                      eb := zndev*zndev
                      ec := ea - eb
                      ed := ea - 6::RF*eb
                      ef := ed + ec + ec
                      s1 := ed*(c1_RD::DF + one_fourth*c3_RD*ed
                                - c5_RD*c4_RD*zndev*ef)
                      s2 := zndev*(c2_RD*ef + zndev*(-c3_RD*ec
                               + zndev*c4_RD*ea))
                      ss := (1 + (s1 + s2))*mu_inv*qsqrt(mu_inv)
                      return 3::RF*sigma + power4*ss
                  xnroot := qsqrt(x)
                  ynroot := qsqrt(y)
                  znroot := qsqrt(z)
                  lambda := xnroot*(ynroot + znroot) + ynroot*znroot
                  sigma := sigma + power4/(znroot*(z + lambda))
                  power4 := one_fourth*power4
                  x := one_fourth*(x + lambda)
                  y := one_fourth*(y + lambda)
                  z := one_fourth*(z + lambda)
                  mu := one_fourth*(mu + lambda)
                  Q := one_fourth*Q

          ellipticRJ(x : DF, y : DF, z : DF, p : DF) : DF ==
              sigma : DF := 0
              power4 : DF := 1
              mu := one_fifth*(x + y + z + p + p)
              xadev := rabs(mu - x)
              yadev := rabs(mu - y)
              zadev := rabs(mu - z)
              padev := rabs(mu - p)
              Q := inv_err_RJ*max(max(xadev, yadev), max(zadev, padev))
              repeat
                  Q < rabs(mu) =>
                      mu_inv := 1/mu
                      xndev := (mu - x)*mu_inv
                      yndev := (mu - y)*mu_inv
                      zndev := (mu - z)*mu_inv
                      pndev := (mu - p)*mu_inv
                      ea := xndev*(yndev + zndev) + yndev*zndev
                      eb := xndev*yndev*zndev
                      ec := pndev*pndev
                      e2 := ea - 3::RF*ec
                      e3 := eb + 2::RF*pndev*(ea - ec)
                      s1 := e2*(-c1_RJ::DF + c5_RJ*e2 - c6_RJ*e3)
                      s2 := eb*(half*one_third::DF +
                                pndev*(-(c3_RJ + c3_RJ)::DF + pndev*c4_RJ))
                      s3 := pndev*ea*(one_third::DF - pndev*c3_RJ)
                            - one_third*pndev*ec
                      ss := (1 + (s1 + s2 + s3))*mu_inv*qsqrt(mu_inv)
                      return 3::RF*sigma + power4*ss
                  xnroot := qsqrt(x)
                  ynroot := qsqrt(y)
                  znroot := qsqrt(z)
                  lambda := xnroot*(ynroot + znroot) + ynroot*znroot
                  alfa := p*(xnroot + ynroot + znroot) + xnroot*ynroot*znroot
                  alfa := alfa*alfa
                  beta := p*(p + lambda)*(p + lambda)
                  sigma := sigma + power4*ellipticRC(alfa, beta)
                  power4 := one_fourth*power4
                  x := one_fourth*(x + lambda)
                  y := one_fourth*(y + lambda)
                  z := one_fourth*(z + lambda)
                  p := one_fourth*(p + lambda)
                  mu := one_fourth*(mu + lambda)
                  Q := one_fourth*Q

          ellipticF(z : DF, m : DF) : DF ==
              z*ellipticRF(1 - z*z, 1 - m*z*z, 1)

          ellipticK(m : DF) : DF ==
              ellipticRF(0, 1 - m, 1)

          ellipticE(z : DF, m : DF) : DF ==
              z*ellipticRF(1 - z*z, 1 - m*z*z, 1) - (m/3::DF)*
                 z*z*z*ellipticRD(1 - z*z, 1 - m*z*z, 1)

          ellipticE(m : DF) : DF ==
              ellipticRF(0, 1 - m, 1) - (m/3::DF)*ellipticRD(0, 1 - m, 1)

          ellipticPi(z : DF, n : DF, m : DF) : DF ==
              z*ellipticRF(1 - z*z, 1 - m*z*z, 1) + (n/3::DF)*
                z*z*z*ellipticRJ(1 - z*z, 1 - m*z*z, 1, 1 - n*z*z)

      rabs(x : Complex(DoubleFloat)) : DoubleFloat == real(abs(x))

      Funs where
          DF ==> RF
          rabs ==> abs

      Funs where
          DF ==> CF
          qsqrt ==> sqrt
)boot $tryRecompileArguments := true

