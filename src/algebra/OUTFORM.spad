)abbrev domain OUTFORM OutputForm
++ Keywords: output, I/O, expression
++ SMW March/88
++ Description:
++ This domain is used to create and manipulate mathematical expressions
++ for output.  It is intended to provide an insulating layer between
++ the expression rendering software (e.g.FORTRAN, TeX, or Script) and
++ the output coercions in the various domains.

OutputForm() : SetCategory with
        --% Printing
        print  : % -> Void
          ++ print(u) prints the form u.
        message : String -> %
          ++ message(s) creates an form with no string quotes
          ++ from string s.
        messagePrint : String -> Void
          ++ messagePrint(s) prints s without string quotes. Note:
          ++ \spad{messagePrint(s)} is equivalent to \spad{print message(s)}.
        --% Creation of atomic forms
        outputForm : Integer -> %
          ++ outputForm(n) creates an form for integer n.
        outputForm : Symbol  -> %
          ++ outputForm(s) creates an form for symbol s.
        outputForm : String  -> %
          ++ outputForm(s) creates an form for string s.
        empty   : () -> %
          ++ empty() creates an empty form.

         --% Space manipulations
        hspace : Integer -> %  ++ hspace(n) creates white space of width n.
        vspace : Integer -> %  ++ vspace(n) creates white space of height n.
        rspace : (Integer, Integer) -> %
          ++ rspace(n, m) creates rectangular white space, n wide by m high.
        --% Area adjustments
        left : (%, Integer) -> %
          ++ left(f, n) left-justifies form f within space of width n.
        right : (%, Integer) -> %
          ++ right(f, n) right-justifies form f within space of width n.
        center : (%, Integer) -> %
          ++ center(f, n) centers form f within space of width n.
        left : % -> %
          ++ left(f) left-justifies form f in total space.
        right : % -> %
          ++ right(f) right-justifies form f in total space.
        center :   % -> %
          ++ center(f) centers form f in total space.

        --% Area manipulations
        hconcat :  (%, %) -> %
          ++ hconcat(f, g) horizontally concatenate forms f and g.
        vconcat :  (%, %) -> %
          ++ vconcat(f, g) vertically concatenates forms f and g.
        hconcat :  List % -> %
          ++ hconcat(u) horizontally concatenates all forms in list u.
        vconcat :  List % -> %
          ++ vconcat(u) vertically concatenates all forms in list u.

        --% Application formers
        prefix :  (%, List %) -> %
          ++ prefix(f, l) creates a form depicting the n-ary prefix
          ++ application of f to a tuple of arguments given by list l.
        infix :   (%, List %) -> %
          ++ infix(f, l) creates a form depicting the n-ary application
          ++ of infix operation f to a tuple of arguments l.
        infix :   (%, %, %) -> %
          ++ infix(op, a, b) creates a form which prints as: a op b.
        postfix : (%, %)    -> %
          ++ postfix(op, a)  creates a form which prints as: a op.
        infix? : % -> Boolean
          ++ infix?(op) returns true if op is an infix operator,
          ++ and false otherwise.
        elt :     (%, List %) -> %
          ++ elt(op, l) creates a form for application of op
          ++ to list of arguments l.

        --% Special forms
        label :   (%, %) -> %
          ++ label(n, f) gives form f an equation label n.
        box :     % -> %
          ++ box(f) encloses f in a box.
        matrix :  List List % -> %
          ++ matrix(llf) makes llf (a list of lists of forms) into
          ++ a form which displays as a matrix.
        zag :     (%, %) -> %
          ++ zag(f, g) creates a form for the continued fraction form for f over g.
        root :    % -> %
          ++ root(f) creates a form for the square root of form f.
        root :    (%, %) -> %
          ++ root(f, n) creates a form for the nth root of form f.
        over :    (%, %) -> %
          ++ over(f, g) creates a form for the vertical fraction of f over g.
        slash :   (%, %) -> %
          ++ slash(f, g) creates a form for the horizontal fraction of f over g.
        assign :  (%, %) -> %
          ++ assign(f, g) creates a form for the assignment \spad{f := g}.
        rarrow :  (%, %) -> %
          ++ rarrow(f, g) creates a form for the mapping \spad{f -> g}.
        differentiate : (%, NonNegativeInteger) -> %
          ++ differentiate(f, n) creates a form for the nth derivative of f,
          ++ e.g. \spad{f'}, \spad{f''}, \spad{f'''},
          ++ "f super \spad{iv}".
        binomial : (%, %) -> %
          ++ binomial(n, m) creates a form for the binomial coefficient of n and m.
        tensor :  (%, %) -> %
          ++ tensor(a, b) creates a form for a tensor b

        --% Scripts
        sub :     (%, %) -> %
          ++ sub(f, n) creates a form for f subscripted by n.
        super :   (%, %) -> %
          ++ super(f, n) creates a form for f superscripted by n.
        presub :  (%, %) -> %
          ++ presub(f, n) creates a form for f presubscripted by n.
        presuper : (%, %) -> %
          ++ presuper(f, n) creates a form for f presuperscripted by n.
        scripts : (%, List %) -> %
          ++ \spad{scripts(f, l)} where l is
          ++ \spad{[sub, super, presuper, presub]} creates a form
          ++ for f with scripts on all 4 corners.  If l has less
          ++ than 4 elements corresponding scripts are absent.
        supersub : (%, List %) -> %
            ++ supersub(a, [sub1, super1, sub2, super2, ...])
            ++ creates a form with each subscript aligned
            ++ under each superscript.

        --% Diacritical marks
        quote :   % -> %
          ++ quote(f) creates the form f with a prefix quote.
        dot :     % -> %
          ++ dot(f) creates the form with one dot overhead.
        dot :     (%, NonNegativeInteger) -> %
          ++ dot(f, n) creates the form f with n dots overhead.
        prime :   % -> %
          ++ prime(f) creates the form f followed by a suffix prime (single quote).
        prime :   (%, NonNegativeInteger) -> %
          ++ prime(f, n) creates the form f followed by n primes.
        overbar : % -> %
          ++ overbar(f) creates the form f with an overbar.
        overlabel : (%, %) -> %
          ++ overlabel(x,f) creates the form f with "x overbar" over the top.

        --% Plexes
        sum :     (%)       -> %
          ++ sum(expr) creates the form prefixing expr by a capital sigma.
        sum :     (%, %)    -> %
          ++ sum(expr, lowerlimit) creates the form prefixing expr by
          ++ a capital sigma with a lowerlimit.
        sum :     (%, %, %) -> %
          ++ sum(expr, lowerlimit, upperlimit) creates the form prefixing expr by
          ++ a capital sigma with both a lowerlimit and upperlimit.
        prod :    (%)       -> %
          ++ prod(expr) creates the form prefixing expr by a capital pi.
        prod :    (%, %)    -> %
          ++ prod(expr, lowerlimit) creates the form prefixing expr by
          ++ a capital pi with a lowerlimit.
        prod :    (%, %, %) -> %
          ++ prod(expr, lowerlimit, upperlimit) creates the form prefixing expr by
          ++ a capital pi with both a lowerlimit and upperlimit.
        int :     (%)       -> %
          ++ int(expr) creates the form prefixing expr with an integral sign.
        int :     (%, %)    -> %
          ++ int(expr, lowerlimit) creates the form prefixing expr by an
          ++ integral sign with a lowerlimit.
        int :     (%, %, %) -> %
          ++ int(expr, lowerlimit, upperlimit) creates the form prefixing expr by
          ++ an integral sign with both a lowerlimit and upperlimit.

        --% Matchfix forms
        brace :   % -> %
          ++ brace(f) creates the form enclosing f in braces (curly brackets).
        brace :   List % -> %
          ++ brace(lf) creates the form separating the elements of lf
          ++ by commas and encloses the result in curly brackets.
        bracket : % -> %
          ++ bracket(f) creates the form enclosing f in square brackets.
        bracket : List % -> %
          ++ bracket(lf) creates the form separating the elements of lf
          ++ by commas and encloses the result in square brackets.
        paren :   % -> %
          ++ paren(f) creates the form enclosing f in parentheses.
        paren :   List % -> %
          ++ paren(lf) creates the form separating the elements of lf
          ++ by commas and encloses the result in parentheses.

        --% Separators for aggregates
        pile :     List % -> %
          ++ pile(l) creates the form consisting of the elements of l which
          ++ displays as a pile, i.e. the elements begin on a new line and
          ++ are indented right to the same margin.

        commaSeparate : List % -> %
          ++ commaSeparate(l) creates the form separating the elements of l
          ++ by commas.
        semicolonSeparate :  List % -> %
          ++ semicolonSeparate(l) creates the form separating the elements of l
          ++ by semicolons.
        blankSeparate : List % -> %
          ++ blankSeparate(l) creates the form separating the elements of l
          ++ by blanks.
        --% Specific applications
        "=":     (%, %) -> %
          ++ f = g creates the equivalent infix form.
        "~=":    (%, %) -> %
          ++ f ~= g creates the equivalent infix form.
        "<":     (%, %) -> %
          ++ f < g creates the equivalent infix form.
        ">":     (%, %) -> %
          ++ f > g creates the equivalent infix form.
        "<=":    (%, %) -> %
          ++ f <= g creates the equivalent infix form.
        ">=":    (%, %) -> %
          ++ f >= g creates the equivalent infix form.
        "+":     (%, %) -> %
          ++ f + g creates the equivalent infix form.
        "-":     (%, %) -> %
          ++ f - g creates the equivalent infix form.
        "-":     (%)    -> %
          ++ - f creates the equivalent prefix form.
        "*":     (%, %) -> %
          ++ f * g creates the equivalent infix form.
        "/":     (%, %) -> %
          ++ f / g creates the equivalent infix form.
        "^":    (%, %) -> %
          ++ f ^ g creates the equivalent infix form.
        "rem":   (%, %) -> %
          ++ f rem g creates the equivalent infix form.
        "quo":   (%, %) -> %
          ++ f quo g creates the equivalent infix form.
        "exquo": (%, %) -> %
          ++ exquo(f, g) creates the equivalent infix form.
        "and":   (%, %) -> %
          ++ f and g creates the equivalent infix form.
        "or":    (%, %) -> %
          ++ f or g creates the equivalent infix form.
        "not":   (%)    -> %
          ++ not f creates the equivalent prefix form.
        SEGMENT : (%, %)  -> %
          ++ SEGMENT(x, y) creates the infix form: \spad{x..y}.
        SEGMENT : (%)    -> %
          ++ SEGMENT(x) creates the prefix form: \spad{x..}.

    == add
        import from NumberFormats

        -- Todo:
        --   program forms, greek letters
        --   infix, prefix, postfix, matchfix support in OUT BOOT
        --   labove rabove, corresponding overs.
        --   better super script, overmark, undermark
        --   bug in product, paren blankSeparate []
        --   uniformize integrals, products, etc as plexes.

        cons_form(x : %, l : List(%)) : % == cons(x, l)$List(%) pretend %

        Rep := SExpression

        a, b : %
        l : List %
        s : String
        e : Symbol
        n : Integer
        nn : NonNegativeInteger

        sform :    String  -> %
        eform :    Symbol  -> %
        iform :    Integer -> %

        print x              == mathprint(x)$Lisp
        message s            == (empty? s => empty(); s pretend %)
        messagePrint s       == print message s
        (a : % = b : %) : Boolean  == EQUAL(a, b)$Lisp
        (a : % = b : %) : %        == convert [eform '_=,     a, b]
        coerce(a) : OutputForm  == a pretend OutputForm
        outputForm n          == n pretend %
        outputForm e          == e pretend %
        sform s               == s pretend %
        eform e               == e pretend %
        iform n               == n pretend %

        outputForm s ==
          sform concat(quote()$Character, concat(s, quote()$Character))

        width(a : %) : Integer == outformWidth(a)$Lisp
        width0() : Integer == _$LINELENGTH$Lisp

        center(a, w)   == hconcat(hspace((w - width(a)) quo 2), a)
        left(a, w)     == hconcat(a, hspace((w - width(a))))
        right(a, w)    == hconcat(hspace(w - width(a)), a)
        center(a)     == center(a, width0())
        left(a)       == left(a, width0())
        right(a)      == right(a, width0())

        vspace(n) ==
          n = 0 => empty()
          vconcat(sform " ",vspace(n - 1))

        hspace(n) ==
          n = 0 => empty()
          sform(fillerSpaces(n, " ")$Lisp)

        rspace(n, m) ==
          n = 0 or m = 0 => empty()
          vconcat(hspace n, rspace(n, m - 1))

        matrix ll ==
            empty?(ll) => bracket([]$List(%))
            lv : List % := [cons_form(eform 'ROW, l) for l in ll]
            cons_form(eform 'MATRIX, cons(eform 'NIL, lv))

        pile l              == cons_form(eform 'SC, l)
        commaSeparate l     == cons_form(eform 'AGGLST,  l)
        semicolonSeparate l == cons_form(eform 'AGGSET,  l)
        blankSeparate l     ==
           c := eform 'CONCATB
           l1 : List % := []
           for u in reverse l repeat
               uo := u pretend OutputForm
               if has_op?(uo, 'CONCATB)$OutputFormTools then
                   l2 := arguments(uo)$OutputFormTools pretend List(%)
                   l1 := concat(l2, l1)
               else
                   l1 := cons(u, l1)
           cons_form(c, l1)

        brace a        == convert [eform 'BRACE, a]
        brace l        == brace commaSeparate l
        bracket a      == convert [eform 'BRACKET, a]
        bracket l      == bracket commaSeparate l
        paren a        == convert [eform 'PAREN, a]
        paren l        == paren commaSeparate l

        sub(a, b)  == convert [eform 'SUB, a, b]
        super(a, b) == convert [eform 'SUPERSUB, a, sform " ", b]
        presub(a, b) == convert [eform 'SUPERSUB, a, sform " ", sform " ",_
                                  sform " ", b]
        presuper(a, b) == convert [eform 'SUPERSUB, a, sform " ", sform " ", b]
        scripts(a, l) ==
            empty?(l) => a
            empty?(rest(l)) => sub(a, first(l))
            cons_form(eform 'SUPERSUB, cons(a, l))
        supersub(a, l) ==
            if odd?(#l) then l := append(l, [empty()])
            cons_form(eform 'ALTSUPERSUB, cons(a, l))

        hconcat(a, b)  == convert [eform 'CONCAT, a, b]
        hconcat l     == cons_form(eform 'CONCAT, l)
        vconcat(a, b)  == convert [eform 'VCONCAT, a, b]
        vconcat l     == cons_form(eform 'VCONCAT, l)

        (a ~= b) : % == convert [eform '_~_=,    a, b]
        a < b       == convert [eform '_<,     a, b]
        a > b       == convert [eform '_>,     a, b]
        a <= b      == convert [eform '_<_=,    a, b]
        a >= b      == convert [eform '_>_=,    a, b]

        a + b       == convert [eform '_+,     a, b]
        a - b       == convert [eform '_-,     a, b]
        - a         == convert [eform '_-,     a]
        a * b       == convert [eform '_*,     a, b]
        a / b       == convert [eform '_/,     a, b]
        a ^ b       == convert [eform '_^,     a, b]
        a rem b     == convert [eform '_rem,   a, b]
        a quo b     == convert [eform '_quo,   a, b]
        a exquo b   == convert [eform '_exquo, a, b]
        a and b     == convert [eform '_and,   a, b]
        a or b      == convert [eform '_or,    a, b]
        not a       == convert [eform '_not,   a]
        SEGMENT(a, b) == convert [eform 'SEGMENT, a, b]
        SEGMENT(a)  == convert [eform 'SEGMENT, a]
        binomial(a, b) == convert [eform 'BINOMIAL, a, b]

        empty() == convert [eform 'NOTHING]

        infix? a ==
            e : % :=
                IDENTP$Lisp a => a
                STRINGP$Lisp a => INTERN$Lisp a
                return false
            if GET(e, QUOTE(INFIXOP$Lisp)$Lisp)$Lisp then true else false

        elt(a, l) ==
            cons_form(a, l)
        prefix(a, l)   ==
            not infix? a => cons_form(a, l)
            hconcat(a, paren commaSeparate l)
        infix(a, l) ==
            empty?(l) => empty()
            empty?(rest(l)) => first(l)
            infix? a => cons_form(a, l)
            hconcat [first l, a, infix(a, rest l)]
        infix(a, b, c)  ==
            infix? a => convert [a, b, c]
            hconcat [b, a, c]
        postfix(a, b) ==
            hconcat(b, a)

        add_prime(a : %, s : %) : % == convert [eform 'PRIME, a, s]
        quote  a   == convert [eform 'QUOTE,   a]
        overbar a  == convert [eform 'OVERBAR, a]
        dot a      == super(a, sform ".")
        prime a    == prime(a, 1)
        dot(a,nn)   == (s := new(nn, char "."); super(a, sform s))
        prime(a, nn) == (s := new(nn, char ",");  add_prime(a, sform s))

        overlabel(a, b) == convert [eform 'OVERLABEL, a, b]
        box a      == convert [eform 'BOX,     a]
        zag(a, b)  == convert [eform 'ZAG,     a, b]
        root a     == convert [eform 'ROOT,    a]
        root(a, b) == convert [eform 'ROOT,    a, b]
        over(a, b) == convert [eform 'OVER,    a, b]
        slash(a, b) == convert [eform 'SLASH,   a, b]
        assign(a, b) == convert [eform 'LET,     a, b]

        label(a, b) == convert [eform 'EQUATNUM, a, b]
        rarrow(a, b)== convert [eform 'TAG, a, b]
        differentiate(a, nn)==
            zero? nn => a
            nn < 4 => prime(a, nn)
            r := FormatRoman(nn::PositiveInteger)
            s := lowerCase(r::String)
            add_prime(a, paren sform s)

        sum(a)     == convert [eform 'SIGMA,  empty(), a]
        sum(a, b)  == convert [eform 'SIGMA,  b, a]
        sum(a, b, c) == convert [eform 'SIGMA2, b, c, a]
        prod(a)    == convert [eform 'PI,     empty(), a]
        prod(a, b) == convert [eform 'PI,     b, a]
        prod(a, b, c) == convert [eform 'PI2,    b, c, a]
        int(a)     == convert [eform 'INTSIGN, empty(), empty(), a]
        int(a, b)   == convert [eform 'INTSIGN, b, empty(), a]
        int(a, b, c) == convert [eform 'INTSIGN, b, c, a]
        tensor(a, b) == convert [eform 'TENSOR, a, b]


--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
