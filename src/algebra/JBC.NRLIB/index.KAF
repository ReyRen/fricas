16132               (MAKEPROP '|JetBundleCategory| 'NILADIC T)
(|JetBundleCategory|)
|category|
(((|JetBundleCategory|) (|Category|)) (T |JetBundleCategory|))
(|Join| (|OrderedSet|) (|CoercibleTo| (|Expression| (|Integer|)))
        (CATEGORY |domain| (SIGNATURE |setNotation| ((|Symbol|) (|Symbol|)))
         (SIGNATURE |getNotation| ((|Symbol|)))
         (SIGNATURE |multiIndex| ((|List| (|NonNegativeInteger|)) $))
         (SIGNATURE |repeatedIndex| ((|List| (|PositiveInteger|)) $))
         (SIGNATURE |r2m|
          ((|List| (|NonNegativeInteger|)) (|List| (|PositiveInteger|))))
         (SIGNATURE |m2r|
          ((|List| (|PositiveInteger|)) (|List| (|NonNegativeInteger|))))
         (SIGNATURE |allRepeated|
          ((|List| (|List| (|PositiveInteger|)))
           (|List| (|NonNegativeInteger|))))
         (SIGNATURE |index| ((|PositiveInteger|) $))
         (SIGNATURE |type| ((|Symbol|) $)) (SIGNATURE |name| ((|Symbol|) $))
         (SIGNATURE |class|
          ((|NonNegativeInteger|) (|List| (|NonNegativeInteger|))))
         (SIGNATURE |class| ((|NonNegativeInteger|) $))
         (SIGNATURE |order| ((|NonNegativeInteger|) $))
         (SIGNATURE |weight| ((|NonNegativeInteger|) $))
         (SIGNATURE > ((|Boolean|) $ $))
         (SIGNATURE |differentiate| ((|Union| $ "0") $ (|PositiveInteger|)))
         (SIGNATURE |derivativeOf?| ((|List| (|NonNegativeInteger|)) $ $))
         (SIGNATURE |integrateIfCan|
          ((|Union| $ "failed") $ (|PositiveInteger|)))
         (SIGNATURE |integrate| ($ $ (|PositiveInteger|)))
         (SIGNATURE X ($ (|PositiveInteger|)))
         (SIGNATURE U ($ (|PositiveInteger|)))
         (SIGNATURE P ($ (|PositiveInteger|) (|List| (|NonNegativeInteger|))))
         (SIGNATURE |Pm|
          ($ (|PositiveInteger|) (|List| (|NonNegativeInteger|))))
         (SIGNATURE |Pr| ($ (|PositiveInteger|) (|List| (|PositiveInteger|))))
         (SIGNATURE (|One|) ($) |constant|) (SIGNATURE |one?| ((|Boolean|) $))
         (SIGNATURE X ($)) (SIGNATURE U ($))
         (SIGNATURE P ($ (|List| (|NonNegativeInteger|))))
         (SIGNATURE P ($ (|PositiveInteger|) (|NonNegativeInteger|)))
         (SIGNATURE P ($ (|NonNegativeInteger|)))
         (SIGNATURE |variables| ((|List| $) (|NonNegativeInteger|)))
         (SIGNATURE |variables|
          ((|List| $) (|NonNegativeInteger|) (|PositiveInteger|)))
         (SIGNATURE |dimJ| ((|NonNegativeInteger|) (|NonNegativeInteger|)))
         (SIGNATURE |dimS| ((|NonNegativeInteger|) (|NonNegativeInteger|)))
         (SIGNATURE |numIndVar| ((|PositiveInteger|)))
         (SIGNATURE |numDepVar| ((|PositiveInteger|)))))
"/git/fricas/src/algebra/JBC.spad"
((> (*1 *2 *1 *1)
    (AND (|ofCategory| *1 (|JetBundleCategory|)) (|isDomain| *2 (|Boolean|))))
 (|setNotation| (*1 *2 *2)
  (AND (|ofCategory| *1 (|JetBundleCategory|)) (|isDomain| *2 (|Symbol|))))
 (|getNotation| (*1 *2)
  (AND (|ofCategory| *1 (|JetBundleCategory|)) (|isDomain| *2 (|Symbol|))))
 (|multiIndex| (*1 *2 *1)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *2 (|List| (|NonNegativeInteger|)))))
 (|repeatedIndex| (*1 *2 *1)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *2 (|List| (|PositiveInteger|)))))
 (|r2m| (*1 *2 *3)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *3 (|List| (|PositiveInteger|)))
       (|isDomain| *2 (|List| (|NonNegativeInteger|)))))
 (|m2r| (*1 *2 *3)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *3 (|List| (|NonNegativeInteger|)))
       (|isDomain| *2 (|List| (|PositiveInteger|)))))
 (|allRepeated| (*1 *2 *3)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *3 (|List| (|NonNegativeInteger|)))
       (|isDomain| *2 (|List| (|List| (|PositiveInteger|))))))
 (|index| (*1 *2 *1)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *2 (|PositiveInteger|))))
 (|type| (*1 *2 *1)
  (AND (|ofCategory| *1 (|JetBundleCategory|)) (|isDomain| *2 (|Symbol|))))
 (|name| (*1 *2 *1)
  (AND (|ofCategory| *1 (|JetBundleCategory|)) (|isDomain| *2 (|Symbol|))))
 (|class| (*1 *2 *3)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *3 (|List| (|NonNegativeInteger|)))
       (|isDomain| *2 (|NonNegativeInteger|))))
 (|class| (*1 *2 *1)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *2 (|NonNegativeInteger|))))
 (|order| (*1 *2 *1)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *2 (|NonNegativeInteger|))))
 (|weight| (*1 *2 *1)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *2 (|NonNegativeInteger|))))
 (|differentiate| (*1 *2 *1 *3)
  (AND (|isDomain| *3 (|PositiveInteger|)) (|isDomain| *2 (|Union| *1 "0"))
       (|ofCategory| *1 (|JetBundleCategory|))))
 (|derivativeOf?| (*1 *2 *1 *1)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *2 (|List| (|NonNegativeInteger|)))))
 (|integrateIfCan| (*1 *1 *1 *2)
  (|partial| AND (|ofCategory| *1 (|JetBundleCategory|))
   (|isDomain| *2 (|PositiveInteger|))))
 (|integrate| (*1 *1 *1 *2)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *2 (|PositiveInteger|))))
 (X (*1 *1 *2)
  (AND (|isDomain| *2 (|PositiveInteger|))
       (|ofCategory| *1 (|JetBundleCategory|))))
 (U (*1 *1 *2)
  (AND (|isDomain| *2 (|PositiveInteger|))
       (|ofCategory| *1 (|JetBundleCategory|))))
 (P (*1 *1 *2 *3)
  (AND (|isDomain| *2 (|PositiveInteger|))
       (|isDomain| *3 (|List| (|NonNegativeInteger|)))
       (|ofCategory| *1 (|JetBundleCategory|))))
 (|Pm| (*1 *1 *2 *3)
  (AND (|isDomain| *2 (|PositiveInteger|))
       (|isDomain| *3 (|List| (|NonNegativeInteger|)))
       (|ofCategory| *1 (|JetBundleCategory|))))
 (|Pr| (*1 *1 *2 *3)
  (AND (|isDomain| *3 (|List| (|PositiveInteger|)))
       (|isDomain| *2 (|PositiveInteger|))
       (|ofCategory| *1 (|JetBundleCategory|))))
 (|One| (*1 *1) (|ofCategory| *1 (|JetBundleCategory|)))
 (|one?| (*1 *2 *1)
  (AND (|ofCategory| *1 (|JetBundleCategory|)) (|isDomain| *2 (|Boolean|))))
 (X (*1 *1) (|ofCategory| *1 (|JetBundleCategory|)))
 (U (*1 *1) (|ofCategory| *1 (|JetBundleCategory|)))
 (P (*1 *1 *2)
  (AND (|isDomain| *2 (|List| (|NonNegativeInteger|)))
       (|ofCategory| *1 (|JetBundleCategory|))))
 (P (*1 *1 *2 *3)
  (AND (|isDomain| *2 (|PositiveInteger|))
       (|isDomain| *3 (|NonNegativeInteger|))
       (|ofCategory| *1 (|JetBundleCategory|))))
 (P (*1 *1 *2)
  (AND (|isDomain| *2 (|NonNegativeInteger|))
       (|ofCategory| *1 (|JetBundleCategory|))))
 (|variables| (*1 *2 *3)
  (AND (|isDomain| *3 (|NonNegativeInteger|)) (|isDomain| *2 (|List| *1))
       (|ofCategory| *1 (|JetBundleCategory|))))
 (|variables| (*1 *2 *3 *4)
  (AND (|isDomain| *3 (|NonNegativeInteger|))
       (|isDomain| *4 (|PositiveInteger|)) (|isDomain| *2 (|List| *1))
       (|ofCategory| *1 (|JetBundleCategory|))))
 (|dimJ| (*1 *2 *2)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *2 (|NonNegativeInteger|))))
 (|dimS| (*1 *2 *2)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *2 (|NonNegativeInteger|))))
 (|numIndVar| (*1 *2)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *2 (|PositiveInteger|))))
 (|numDepVar| (*1 *2)
  (AND (|ofCategory| *1 (|JetBundleCategory|))
       (|isDomain| *2 (|PositiveInteger|)))))
((~= (((|Boolean|) $ $) 6)) (|weight| (((|NonNegativeInteger|) $) 6))
 (|variables| (((|List| $) (|NonNegativeInteger|)) 6)
  (((|List| $) (|NonNegativeInteger|) (|PositiveInteger|)) 6))
 (|type| (((|Symbol|) $) 6)) (|smaller?| (((|Boolean|) $ $) 6))
 (|setNotation| (((|Symbol|) (|Symbol|)) 6))
 (|repeatedIndex| (((|List| (|PositiveInteger|)) $) 6))
 (|r2m| (((|List| (|NonNegativeInteger|)) (|List| (|PositiveInteger|))) 6))
 (|order| (((|NonNegativeInteger|) $) 6)) (|one?| (((|Boolean|) $) 6))
 (|numIndVar| (((|PositiveInteger|)) 6))
 (|numDepVar| (((|PositiveInteger|)) 6)) (|name| (((|Symbol|) $) 6))
 (|multiIndex| (((|List| (|NonNegativeInteger|)) $) 6)) (|min| (($ $ $) 6))
 (|max| (($ $ $) 6))
 (|m2r| (((|List| (|PositiveInteger|)) (|List| (|NonNegativeInteger|))) 6))
 (|latex| (((|String|) $) 6))
 (|integrateIfCan| (((|Union| $ "failed") $ (|PositiveInteger|)) 6))
 (|integrate| (($ $ (|PositiveInteger|)) 6))
 (|index| (((|PositiveInteger|) $) 6))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) 6))
 (|hash| (((|SingleInteger|) $) 6)) (|getNotation| (((|Symbol|)) 6))
 (|dimS| (((|NonNegativeInteger|) (|NonNegativeInteger|)) 6))
 (|dimJ| (((|NonNegativeInteger|) (|NonNegativeInteger|)) 6))
 (|differentiate| (((|Union| $ "0") $ (|PositiveInteger|)) 6))
 (|derivativeOf?| (((|List| (|NonNegativeInteger|)) $ $) 6))
 (|coerce| (((|OutputForm|) $) 6) (((|Expression| (|Integer|)) $) 6))
 (|class| (((|NonNegativeInteger|) (|List| (|NonNegativeInteger|))) 6)
  (((|NonNegativeInteger|) $) 6))
 (|allRepeated|
  (((|List| (|List| (|PositiveInteger|))) (|List| (|NonNegativeInteger|))) 6))
 (X (($ (|PositiveInteger|)) 6) (($) 6))
 (U (($ (|PositiveInteger|)) 6) (($) 6))
 (|Pr| (($ (|PositiveInteger|) (|List| (|PositiveInteger|))) 6))
 (|Pm| (($ (|PositiveInteger|) (|List| (|NonNegativeInteger|))) 6))
 (P (($ (|PositiveInteger|) (|List| (|NonNegativeInteger|))) 6)
  (($ (|List| (|NonNegativeInteger|))) 6)
  (($ (|PositiveInteger|) (|NonNegativeInteger|)) 6)
  (($ (|NonNegativeInteger|)) 6))
 (|One| (($) 6 T CONST)) (>= (((|Boolean|) $ $) 6)) (> (((|Boolean|) $ $) 6))
 (= (((|Boolean|) $ $) 6)) (<= (((|Boolean|) $ $) 6)) (< (((|Boolean|) $ $) 6)))
JBC
(((|OrderedSet|) . T) ((|CoercibleTo| (|Expression| (|Integer|))) . T))
(((|BasicType|) . T) ((|CoercibleTo| (|Expression| (|Integer|))) . T)
 ((|CoercibleTo| (|OutputForm|)) . T) ((|Comparable|) . T) ((|OrderedSet|) . T)
 ((|PartialOrder|) . T) ((|SetCategory|) . T))
((|constructor|
  (NIL
   "\\spadtype{JetBundleCategory} provides basic data structures and procedures for jet bundles. Nearly all necessary functions are implemented already here. Only the representation and functions which direct access to it must be implemented in a domain. Two notations of derivatives are supported. Default is multi-index notation,{} where the \\spad{i}-th entry of the index denotes the number of differentiations taken with respect to \\spad{x^i}. In repeated index notation each entry \\spad{i} in the index denotes a differentiation with respect to \\spad{x^i}. The choice affects,{} however,{} only in- and output. Internally,{} multi-index notation is used throughout."))
 (|numDepVar|
  (((|PositiveInteger|))
   "\\spad{numDepVar} returns the number of dependent variables."))
 (|numIndVar|
  (((|PositiveInteger|))
   "\\spad{numIndVar} returns the number of independent variables."))
 (|dimS|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{dimS(q)} computes dimension of \\spad{SqT} \\spad{x} VE (= number of derivatives of order \\spad{q})."))
 (|dimJ|
  (((|NonNegativeInteger|) (|NonNegativeInteger|))
   "\\spad{dimJ(q)} computes the (fibre) dimension of the \\spad{q}\\spad{-}th order jet bundle."))
 (|variables|
  (((|List| $) (|NonNegativeInteger|) (|PositiveInteger|))
   "\\spad{variables(q,{} c)} computes all jet variables of order \\spad{q} whose class is greater than or equal to \\spad{c}.")
  (((|List| $) (|NonNegativeInteger|))
   "\\spad{variables(q)} computes the list of all jet variables up to order \\spad{q}."))
 (|one?|
  (((|Boolean|) $)
   "\\spad{one?(jv)} checks whether the jet variables \\spad{jv} is the special variable 1."))
 ((|One|)
  (($)
   "\\spad{1} generates the special \"jet variable\" 1,{} which is needed for the representation of linear functions."))
 (|Pr|
  (($ (|PositiveInteger|) (|List| (|PositiveInteger|)))
   "\\spad{Pr(i,{} ind)} is like \\spad{P(i,{} ind)} but \\spad{ind} is always a repeated index."))
 (|Pm|
  (($ (|PositiveInteger|) (|List| (|NonNegativeInteger|)))
   "\\spad{Pm(i,{} ind)} is like \\spad{P(i,{} ind)} but \\spad{ind} is always a multi-index."))
 (P
  (($ (|NonNegativeInteger|))
   "\\spad{P(i)} generates the \\spad{i}\\spad{-}th derivative of the only dependent variable \\spad{wrt} the only independent variable.")
  (($ (|PositiveInteger|) (|NonNegativeInteger|))
   "\\spad{P(i,{} j)} generates the \\spad{j}\\spad{-}th derivative of the \\spad{i}\\spad{-}th independent variable \\spad{wrt} the only independent variable.")
  (($ (|List| (|NonNegativeInteger|)))
   "\\spad{P(ind)} generates the derivative of the only dependent variable \\spad{wrt} the index \\spad{ind}.")
  (($ (|PositiveInteger|) (|List| (|NonNegativeInteger|)))
   "\\spad{P(i,{} ind)} generates the derivative of the \\spad{i}\\spad{-}th dependent variable \\spad{wrt} the index \\spad{ind}. Whether \\spad{ind} is interpreted as multi-index or as repeated index depends on the chosen notation."))
 (U (($) "\\spad{U()} generates the only dependent variable.")
  (($ (|PositiveInteger|))
   "\\spad{U(i)} generates the \\spad{i}\\spad{-}th dependent variable."))
 (X (($) "\\spad{X()} generates the only independent variable.")
  (($ (|PositiveInteger|))
   "\\spad{X(i)} generates the \\spad{i}\\spad{-}th independent variable."))
 (|integrate|
  (($ $ (|PositiveInteger|))
   "\\spad{integrate(jv,{} i)} is like \\spad{integrateIfCan(jv,{} i)} but yields an error,{} if the integration is not possible."))
 (|integrateIfCan|
  (((|Union| $ "failed") $ (|PositiveInteger|))
   "\\spad{integrate(jv,{} i)} integrated \\spad{jv} \\spad{wrt} the \\spad{i}\\spad{-}th independent variable,{} if possible."))
 (|derivativeOf?|
  (((|List| (|NonNegativeInteger|)) $ $)
   "\\spad{derivativeOf?(jv1,{} jv2)} checks whether \\spad{jv1} is a derivative of \\spad{jv2}. In this case,{} the difference of their multi-indices is returned. Otherwise,{} an empty list is returned."))
 (|differentiate|
  (((|Union| $ "0") $ (|PositiveInteger|))
   "\\spad{differentiate(jv,{} i)} differentiates \\spad{jv} \\spad{wrt} the \\spad{i}\\spad{-}th independent variable."))
 (>
  (((|Boolean|) $ $)
   "\\spad{jv1 > jv2} checks whether \\spad{jv1} is greater than \\spad{jv2} in the internal ordering."))
 (|weight|
  (((|NonNegativeInteger|) $)
   "\\spad{weight(jv)} assigns each jet variable a unique integer reflecting its position in the internal ordering. The variable with the greater weight is also greater in this ordering."))
 (|order|
  (((|NonNegativeInteger|) $)
   "\\spad{order(jv)} yields the order of the jet variable \\spad{jv} (Order as derivative)."))
 (|class|
  (((|NonNegativeInteger|) $)
   "\\spad{class(jv)} yields the class of the jet variable \\spad{jv} (Class of multi-index for derivative,{} 0 else).")
  (((|NonNegativeInteger|) (|List| (|NonNegativeInteger|)))
   "\\spad{class(ind)} yields the class of the multi-index \\spad{ind} (Position for first non-vanishing entry)."))
 (|name|
  (((|Symbol|) $)
   "\\spad{name(jv)} yields the name of the jet variable \\spad{jv}."))
 (|type|
  (((|Symbol|) $)
   "\\spad{type(jv)} yields the type (\\spad{Const,{} Indep,{} Dep,{} Deriv}) of the jet variable \\spad{jv}."))
 (|index|
  (((|PositiveInteger|) $)
   "\\spad{index(jv)} yields number of the jet variable \\spad{jv}."))
 (|allRepeated|
  (((|List| (|List| (|PositiveInteger|))) (|List| (|NonNegativeInteger|)))
   "\\spad{allRepeated(ind)} returns a list of all possible realizations of a given multi-index as repeated index."))
 (|m2r|
  (((|List| (|PositiveInteger|)) (|List| (|NonNegativeInteger|)))
   "\\spad{m2r(ind)} transforms a multi-index into a repeated index."))
 (|r2m|
  (((|List| (|NonNegativeInteger|)) (|List| (|PositiveInteger|)))
   "\\spad{r2m(ind)} transforms a repeated index into a multi-index."))
 (|repeatedIndex|
  (((|List| (|PositiveInteger|)) $)
   "\\spad{repeatedIndex(jv)} returns the multi-index of the jet variable \\spad{jv} in repeated index notation."))
 (|multiIndex|
  (((|List| (|NonNegativeInteger|)) $)
   "\\spad{multiIndex(jv)} returns the multi-index of the jet variable \\spad{jv}."))
 (|getNotation|
  (((|Symbol|)) "\\spad{getNotation()} shows the currently used notation."))
 (|setNotation|
  (((|Symbol|) (|Symbol|))
   "\\spad{setNotation(s)} chooses the notation used for derivatives. Returns the old value.")))
(("documentation" 0 9746) ("ancestors" 0 9549) ("parents" 0 9477)
 ("abbreviation" 0 9473) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 7301) ("modemaps" 0 2672) ("sourceFile" 0 2637)
 ("constructorCategory" 0 159) ("constructorModemap" 0 96)
 ("constructorKind" 0 85) ("constructorForm" 0 63) ("NILADIC" 0 20))