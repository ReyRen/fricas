)abbrev domain SARGND SArgand
++ Author: Martin Baker
++ Date Created: September 2010
++ Basic Operations: point, elt, setelt, copy, dimension, minIndex, maxIndex,
++ convert
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/prog/scratchpad/mycode/graph/
++ Description: an implementation of PointCategory to represent points and
++ vectors in an Argand plane

SArgand() : Exports == Implementation where
  ++ Domain for representing points, vectors, subspaces and properties
  ++ of components in a subspace as complex numbers
  DF ==> DoubleFloat
  C ==> Complex DF
  PI ==> PositiveInteger

  Exports == SPointCategory() with
    coerce : % -> C
    coerce : C -> %

  Implementation ==> add

    -- represented by real and imaginary parts of complex number
    Rep := Record(r : DF, i : DF)

    -- spnt(a, b) constructs a 2D point defined by a and b
    -- of type DF
    spnt(a : DF, b : DF) : % ==
      [a, b]

    -- spnt(a, b, c) constructs a 3D point defined by a, b and c
    -- of type DF
    spnt(a : DF, b : DF, c : DF) : % ==
      [a, b]

    -- svec(a, b) constructs a 2D vector defined by a and b
    -- of type DF
    svec(a : DF, b : DF) : % ==
      [a, b]

    -- svec(a, b, c) constructs a 3D vector defined by a, b and c
    -- of type DF
    svec(a : DF, b : DF, c : DF) : % ==
      [a, b]

    -- min(a, b) returns a point whose value in each dimension is
    -- the minimum. So if a has the smallest x value and b has the
    -- smallest y value then the result will combine these. This is
    -- useful for constructing boundary boxes around sets of points.
    min(a : %, b : %) : % ==
      re : DF := min(a.r, b.r)
      im : DF := min(a.i, b.i)
      [re, im]

    -- max(a, b) returns a point whose value in each dimension is
    -- the maximum. So if a has the largest x value and b has the
    -- largest y value then the result will combine these. This is
    -- useful for constructing boundary boxes around sets of points.
    max(a : %, b : %) : % ==
      re : DF := max(a.r, b.r)
      im : DF := max(a.i, b.i)
      [re, im]

    dimension p == 2 -- dimension of base space

    -- Test for NaN (Not a Number)
    -- That is have we divided by zero or taken sqrt of negative number at
    -- some stage? Common Lisp does not support NaN ? So we need some sort
    -- of test for invalid numbers
    -- If not equal to itself then we assume that its not a valid number
    nan?(x : DF) : Boolean == x ~= x

    -- Is this a valid point? if any of its elements are not valid
    -- then return true
    -- Examples of invalid floating point numbers are when have we
    -- have divided a given element by zero or taken
    -- sqrt of negative number at some stage?
    -- Note: we can still represent a point at infinity and we can
    -- represent points using complex numbers, but we do this using
    -- projective or conformal space or by using the appropriate
    -- instance of SPointCategory, not by using invalid floating
    -- point numbers.
    Pnan?(p : %) : Boolean ==
      nan?(p.r) => true
      nan?(p.i) => true
      false

    -- scale until length is 1
    unitVector(p : %) : % ==
      factor := sqrt(p.r * p.r + p.i * p.i)
      [p.r/factor, p.i/factor]

    -- returns the distance between the points p1 and p2
    -- there are 2 metrics associated with any SPointCategory
    -- the underlying space and the space that it is embedded in
    -- this is the distance in the underlying space.
    distanceSquared(p1 : %, p2 : %) : DF ==
      (p1.r - p2.r)^2 + (p1.i - p2.i)^2

    -- This returns the length of the parallel component of two vectors
    -- in the case of Euclidean space this is the dot product of two
    -- vectors. We use this function to test the colinearity
    parallel(x : %, y : %) : DF == x.r * y.r + x.i * y.i

    -- This returns a vector perpendicular to the two vectors
    -- in the case of 3D Euclidean space this is the cross product of the
    -- two vectors. We use this function to compute orthogonal
    -- In this case set to arbitrary value
    perpendicular(x : %, y : %) : % ==
      [0@DF, 1@DF]

    -- scalar multiplication
    _*(s : DF, x : %) : % ==
      [x.r * s, x.i * s]

    -- addition
    _+(x : %, y : %) : % ==
      [x.r + y.r, x.i + y.i]

    -- addition
    _-(x : %, y : %) : % ==
      [x.r - y.r, x.i - y.i]

    -- return true if param is inside bounding box
    -- where bounding box is specified by min and max
    inBounds?(pt : %, mns : %, mxs : %) : Boolean ==
      -- left of box - check minimum x
      pt.r < mns.r => false
      -- right of box - check maximum x
      pt.r > mxs.r => false
      -- below box - check minimum y
      pt.i < mns.i => false
      -- above box - check maximum y
      pt.i > mxs.i => false
      -- inside box so return true
      true

    -- returns the 'x'(left to right) screen coordinate
    screenCoordX(pt : %) : DF == pt.r

    -- returns the 'y'(bottom to top) screen coordinate
    screenCoordY(pt : %) : DF == pt.i

    -- returns the 'z'(out from screen) screen coordinate
    screenCoordZ(pt : %) : DF == 0@DF

    -- returns screen coordinates as a list
    screenCoords(pt : %) : List DF == [pt.r, pt.i]

    -- returns extended coordinates as a list
    extendedCoords(pt : %) : List DF == [pt.r, pt.i]

    -- toPoint(p) returns a Point with the same coordinates as p
    -- If p was originally a vector then that will be treated as the
    -- distance from the origin.
    toPoint(p : %) ==
      [p.r, p.i]

    -- toVector returns a Vector with the same coordinates as p
    -- If p was originally a point then the vector will be the
    -- distance from the origin.
    toVector(p : %) ==
      [p.r, p.i]

    -- isPoint?(p) returns true if this represents a point as
    -- opposed to a vector. Since there is no distinction in
    -- Argand plane always return true.
    isPoint?(p : %) == true

    -- isVector? returns true if this represents a vector as
    -- opposed to a point. Since there is no distinction in
    -- Argand plane always return true.
    isVector?(p : %) == true

    coerce(me : %) : C ==
      complex(me.r, me.i)

    coerce(cmpx : C) : % ==
      [real(cmpx), imag(cmpx)]

    -- start of SetCategory definitions --

    hash(s : %) : SingleInteger == 0$SingleInteger

    -- returns true if x equals y
    _=(x : %, y : %) : Boolean ==
      if x.r ~= y.r then return false
      if x.i ~= y.i then return false
      true

    -- returns true if x is not equal to y
    _~_=(x : %, y : %) : Boolean == not(x = y)

    -- output
    coerce(pt : %) : OutputForm ==
      pt.i < 0::DF =>
        ((pt.r)::OutputForm) - _
             (hconcat('%i::OutputForm, (- pt.i)::OutputForm))
      ((pt.r)::OutputForm) + _
           (hconcat('%i::OutputForm, (pt.i)::OutputForm))

)if false

A coding of points and vectors in conformal space.
\section{SConformal domain}
)endif

