)abbrev package EFGUSER ElementaryFunctionsGeneralizedUnivariatePowerSeries
ElementaryFunctionsGeneralizedUnivariatePowerSeries(
    Coef : Algebra Fraction Integer,
     Expon : OrderedAbelianMonoid,
      PS : UnivariatePowerSeriesCategory(Coef, Expon) with (
         removeZeros : (%, Expon) -> %;
          apply_taylor : (Stream Coef, %) -> %
       )
   ) : Exports == Implementation where
  Exports ==> PartialTranscendentalFunctions(PS) with

    do_quo : (PS, PS) -> Union(PS, "failed")

  Implementation ==> add

    STTF ==> StreamTranscendentalFunctions(Coef)
    STSO ==> StreamTaylorSeriesOperations(Coef)

    TRANSFCN : Boolean := Coef has TranscendentalFunctionCategory
                          and Coef has CommutativeRing

    apply_taylor1(ft : Stream(Coef) -> Stream(Coef), x : PS
                 ) : Union(PS, "failed") ==
        x := removeZeros(x, 0)
        degree(x) < 0 => "failed"
        c0 := coefficient(x, 0)
        s1 := monom(c0, 0)$STSO +$STSO monom(1, 1)$STSO
        fxu : Union(Stream(Coef), "failed") := trappedSpadEval(ft(s1))$Lisp
        fxu case "failed" => "failed"
        apply_taylor(fxu::Stream(Coef), x - monomial(c0, 0)$PS)

    if Expon has Algebra(Fraction(Integer)) then

      nthRootIfCan(x : PS, n : NonNegativeInteger) ==
        n = 0 => 1$PS
        n = 1 => x
        x := removeZeros(x, 0)
        ord : Expon := degree(x)
        if ord >= 0 then
            for i in 0..50 while coefficient(x, ord) = 0 repeat
                x := removeZeros(x, ord + 10*(1$Expon))
                ord := degree(x)
        (c0 := coefficient(x, ord)) = 0 => "failed"
        x1 := monomial(1, (-1)*ord)*x
        res1 := apply_taylor1((s : Stream(Coef)) : Stream(Coef) +->
                               powern(1/n, s)$STSO, x1)
        res1 case "failed" => "failed"
        monomial(1, (1/n)*ord)*res1::PS

    expIfCan(x : PS) ==
        x := removeZeros(x, 0)
        degree(x) < 0 => "failed"
        expx := exp(monom(1, 1)$STSO)$STTF
        (c1 := coefficient(x, 0)) = 0 => apply_taylor(expx, x)
        TRANSFCN => exp(c1)*apply_taylor(expx, x - monomial(c1, 0)$PS)
        "failed"

    logIfCan(x : PS) == apply_taylor1(log$STTF, x)

    sincos(x : PS) : Union(Record(sin : PS, cos : PS), "failed") ==
        x := removeZeros(x, 0)
        degree(x) < 0 => "failed"
        scst := sincos(monom(1, 1)$STSO)$STTF
        (c1 := coefficient(x, 0)) = 0 =>
            [apply_taylor(scst.sin, x), apply_taylor(scst.cos, x)]
        TRANSFCN =>
            x1 := x - monomial(c1, 0)$PS
            sx1 := apply_taylor(scst.sin, x1)
            cx1 := apply_taylor(scst.cos, x1)
            sc1 := sin(c1)
            cc1 := cos(c1)
            [sc1*cx1 + cc1*sx1, cc1*cx1 - sc1*sx1]
        "failed"

    sinIfCan(x) ==
        usc := sincos(x)
        usc case "failed" => "failed"
        (usc::Record(sin : PS, cos : PS)).sin

    cosIfCan(x) ==
        usc := sincos(x)
        usc case "failed" => "failed"
        (usc::Record(sin : PS, cos : PS)).cos

    tanIfCan(x) ==
        usc := sincos(x)
        usc case "failed" => "failed"
        do_quo((usc::Record(sin : PS, cos : PS)).sin,
          (usc::Record(sin : PS, cos : PS)).cos)

    cotIfCan(x) ==
        usc := sincos(x)
        usc case "failed" => "failed"
        do_quo((usc::Record(sin : PS, cos : PS)).cos,
          (usc::Record(sin : PS, cos : PS)).sin)

    secIfCan(x) ==
        usc := sincos(x)
        usc case "failed" => "failed"
        do_quo(1$PS, (usc::Record(sin : PS, cos : PS)).cos)

    cscIfCan(x) ==
        usc := sincos(x)
        usc case "failed" => "failed"
        do_quo(1$PS, (usc::Record(sin : PS, cos : PS)).sin)

    asinIfCan(x) == apply_taylor1(asin$STTF, x)

    acosIfCan(x) == apply_taylor1(acos$STTF, x)

    atanIfCan(x) == apply_taylor1(atan$STTF, x)

    acotIfCan(x) == apply_taylor1(acot$STTF, x)

    asecIfCan(x) == apply_taylor1(asec$STTF, x)

    acscIfCan(x) == apply_taylor1(acsc$STTF, x)

    sinhcosh(x : PS) : Union(Record(sinh : PS, cosh : PS), "failed") ==
        x := removeZeros(x, 0)
        degree(x) < 0 => "failed"
        scst := sinhcosh(monom(1, 1)$STSO)$STTF
        (c1 := coefficient(x, 0)) = 0 =>
            [apply_taylor(scst.sinh, x), apply_taylor(scst.cosh, x)]
        TRANSFCN =>
            x1 := x - monomial(c1, 0)$PS
            sx1 := apply_taylor(scst.sinh, x1)
            cx1 := apply_taylor(scst.cosh, x1)
            sc1 := sinh(c1)
            cc1 := cosh(c1)
            [sc1*cx1 + cc1*sx1, cc1*cx1 + sc1*sx1]
        "failed"

    sinhIfCan(x) ==
        usc := sinhcosh(x)
        usc case "failed" => "failed"
        (usc::Record(sinh : PS, cosh : PS)).sinh

    coshIfCan(x) ==
        usc := sinhcosh(x)
        usc case "failed" => "failed"
        (usc::Record(sinh : PS, cosh : PS)).cosh

    tanhIfCan(x) ==
        usc := sinhcosh(x)
        usc case "failed" => "failed"
        do_quo((usc::Record(sinh : PS, cosh : PS)).sinh,
          (usc::Record(sinh : PS, cosh : PS)).cosh)

    cothIfCan(x) ==
        usc := sinhcosh(x)
        usc case "failed" => "failed"
        do_quo((usc::Record(sinh : PS, cosh : PS)).cosh,
          (usc::Record(sinh : PS, cosh : PS)).sinh)

    sechIfCan(x) ==
        usc := sinhcosh(x)
        usc case "failed" => "failed"
        do_quo(1$PS, (usc::Record(sinh : PS, cosh : PS)).cosh)

    cschIfCan(x) ==
        usc := sinhcosh(x)
        usc case "failed" => "failed"
        do_quo(1$PS, (usc::Record(sinh : PS, cosh : PS)).sinh)

    asinhIfCan(x) == apply_taylor1(asinh$STTF, x)

    acoshIfCan(x) == apply_taylor1(acosh$STTF, x)

    atanhIfCan(x) == apply_taylor1(atanh$STTF, x)

    acothIfCan(x) == apply_taylor1(acoth$STTF, x)

    asechIfCan(x) == apply_taylor1(asech$STTF, x)

    acschIfCan(x) == apply_taylor1(acsch$STTF, x)


    if Coef has IntegralDomain then

        do_quo(x, y) == x exquo y

    else

        do_quo(x, y) ==
            (yinv := recip(y)) case "failed" => "failed"
            x*yinv::PS



