10335               (|UnaryRecursiveAggregate&| A S)
|domain|
(((|UnaryRecursiveAggregate&| |#1| |#2|)
  (CATEGORY |domain| (SIGNATURE |split!| (|#1| |#1| (|NonNegativeInteger|)))
   (SIGNATURE |setelt!| (|#2| |#1| "last" |#2|))
   (SIGNATURE |setlast!| (|#2| |#1| |#2|))
   (SIGNATURE |setelt!| (|#1| |#1| "rest" |#1|))
   (SIGNATURE |qsetrest!| (|#1| |#1| |#1|))
   (SIGNATURE |setelt!| (|#2| |#1| "first" |#2|))
   (SIGNATURE |qsetfirst!| (|#2| |#1| |#2|))
   (SIGNATURE |cycleSplit!| (|#1| |#1|)) (SIGNATURE |cycleTail| (|#1| |#1|))
   (SIGNATURE |cycleLength| ((|NonNegativeInteger|) |#1|))
   (SIGNATURE |cycleEntry| (|#1| |#1|)) (SIGNATURE |third| (|#2| |#1|))
   (SIGNATURE |second| (|#2| |#1|)) (SIGNATURE |tail| (|#1| |#1|))
   (SIGNATURE |last| (|#1| |#1| (|NonNegativeInteger|)))
   (SIGNATURE |elt| (|#2| |#1| "last")) (SIGNATURE |last| (|#2| |#1|))
   (SIGNATURE |rest| (|#1| |#1| (|NonNegativeInteger|)))
   (SIGNATURE |elt| (|#1| |#1| "rest")) (SIGNATURE |rest| (|#1| |#1|))
   (SIGNATURE |elt| (|#2| |#1| "first")) (SIGNATURE |concat| (|#1| |#2| |#1|))
   (SIGNATURE |concat| (|#1| |#1| |#1|))
   (SIGNATURE |setvalue!| (|#2| |#1| |#2|))
   (SIGNATURE |setelt!| (|#2| |#1| #1="value" |#2|))
   (SIGNATURE |setchildren!| (|#1| |#1| (|List| |#1|)))
   (SIGNATURE |node?| ((|Boolean|) |#1| |#1|))
   (SIGNATURE |cyclic?| ((|Boolean|) |#1|)) (SIGNATURE |elt| (|#2| |#1| #1#))
   (SIGNATURE |value| (|#2| |#1|)) (SIGNATURE |leaf?| ((|Boolean|) |#1|))
   (SIGNATURE |nodes| ((|List| |#1|) |#1|))
   (SIGNATURE |children| ((|List| |#1|) |#1|))
   (SIGNATURE = ((|Boolean|) |#1| |#1|))
   (SIGNATURE |map!| (|#1| (|Mapping| |#2| |#2|) |#1|))
   (SIGNATURE |#| ((|NonNegativeInteger|) |#1|))
   (SIGNATURE |size?| ((|Boolean|) |#1| (|NonNegativeInteger|)))
   (SIGNATURE |more?| ((|Boolean|) |#1| (|NonNegativeInteger|)))
   (SIGNATURE |less?| ((|Boolean|) |#1| (|NonNegativeInteger|))))
  (|UnaryRecursiveAggregate| |#2|) (|Type|))
 (T |UnaryRecursiveAggregate&|))
(CATEGORY |domain| (SIGNATURE |split!| (|#1| |#1| (|NonNegativeInteger|)))
 (SIGNATURE |setelt!| (|#2| |#1| "last" |#2|))
 (SIGNATURE |setlast!| (|#2| |#1| |#2|))
 (SIGNATURE |setelt!| (|#1| |#1| "rest" |#1|))
 (SIGNATURE |qsetrest!| (|#1| |#1| |#1|))
 (SIGNATURE |setelt!| (|#2| |#1| "first" |#2|))
 (SIGNATURE |qsetfirst!| (|#2| |#1| |#2|))
 (SIGNATURE |cycleSplit!| (|#1| |#1|)) (SIGNATURE |cycleTail| (|#1| |#1|))
 (SIGNATURE |cycleLength| ((|NonNegativeInteger|) |#1|))
 (SIGNATURE |cycleEntry| (|#1| |#1|)) (SIGNATURE |third| (|#2| |#1|))
 (SIGNATURE |second| (|#2| |#1|)) (SIGNATURE |tail| (|#1| |#1|))
 (SIGNATURE |last| (|#1| |#1| (|NonNegativeInteger|)))
 (SIGNATURE |elt| (|#2| |#1| "last")) (SIGNATURE |last| (|#2| |#1|))
 (SIGNATURE |rest| (|#1| |#1| (|NonNegativeInteger|)))
 (SIGNATURE |elt| (|#1| |#1| "rest")) (SIGNATURE |rest| (|#1| |#1|))
 (SIGNATURE |elt| (|#2| |#1| "first")) (SIGNATURE |concat| (|#1| |#2| |#1|))
 (SIGNATURE |concat| (|#1| |#1| |#1|)) (SIGNATURE |setvalue!| (|#2| |#1| |#2|))
 (SIGNATURE |setelt!| (|#2| |#1| #1="value" |#2|))
 (SIGNATURE |setchildren!| (|#1| |#1| (|List| |#1|)))
 (SIGNATURE |node?| ((|Boolean|) |#1| |#1|))
 (SIGNATURE |cyclic?| ((|Boolean|) |#1|)) (SIGNATURE |elt| (|#2| |#1| #1#))
 (SIGNATURE |value| (|#2| |#1|)) (SIGNATURE |leaf?| ((|Boolean|) |#1|))
 (SIGNATURE |nodes| ((|List| |#1|) |#1|))
 (SIGNATURE |children| ((|List| |#1|) |#1|))
 (SIGNATURE = ((|Boolean|) |#1| |#1|))
 (SIGNATURE |map!| (|#1| (|Mapping| |#2| |#2|) |#1|))
 (SIGNATURE |#| ((|NonNegativeInteger|) |#1|))
 (SIGNATURE |size?| ((|Boolean|) |#1| (|NonNegativeInteger|)))
 (SIGNATURE |more?| ((|Boolean|) |#1| (|NonNegativeInteger|)))
 (SIGNATURE |less?| ((|Boolean|) |#1| (|NonNegativeInteger|))))
"/git/fricas/src/algebra/URAGG.spad"
((|value| ((|#2| $) 28)) (|third| ((|#2| $) 18)) (|tail| (($ $) 37))
 (|split!| (($ $ (|NonNegativeInteger|)) 65))
 (|size?| (((|Boolean|) $ (|NonNegativeInteger|)) 34))
 (|setvalue!| ((|#2| $ |#2|) 62)) (|setlast!| ((|#2| $ |#2|) 60))
 (|setelt!| ((|#2| $ #1="value" |#2|) NIL) ((|#2| $ "first" |#2|) 51)
  (($ $ "rest" $) 55) ((|#2| $ "last" |#2|) 53))
 (|setchildren!| (($ $ (|List| $)) 61)) (|second| ((|#2| $) 17))
 (|rest| (($ $) NIL) (($ $ (|NonNegativeInteger|)) 43))
 (|qsetrest!| (($ $ $) 59)) (|qsetfirst!| ((|#2| $ |#2|) 58))
 (|nodes| (((|List| $) $) 25)) (|node?| (((|Boolean|) $ $) 49))
 (|more?| (((|Boolean|) $ (|NonNegativeInteger|)) 33))
 (|map!| (($ (|Mapping| |#2| |#2|) $) 68))
 (|less?| (((|Boolean|) $ (|NonNegativeInteger|)) 32))
 (|leaf?| (((|Boolean|) $) 27))
 (|last| ((|#2| $) 23) (($ $ (|NonNegativeInteger|)) 45))
 (|elt| ((|#2| $ #1#) NIL) ((|#2| $ "first") 10) (($ $ "rest") 16)
  ((|#2| $ "last") 13))
 (|cyclic?| (((|Boolean|) $) 21)) (|cycleTail| (($ $) 40))
 (|cycleSplit!| (($ $) 66)) (|cycleLength| (((|NonNegativeInteger|) $) 42))
 (|cycleEntry| (($ $) 41)) (|concat| (($ $ $) 57) (($ |#2| $) NIL))
 (|children| (((|List| $) $) 26)) (= (((|Boolean|) $ $) 47))
 (|#| (((|NonNegativeInteger|) $) 36)))
((|HasCategory| |#1| '(|shallowlyMutable|)))
URAGG-
((|constructor|
  (NIL
   "A unary-recursive aggregate is an aggregate where nodes may have either 0 or 1 children. This aggregate models,{} though not precisely,{} a linked list possibly with a single cycle. A node with one children models a non-empty list,{} with the \\spadfun{value} of the list designating the head,{} or \\spadfun{first},{} of the list,{} and the child designating the tail,{} or \\spadfun{rest},{} of the list. A node with no child then designates the empty list. Since these aggregates are recursive aggregates,{} they may be cyclic."))
 (|split!|
  (($ $ (|NonNegativeInteger|))
   "\\spad{split!(u,{} n)} splits \\spad{u} into two aggregates: \\spad{v = rest(u,{} n)} and \\spad{w = first(u,{} n)},{} returning \\spad{v} and setting \\spad{u} to \\spad{w}. If \\spad{n} is 0,{} split! currently only works for Stream and gives error for List. Note: afterwards \\spad{rest(u,{} n)} returns \\spad{empty()}."))
 (|setlast!|
  ((|#2| $ |#2|)
   "\\spad{setlast!(u,{} x)} destructively changes the last element of \\spad{u} to \\spad{x}. Error if \\spad{u} is empty."))
 (|qsetrest!|
  (($ $ $)
   "\\spad{qsetrest!(u,{} v)} destructively changes the rest of \\spad{u} to \\spad{v} without checking for errors."))
 (|setrest!|
  (($ $ $)
   "\\spad{setrest!(u,{} v)} destructively changes the rest of \\spad{u} to \\spad{v}. Error if \\spad{u} is empty."))
 (|setelt!|
  ((|#2| $ "last" |#2|)
   "\\spad{setelt!(u,{} \"last\",{} x)} (also written: \\spad{u.last := x}) is equivalent to \\spad{setlast!(u,{} x)}.")
  (($ $ "rest" $)
   "\\spad{setelt!(u,{} \"rest\",{} v)} (also written: \\spad{u.rest := v}) is equivalent to \\spad{setrest!(u,{} v)}.")
  ((|#2| $ "first" |#2|)
   "\\spad{setelt!(u,{} \"first\",{} x)} (also written: \\spad{u.first := x}) is equivalent to \\spad{setfirst!(u,{} x)}."))
 (|qsetfirst!|
  ((|#2| $ |#2|)
   "\\spad{qsetfirst!(u,{} x)} destructively changes the first element of \\spad{u} to \\spad{x} without checking for errors."))
 (|setfirst!|
  ((|#2| $ |#2|)
   "\\spad{setfirst!(u,{} x)} destructively changes the first element of \\spad{u} to \\spad{x}. Error if \\spad{u} is empty."))
 (|cycleSplit!|
  (($ $)
   "\\spad{cycleSplit!(u)} splits the aggregate by dropping off the cycle. The value returned is the cycle entry,{} or empty() if none exists. For example,{} if \\spad{w = concat(u,{} v)} is the cyclic list where \\spad{v} is the head of the cycle,{} \\spad{cycleSplit!(w)} will drop \\spad{v} off \\spad{w} thus destructively changing \\spad{w} to \\spad{u},{} and returning \\spad{v}."))
 (|concat!|
  (($ $ |#2|)
   "\\spad{concat!(u,{} x)} destructively adds element \\spad{x} to the end of \\spad{u}. Note: \\spad{concat!(a,{} x) = concat!(a,{} [x])}.")
  (($ $ $)
   "\\spad{concat!(u,{} v)} destructively concatenates \\spad{v} to the end of \\spad{u}."))
 (|cycleTail|
  (($ $)
   "\\spad{cycleTail(u)} returns the last node in the cycle,{} or empty() if none exists."))
 (|cycleLength|
  (((|NonNegativeInteger|) $)
   "\\spad{cycleLength(u)} returns the length of a top-level cycle contained in aggregate \\spad{u},{} or 0 if \\spad{u} has no such cycle."))
 (|cycleEntry|
  (($ $)
   "\\spad{cycleEntry(u)} returns the head of a top-level cycle contained in aggregate \\spad{u},{} or \\spad{empty()} if none exists."))
 (|third|
  ((|#2| $)
   "\\spad{third(u)} returns the third element of \\spad{u}. Note: \\spad{third(u) = first(rest(rest(u)))}."))
 (|second|
  ((|#2| $)
   "\\spad{second(u)} returns the second element of \\spad{u}. Note: \\spad{second(u) = first(rest(u))}."))
 (|tail|
  (($ $)
   "\\spad{tail(u)} returns the last node of \\spad{u}. Error if \\spad{u} is empty."))
 (|last|
  (($ $ (|NonNegativeInteger|))
   "\\spad{last(u,{} n)} returns a copy of the last \\spad{n} nodes of \\spad{u}. Note: \\spad{last(u,{} n)} is a list of \\spad{n} elements.")
  ((|#2| $)
   "\\spad{last(u)} returns the last element of \\spad{u}. Note: for lists,{} \\spad{last(u) = u.(maxIndex u)}."))
 (|rest|
  (($ $ (|NonNegativeInteger|))
   "\\spad{rest(u,{} n)} returns the \\spad{n}th node of \\spad{u}. Note: \\spad{rest(u,{} 0) = u}.")
  (($ $)
   "\\spad{rest(u)} returns an aggregate consisting of all but the first element of \\spad{u} (equivalently,{} the next node of \\spad{u})."))
 (|elt|
  ((|#2| $ "last")
   "\\spad{elt(u,{} \"last\")} (also written: \\spad{u.last}) is equivalent to last(\\spad{u}).")
  (($ $ "rest")
   "\\spad{elt(\\%,{} \"rest\")} (also written: \\spad{u.rest}) is equivalent to \\spad{rest u}.")
  ((|#2| $ "first")
   "\\spad{elt(u,{} \"first\")} (also written: \\spad{u.first}) is equivalent to first(\\spad{u})."))
 (|first|
  (($ $ (|NonNegativeInteger|))
   "\\spad{first(u,{} n)} returns a copy of the first \\spad{n} elements of \\spad{u}.")
  ((|#2| $)
   "\\spad{first(u)} returns the first element of \\spad{u} (equivalently,{} the value at the current node)."))
 (|concat|
  (($ |#2| $)
   "\\spad{concat(x,{} u)} returns aggregate consisting of \\spad{x} followed by the elements of \\spad{u}. Note: if \\spad{v = concat(x,{} u)} then \\spad{x = first v} and \\spad{u = rest v}.")
  (($ $ $)
   "\\spad{concat(u,{} v)} returns an aggregate \\spad{w} consisting of the elements of \\spad{u} followed by the elements of \\spad{v}. Note: \\spad{v = rest(w,{} \\#u)}.")))
(("documentation" 0 5033) ("ancestors" 0 NIL) ("parents" 0 NIL)
 ("abbreviation" 0 5026) ("predicates" 0 4981) ("superDomain" 0 NIL)
 ("operationAlist" 0 3741) ("modemaps" 0 NIL) ("sourceFile" 0 3704)
 ("constructorCategory" 0 1974) ("constructorModemap" 0 62)
 ("constructorKind" 0 53) ("constructorForm" 0 20))