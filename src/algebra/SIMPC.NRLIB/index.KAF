17327               (|FiniteSimplicialComplex| VS)
|domain|
(((|FiniteSimplicialComplex| |#1|)
  (|Join| (|SetCategory|)
          (CATEGORY |domain|
           (SIGNATURE |simplicialComplex|
            ($ (|List| |#1|) (|NonNegativeInteger|)
             (|List| (|List| (|NonNegativeInteger|)))))
           (SIGNATURE |simplicialComplex|
            ($ (|List| |#1|) (|List| (|List| (|NonNegativeInteger|)))))
           (SIGNATURE |simplicialComplex| ($ (|List| |#1|)))
           (SIGNATURE |simplicialComplexIfCan|
            ((|Union| $ "failed") (|DeltaComplex| |#1|) (|Boolean|)))
           (SIGNATURE |simplicialComplexIfCan|
            ((|Union| $ "failed") (|DeltaComplex| |#1|)))
           (SIGNATURE |addSimplex| ($ $ (|OrientedFacet|)))
           (SIGNATURE |maxIndex| ((|NonNegativeInteger|) $))
           (SIGNATURE |minIndex| ((|NonNegativeInteger|) $))
           (SIGNATURE |grade| ((|List| (|List| (|OrientedFacet|))) $))
           (SIGNATURE |sort| ($ $))
           (SIGNATURE |addImpliedFaces|
            ((|List| (|List| (|OrientedFacet|))) $))
           (SIGNATURE |boundary| ($ $))
           (SIGNATURE |star| ($ $ (|OrientedFacet|)))
           (SIGNATURE |link| ($ $ (|OrientedFacet|)))
           (SIGNATURE |cone| ($ $ (|NonNegativeInteger|)))
           (SIGNATURE |refactorIndexes| ($ $ (|NonNegativeInteger|)))
           (SIGNATURE |makeDisjoint| ($ $ $))
           (SIGNATURE |simplicialJoin| ($ $ $ (|Boolean|)))
           (SIGNATURE |merge| ($ $ $)) (SIGNATURE |product| ($ $ $))
           (SIGNATURE |oneSkeleton|
            ((|DirectedGraph| (|NonNegativeInteger|)) $))
           (SIGNATURE |fundamentalGroup| ((|GroupPresentation|) $))
           (SIGNATURE |fundamentalGroup|
            ((|GroupPresentation|) $ (|Boolean|) (|Boolean|)))
           (SIGNATURE |chain| ((|ChainComplex|) $))
           (SIGNATURE |coChain| ((|CoChainComplex| |#1|) $))
           (SIGNATURE |homology| ((|List| (|Homology|)) $))
           (SIGNATURE |coHomology| ((|List| (|Homology|)) $))
           (SIGNATURE |coerce| ((|DeltaComplex| |#1|) $))))
  (|AbelianGroup|))
 (T |FiniteSimplicialComplex|))
(|Join| (|SetCategory|)
        (CATEGORY |domain|
         (SIGNATURE |simplicialComplex|
          ($ (|List| |#1|) (|NonNegativeInteger|)
           (|List| (|List| (|NonNegativeInteger|)))))
         (SIGNATURE |simplicialComplex|
          ($ (|List| |#1|) (|List| (|List| (|NonNegativeInteger|)))))
         (SIGNATURE |simplicialComplex| ($ (|List| |#1|)))
         (SIGNATURE |simplicialComplexIfCan|
          ((|Union| $ "failed") (|DeltaComplex| |#1|) (|Boolean|)))
         (SIGNATURE |simplicialComplexIfCan|
          ((|Union| $ "failed") (|DeltaComplex| |#1|)))
         (SIGNATURE |addSimplex| ($ $ (|OrientedFacet|)))
         (SIGNATURE |maxIndex| ((|NonNegativeInteger|) $))
         (SIGNATURE |minIndex| ((|NonNegativeInteger|) $))
         (SIGNATURE |grade| ((|List| (|List| (|OrientedFacet|))) $))
         (SIGNATURE |sort| ($ $))
         (SIGNATURE |addImpliedFaces| ((|List| (|List| (|OrientedFacet|))) $))
         (SIGNATURE |boundary| ($ $))
         (SIGNATURE |star| ($ $ (|OrientedFacet|)))
         (SIGNATURE |link| ($ $ (|OrientedFacet|)))
         (SIGNATURE |cone| ($ $ (|NonNegativeInteger|)))
         (SIGNATURE |refactorIndexes| ($ $ (|NonNegativeInteger|)))
         (SIGNATURE |makeDisjoint| ($ $ $))
         (SIGNATURE |simplicialJoin| ($ $ $ (|Boolean|)))
         (SIGNATURE |merge| ($ $ $)) (SIGNATURE |product| ($ $ $))
         (SIGNATURE |oneSkeleton| ((|DirectedGraph| (|NonNegativeInteger|)) $))
         (SIGNATURE |fundamentalGroup| ((|GroupPresentation|) $))
         (SIGNATURE |fundamentalGroup|
          ((|GroupPresentation|) $ (|Boolean|) (|Boolean|)))
         (SIGNATURE |chain| ((|ChainComplex|) $))
         (SIGNATURE |coChain| ((|CoChainComplex| |#1|) $))
         (SIGNATURE |homology| ((|List| (|Homology|)) $))
         (SIGNATURE |coHomology| ((|List| (|Homology|)) $))
         (SIGNATURE |coerce| ((|DeltaComplex| |#1|) $))))
"/git/fricas/src/algebra/SIMPC.spad"
((|simplicialComplex| (*1 *1 *2 *3 *4)
  (AND (|isDomain| *2 (|List| *5))
       (|isDomain| *4 (|List| (|List| (|NonNegativeInteger|))))
       (|ofCategory| *5 (|AbelianGroup|))
       (|isDomain| *3 (|NonNegativeInteger|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *5))))
 (|simplicialComplex| (*1 *1 *2 *3)
  (AND (|isDomain| *2 (|List| *4))
       (|isDomain| *3 (|List| (|List| (|NonNegativeInteger|))))
       (|ofCategory| *4 (|AbelianGroup|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *4))))
 (|simplicialComplex| (*1 *1 *2)
  (AND (|isDomain| *2 (|List| *3)) (|ofCategory| *3 (|AbelianGroup|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))))
 (|simplicialComplexIfCan| (*1 *1 *2 *3)
  (|partial| AND (|isDomain| *2 (|DeltaComplex| *4))
   (|isDomain| *3 (|Boolean|)) (|ofCategory| *4 (|AbelianGroup|))
   (|isDomain| *1 (|FiniteSimplicialComplex| *4))))
 (|simplicialComplexIfCan| (*1 *1 *2)
  (|partial| AND (|isDomain| *2 (|DeltaComplex| *3))
   (|ofCategory| *3 (|AbelianGroup|))
   (|isDomain| *1 (|FiniteSimplicialComplex| *3))))
 (|addSimplex| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|OrientedFacet|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|maxIndex| (*1 *2 *1)
  (AND (|isDomain| *2 (|NonNegativeInteger|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|minIndex| (*1 *2 *1)
  (AND (|isDomain| *2 (|NonNegativeInteger|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|grade| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|List| (|OrientedFacet|))))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|sort| (*1 *1 *1)
  (AND (|isDomain| *1 (|FiniteSimplicialComplex| *2))
       (|ofCategory| *2 (|AbelianGroup|))))
 (|addImpliedFaces| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|List| (|OrientedFacet|))))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|boundary| (*1 *1 *1)
  (AND (|isDomain| *1 (|FiniteSimplicialComplex| *2))
       (|ofCategory| *2 (|AbelianGroup|))))
 (|star| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|OrientedFacet|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|link| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|OrientedFacet|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|cone| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|NonNegativeInteger|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|refactorIndexes| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|NonNegativeInteger|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|makeDisjoint| (*1 *1 *1 *1)
  (AND (|isDomain| *1 (|FiniteSimplicialComplex| *2))
       (|ofCategory| *2 (|AbelianGroup|))))
 (|simplicialJoin| (*1 *1 *1 *1 *2)
  (AND (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|merge| (*1 *1 *1 *1)
  (AND (|isDomain| *1 (|FiniteSimplicialComplex| *2))
       (|ofCategory| *2 (|AbelianGroup|))))
 (|product| (*1 *1 *1 *1)
  (AND (|isDomain| *1 (|FiniteSimplicialComplex| *2))
       (|ofCategory| *2 (|AbelianGroup|))))
 (|oneSkeleton| (*1 *2 *1)
  (AND (|isDomain| *2 (|DirectedGraph| (|NonNegativeInteger|)))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|fundamentalGroup| (*1 *2 *1)
  (AND (|isDomain| *2 (|GroupPresentation|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|fundamentalGroup| (*1 *2 *1 *3 *3)
  (AND (|isDomain| *3 (|Boolean|)) (|isDomain| *2 (|GroupPresentation|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *4))
       (|ofCategory| *4 (|AbelianGroup|))))
 (|chain| (*1 *2 *1)
  (AND (|isDomain| *2 (|ChainComplex|))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|coChain| (*1 *2 *1)
  (AND (|isDomain| *2 (|CoChainComplex| *3))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|homology| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|Homology|)))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|coHomology| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|Homology|)))
       (|isDomain| *1 (|FiniteSimplicialComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|coerce| (*1 *2 *1)
           (AND (|isDomain| *2 (|DeltaComplex| *3))
                (|isDomain| *1 (|FiniteSimplicialComplex| *3))
                (|ofCategory| *3 (|AbelianGroup|)))))
((~= (((|Boolean|) $ $) NIL)) (|star| (($ $ (|OrientedFacet|)) 77))
 (|sort| (($ $) 67)) (|simplicialJoin| (($ $ $ (|Boolean|)) 87))
 (|simplicialComplexIfCan|
  (((|Union| $ "failed") (|DeltaComplex| |#1|) (|Boolean|)) 26)
  (((|Union| $ "failed") (|DeltaComplex| |#1|)) 27))
 (|simplicialComplex|
  (($ (|List| |#1|) (|NonNegativeInteger|)
    (|List| (|List| (|NonNegativeInteger|))))
   17)
  (($ (|List| |#1|) (|List| (|List| (|NonNegativeInteger|)))) 21)
  (($ (|List| |#1|)) 23))
 (|refactorIndexes| (($ $ (|NonNegativeInteger|)) 83))
 (|product| (($ $ $) 132))
 (|oneSkeleton| (((|DirectedGraph| (|NonNegativeInteger|)) $) 99))
 (|minIndex| (((|NonNegativeInteger|) $) 62)) (|merge| (($ $ $) 88))
 (|maxIndex| (((|NonNegativeInteger|) $) 60)) (|makeDisjoint| (($ $ $) 84))
 (|link| (($ $ (|OrientedFacet|)) 79)) (|latex| (((|String|) $) NIL))
 (|homology| (((|List| (|Homology|)) $) 114))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) NIL))
 (|hash| (((|SingleInteger|) $) NIL))
 (|grade| (((|List| (|List| (|OrientedFacet|))) $) 65))
 (|fundamentalGroup| (((|GroupPresentation|) $) 102)
  (((|GroupPresentation|) $ (|Boolean|) (|Boolean|)) 101))
 (|cone| (($ $ (|NonNegativeInteger|)) 81))
 (|coerce| (((|OutputForm|) $) 144) (((|DeltaComplex| |#1|) $) 145))
 (|coHomology| (((|List| (|Homology|)) $) 116))
 (|coChain| (((|CoChainComplex| |#1|) $) 111))
 (|chain| (((|ChainComplex|) $) 108)) (|boundary| (($ $) 75))
 (|addSimplex| (($ $ (|OrientedFacet|)) 59))
 (|addImpliedFaces| (((|List| (|List| (|OrientedFacet|))) $) 73))
 (= (((|Boolean|) $ $) 140)))
SIMPC
(((|SetCategory|) . T))
(((|BasicType|) . T) ((|CoercibleTo| (|OutputForm|)) . T) ((|SetCategory|) . T))
((|constructor|
  (NIL
   "\\indented{2}{A Finite Simplicial Complex} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/} Date Created: Dec 2015 Basic Operations: star,{} link,{} cone,{} product Related packages: Related categories: Related Domains: DeltaComplex is an alternative representation \\indented{3}{which is less compact but allows edges,{} triangles,{} etc to be indexed.} Also See: AMS Classifications:"))
 (|coerce|
  (((|DeltaComplex| |#1|) $)
   "\\spad{coerce SimplicialComplex} to DeltaComplex"))
 (|coHomology|
  (((|List| (|Homology|)) $)
   "calculate cohomology using SmithNormalForm \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homology/cohomol/index.\\spad{htm}}"))
 (|homology|
  (((|List| (|Homology|)) $)
   "calculate homology using SmithNormalForm For more information: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homology/index.\\spad{htm}}"))
 (|coChain|
  (((|CoChainComplex| |#1|) $)
   "returns a matrix sequence representing the face maps in linear algebra form For more information: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/chain/cochain/index.\\spad{htm}}"))
 (|chain|
  (((|ChainComplex|) $)
   "returns a matrix sequence representing the face maps in linear algebra form For more information: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/chain/index.\\spad{htm}}"))
 (|fundamentalGroup|
  (((|GroupPresentation|) $ (|Boolean|) (|Boolean|))
   "Generates fundamental group from this simplicial complex. This works by converting to a DeltaComplex and then generating the fundamentalGroup from that. This is not the most efficient method because the conversion generates lots of higher order faceMaps which are not used. This version has options to: simplify - if \\spad{true} attempts to simplify the group presentation trace - if \\spad{true} outputs trace of simplification rules used. For more information: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homotopy/index.\\spad{htm}}")
  (((|GroupPresentation|) $)
   "Generates fundamental group from this simplicial complex. This works by converting to a DeltaComplex and then generating the fundamentalGroup from that. This is not the most efficient method because the conversion generates lots of higher order faceMaps which are not used. This will attempt to simplify the group presentation,{} if you don\\spad{'t} want this use alternative function of same name. For more information: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homotopy/index.\\spad{htm}}"))
 (|oneSkeleton|
  (((|DirectedGraph| (|NonNegativeInteger|)) $)
   "generates graph AKA 1-skeleton"))
 (|product|
  (($ $ $)
   "Forms product of two simplicial complexes. For more detailed explanation of simplex product code see: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/product/} Also see Hatcher [9]. page 277 - The simplical cross product. page 278 - The cohomology cross product. Returns list,{} each entry is a 'lattice path' from (0,{} 0) to (\\spad{x},{} \\spad{y}) where \\spad{x} is number of entries in sa and \\spad{y} is number of entries in \\spad{sb}."))
 (|merge| (($ $ $) "Forms union of two simplicial complexes."))
 (|simplicialJoin|
  (($ $ $ (|Boolean|))
   "Forms join of two simplicial complexes. The join \\spad{S*T} of two simplicial sets \\spad{S} and \\spad{T} is a new simplicial set that may geometrically be thought of as a cone over \\spad{T} with tip of shape \\spad{S}. simplicialJoin is commutative and associative. For more information: \\url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/join/index.\\spad{htm}}"))
 (|makeDisjoint|
  (($ $ $)
   "If index numbers of \\spad{'b'} overlap with index numbers of 'a' then refactor \\spad{'b'} so that it does not overlap."))
 (|refactorIndexes|
  (($ $ (|NonNegativeInteger|))
   "add \\spad{'n'} to all indexes without changing the structure of this simplicial complex."))
 (|cone|
  (($ $ (|NonNegativeInteger|))
   "The 'cone' of a simplicial complex is formed by adding the vertex to every facet. 'vertex' should not already be included in existing faces,{} this is not checked and so will lead to simplexes with duplicate vertices."))
 (|link|
  (($ $ (|OrientedFacet|))
   "The 'link' of a simplicial complex and a vertex contains the boundary of the simplexes of \\spad{s} which include simplex."))
 (|star|
  (($ $ (|OrientedFacet|))
   "The 'star' of a simplicial complex and a facet contains only the faces of \\spad{s} which include simplex."))
 (|boundary|
  (($ $)
   "Step down to the next lower dimension,{} this is like hollowing out the complex. It takes the highest dimension entries and replaces them with their boundaries,{} cancelling out where it can."))
 (|addImpliedFaces|
  (((|List| (|List| (|OrientedFacet|))) $)
   "a function to take a set of faces and add those that are implied by the simplecicalComplex conventions (if they don\\spad{'t} already exist). For example,{} if the input is a triangle ((1,{} 2,{} 3)) then we would add: its points ((1),{} (2),{} (3)). and its edges ((1,{} 2),{} (1,{} 3),{} (2,{} 3))."))
 (|sort| (($ $) "sort"))
 (|grade|
  (((|List| (|List| (|OrientedFacet|))) $)
   "a function to grade simplexes according to their lengths. This nests the lists according to their length. Verticies,{} edges,{} trianges and so on. The list is returned in reverse order,{} that is,{} it starts at highest grade and works down."))
 (|minIndex| (((|NonNegativeInteger|) $) "find the minimum index."))
 (|maxIndex| (((|NonNegativeInteger|) $) "find the maximum index."))
 (|addSimplex|
  (($ $ (|OrientedFacet|))
   "Add a facet to this simplex If the facet is also in the list then,{} dont append,{} instead change the multiplier. Used by boundary function"))
 (|simplicialComplexIfCan|
  (((|Union| $ "failed") (|DeltaComplex| |#1|))
   "construct FiniteSimplicialComplex from DeltaComplex. If there are 'implied' loops,{} such as facets with multiple entries with the same index,{} then this function may fail.")
  (((|Union| $ "failed") (|DeltaComplex| |#1|) (|Boolean|))
   "construct FiniteSimplicialComplex from DeltaComplex with trace. If there are 'implied' loops,{} such as facets with multiple entries with the same index,{} then this function may fail."))
 (|simplicialComplex| (($ (|List| |#1|)) "construct empty simplex")
  (($ (|List| |#1|) (|List| (|List| (|NonNegativeInteger|))))
   "constructor where the simplices are supplied")
  (($ (|List| |#1|) (|NonNegativeInteger|)
    (|List| (|List| (|NonNegativeInteger|))))
   "constructor where the simplices are supplied")))
(("documentation" 0 10579) ("ancestors" 0 10498) ("parents" 0 10474)
 ("abbreviation" 0 10468) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 8899) ("modemaps" 0 4084) ("sourceFile" 0 4047)
 ("constructorCategory" 0 2144) ("constructorModemap" 0 60)
 ("constructorKind" 0 51) ("constructorForm" 0 20))