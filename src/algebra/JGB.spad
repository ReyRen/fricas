)abbrev package JGB JetGroebner
++ Description:
++  \spadtype{JetGroebner} provides a procedure to compute Groebner bases for
++  arbitrary domains of jet polynomials. Two internal procedures transform
++  to and from \spadtype{DistributedJetBundlePolynomial} where the actual
++  computation is done. The argument \spad{LJV} contains all jet variables
++  effectively occurring in the polynomials. The ordering is determined by
++  the ordering in \spad{P}.

JetGroebner(R, JB, LJV, P, E) : Cat == Def where

  L    ==> List
  NNI  ==> NonNegativeInteger
  JBC  ==> JetBundleCategory
  JBFC ==> JetBundleFunctionCategory JB
  DPC  ==> DirectProductCategory(#LJV, NNI)
  IE   ==> IndexedExponents JB
  PC   ==> PolynomialCategory(R, IE, JB)
  DJBP ==> DistributedJetBundlePolynomial(R, JB, LJV, E)


  R   : GcdDomain
  E   : DPC
  JB  : JBC
  LJV : L JB
  P   : Join(JBFC, PC)


  Cat ==> with

    groebner : L P -> L P
      ++ \spad{groebner(lp)} computes a Groebner basis for the ideal
      ++ generated by the polynomials \spad{lp}.


  Def ==> add

    convert1(p : P) : DJBP ==
        (xx := mainVariable p) case "failed" =>
            cc : R := retract p
            cc::DJBP
        x := xx::JB
        not member?(x, LJV) => error "illegal jet variable"
        up := univariate(p, x)
        res : DJBP := 0
        while not zero? up repeat
            lcup := leadingCoefficient up
            clcup := convert1 lcup
            m := monomial(clcup, x, degree up)
            res := res + monomial(convert1 leadingCoefficient up, _
                                  x, degree up)
            up := reductum up
        res

    convert2(p : DJBP) : P ==
        (xx := mainVariable p) case "failed" =>
            cc : R := retract p
            cc::P
        x := xx::JB
        up := univariate(p, x)
        res : P := 0
        while not zero? up repeat
            res := res + monomial(convert2 leadingCoefficient up, _
                                  x, degree up)
            up := reductum up
        res

    groebner(lp : L P) : L P ==
        nlp : L DJBP := [convert1 p  for p in lp]
        gb := groebner(nlp)$DJBP
        [convert2 dp  for dp in gb]


)if false
-- Does not compile
-- )abbrev domain JBQLF JetBundleQuasiLinearFunction
++ Description:
++  \spadtype{JetBundleQuasiLinearFunction} implements non-linear functions
++  over a jet bundle. It tries to represent them as quasi-linear functions,
++  i.e. as functions which are linear in the highest derivatives. All
++  operations try to exploit and to maintain this quasi-linear structure.
++  Truly non-linear expression must be of the argument domain \spad{D}

JetBundleQuasiLinearFunction(JB, D) : Cat == Def where

  V    ==> Vector
  M    ==> Matrix
  Sy   ==> Symbol
  PI   ==> PositiveInteger
  NNI  ==> NonNegativeInteger
  I    ==> Integer
  B    ==> Boolean
  L    ==> List
  JBC  ==> JetBundleCategory
  JBE  ==> JetBundleExpression JB
  JBFC ==> JetBundleFunctionCategory JB
  MCF  ==> MatrixCategoryFunctions2(%, V %, V %, M %, D, V D, V D, M D)
  MCFD ==> MatrixCategoryFunctions2(D, V D, V D, M D, %, V %, V %, M %)
  OUT  ==> OutputForm
  SEM  ==> SparseEchelonMatrix(JB, %)
  SEMD ==> SparseEchelonMatrix(JB, D)

  SIMPREC ==> Record(Sys : L %, JM : SEM, Depend : Union("failed", L L NNI))

  Const   ==> "Const"::Sy
  Indep   ==> "Indep"::Sy
  Dep     ==> "Dep"::Sy
  Deriv   ==> "Deriv"::Sy


  JB : JBC
  D  : Join(JBFC, CommutativeRing)


  Cat ==> Join(JBFC, Module D, CoercibleTo D) with

    nonlinear? : % -> B
      ++ \spad{nonlinear?(q)} checks whether \spad{q} is a truly non-linear
      ++ function, i.e. not quasi-linear.

    convert : D -> %
      ++ \spad{convert(q)} tries to write an element of \spad{D} as a
      ++ quasi-linear function.

    if D has Field then
      Field


  Def ==> add

    -- -------------- --
    -- Representation --
    -- -------------- --

    Rep := Record(hCoeff : L D, hJV : L JB, low : D, ord : NNI, nonl? : B)
      -- ord gives the order of the function which is linear in the
      -- jet variables hJV of this order. hCoeff contains the corresponding
      -- coefficients; low the lower order terms. hJV is always ordered.
      -- nonl? is false for quasi-linear functions.


    nonlinear?(q : %) : B == q.nonl?


    order(q : %) : NNI == q.ord


    coerce(jv : JB) : % == [[1], [jv], 0, order(jv), false]


    coerce(q : %) : D ==
        nonlinear? q => q.low
        q.low + reduce("+", [c *$D jv::D  for c in q.hCoeff  for jv in q.hJV], 0)


    monom(c : D, jv : JB) : OUT ==
        one?(c)$D => jv::OUT
        one? jv => c::OUT
        c::OUT * jv::OUT


    coerce(q : %) : OUT ==
        zero? q => 0$NNI::OUT
        nonlinear? q => q::D::OUT
        res : OUT := monom(first(q.hCoeff), first(q.hJV))
        for c in rest q.hCoeff  for jv in rest q.hJV repeat
            res := res + monom(c, jv)
        zero? q.low => res
        res + (q.low)::OUT


    convert(ex : D) : % ==
        oe := order(ex)$D
        JV := jetVariables(ex)$D
        empty? JV => [[ex], [1$JB], 0, 0, false]

        resJV : L JB := empty
        resCo : L D := empty
        l := ex
        for jv in JV  while order(jv) = oe repeat
            c := differentiate(l, jv)$D
            if order(c)$D < oe then
                resJV := cons(jv, resJV)
                resCo := cons(c, resCo)
                l := l - c*jv::D
            else    -- not quasi-linear!
                return [[], [], ex, oe, true]

        [resCo, resJV, l, oe, false]


    numerator(q : %) : % ==
        nonlinear? q => convert numerator(q.low)$D
        q


    denominator(q : %) : % ==
        nonlinear? q => convert denominator(q.low)$D
        1


    -- ----------- --
    -- Arithmetics --
    -- ----------- --

    q1 : % = q2 : % ==
        nonlinear? q1 =>
            nonlinear? q2 => q1.low =$D q2.low
            q1.low =$D q2::D
        nonlinear? q2 => q2.low =$D q1::D
        q1.ord = q2.ord =>
            (q1.hJV = q2.hJV) and (q1.hCoeff = q2.hCoeff) and (q1.low = q2.low)
        false


    0 : % == [[0$D], [1$JB], 0$D, 0, false]


    1 : % == [[1$D], [1$JB], 0$D, 0, false]


    zero?(q : %) : B ==
        zero?(q.low)$D =>
            empty?(q.hJV) or ((first(q.hJV) = 1$JB) and zero?(first q.hCoeff)$D)
        false


    one?(q : %) : B ==
        zero?(q.low)$D =>
            empty?(q.hJV) => false
            (first(q.hJV) = 1$JB) and one?(first q.hCoeff)$D
        one?(q.low)$D and empty? q.hJV


    - q : % == [[-$D c  for c in q.hCoeff], q.hJV, -$D q.low, q.ord, q.nonl?]


    q1 : % + q2 : % ==
        nonlinear?(q1) or nonlinear?(q2) => convert(q1::D +$D q2::D)
        o1 := order q1
        o2 := order q2
        o1 > o2 => [q1.hCoeff, q1.hJV, q1.low +$D q2::D, o1, false]
        o2 > o1 => [q2.hCoeff, q2.hJV, q2.low +$D q1::D, o2, false]

        resC : L D := empty
        resJ : L JB := empty
        lc2 := copy q2.hCoeff
        lj2 := copy q2.hJV

        for c1 in q1.hCoeff  for j1 in q1.hJV  repeat
            while not empty?(lj2) and first(lj2) > j1 repeat
                resC := cons(first lc2, resC)
                resJ := cons(first lj2, resJ)
                lc2 := rest lc2
                lj2 := rest lj2
            if not empty?(lj2) and first(lj2) = j1 then
                sum := c1 +$D first lc2
                if not zero? sum then
                    resC := cons(sum, resC)
                    resJ := cons(j1, resJ)
                lc2 := rest lc2
                lj2 := rest lj2
            else
                resC := cons(c1, resC)
                resJ := cons(j1, resJ)
        resC := concat!(reverse! resC, lc2)
        resJ := concat!(reverse! resJ, lj2)

        empty? resJ => convert(q1.low +$D q2.low)
        [resC, resJ, q1.low +$D q2.low, o1, false]


    i : I * q : % ==
        zero? i or zero? q => 0
        [[i *$D c  for c in q.hCoeff], q.hJV, i *$D q.low, q.ord, q.nonl?]


    ex : D * q : % ==
        zero? ex or zero? q => 0
        oe := order ex
        oq := order q
        oe > oq =>
            qx := convert ex
            nonlinear? qx => [[], [], ex *$D q::D, oe, true]
            qe := q::D
            [[qe *$D c  for c in qx.hCoeff], qx.hJV, qe *$D qx.low, oe, false]
        oe = oq => [[], [], ex *$D q::D, oe, true]
        [[ex *$D c  for c in q.hCoeff], q.hJV, ex *$D q.low, oq, q.nonl?]


    q1 : % * q2 : % ==
        o1 := order q1
        o2 := order q2
        o1 > o2 => q2::D * q1
        o2 > o1 => q1::D * q2
        [[], [], q1::D *$D q2::D, o1, true]


    recip(q : %) : Union(%, "failed") ==
        r := recip(q::D)$D
        r case "failed" => "failed"
        convert(r::D)


    if D has Field then

        q1 : % / q2 : % == convert(q1::D /$D q2::D)


    -- -------------- --
    -- JBFC Functions --
    -- -------------- --

    jetVariables(q : %) : L JB ==
        nonlinear? q => jetVariables(q.low)$D
        jetC : L L JB := [jetVariables(c)$D  for c in q.hCoeff]
        res : L JB := reduce(setUnion, jetC, empty)
        one? first q.hJV => sort(">", setUnion(res, jetVariables(q.low)$D))
        sort(">", append(q.hJV, setUnion(res, jetVariables(q.low)$D)))


    differentiate(q : %, s : Sy) : % ==
        dl := differentiate(q.low, s)$D
        nonlinear? q => convert dl
        resC : L D := empty
        resJ : L JB := empty
        for c in q.hCoeff  for jv in q.hJV repeat
            dc := differentiate(c, s)$D
            if not zero? dc then
                resC := cons(dc, resC)
                resJ := cons(jv, resJ)
        empty? resJ => convert dl
        [reverse! resC, reverse! resJ, dl, q.ord, false]


    differentiate(q : %, jv : JB) : % ==
        dl := differentiate(q.low, jv)$D
        nonlinear? q => convert dl
        oj := order jv
        oq := order q
        oj > oq => 0
        oj = oq =>
            pos := position(jv, q.hJV)
            pos < minIndex(q.hJV) => 0
            convert qelt(q.hCoeff, pos)
        resC : L D := empty
        resJ : L JB := empty
        for c in q.hCoeff  for j in q.hJV repeat
            dc := differentiate(c, jv)$D
            if not zero? dc then
                resC := cons(dc, resC)
                resJ := cons(j, resJ)
        empty? resJ => convert dl
        [reverse! resC, reverse! resJ, dl, oq, false]

    SEM_to_SEMD(jm : SEM) : SEMD == error "unimplemented"

    dimension(sys : L %, jm : SEM, q : NNI) : NNI ==
        -- Assumes that sys is simplified and that no equation is of
        -- higher order than q.
        reduce("or", [nonlinear? eq  for eq in sys], false) =>
            sysd : L D := [eq::D  for eq in sys]
            -- jmd : M D := map(coerce, jm.Mat)$MCF
            -- dimension(sysd, [jmd, jm.Ind, jm.Echelon?], q)$D
            jmd := SEM_to_SEMD(jm)
            dimension(sysd, jmd, q)$D
        (dimJ(q)$JB - #sys)::NNI


    orderDim(sys : L %, jm : SEM, q : NNI) : NNI ==
        -- Assumes that sys is simplified and that all equations are of order q.
        reduce("or", [nonlinear? eq  for eq in sys], false) =>
            sysd : L D := [eq::D  for eq in sys]
            -- jmd : M D := map(coerce, jm.Mat)$MCF
            -- orderDim(sysd, [jmd, jm.Ind, jm.Echelon?], q)$D
            jmd := SEM_to_SEMD(jm)
            orderDim(sysd, jmd, q)$D
        (dimS(q)$JB - #sys)::NNI

    -- -------------- --
    -- Simplification --
    -- -------------- --

    leadingDer(q : %) : JB ==
        nonlinear? q => leadingDer(q.low)$D
        first q.hJV


    freeOf?(q : %, jv : JB) : B ==
        oj := order jv
        oq := order q
        oj > oq => true
        nonlinear? q => freeOf?(q.low, jv)$D
        oj = oq => not member?(jv, q.hJV)
        freeOf?(q.low, jv) and _
            reduce("and", [freeOf?(c, jv)$D  for c in q.hCoeff], true)


    solveFor(q : %, jv : JB) : Union(%, "failed") ==
        -- solves only for highest-order derivatives
        -- if they have an invertible coefficient
        nonlinear? q =>
            s := solveFor(q.low, jv)$D
            s case D => convert s
            "failed"
        pos := position(jv, q.hJV)
        pos < minIndex(q.hJV) => "failed"
        dr := recip(q.hCoeff.pos)$D
        dr case "failed" => "failed"
        d : D := - (dr::D)
        #q.hJV = 1 => convert(d *$D q.low)
        [[d *$D c  for c in delete(q.hCoeff, pos)], delete(q.hJV, pos), _
         d *$D q.low, q.ord, false]


    subst(q : %, jv : JB, exp : %) : % ==
        -- lazy-bone!!!
        convert subst(q::D, jv, exp::D)$D


    ground(q : %) : % ==
        -- local function; returns lower order part
        convert q.low

)if false
    rewrite(jm : SEM) : L % ==
        -- local function; transforms a matrix into a system
        -- assumes all jet variables in jm.Ind are of the same order and
        -- that jm.Mat is in row echelon form
        res : L % := empty
        finished? : B := false
        minR := minRowIndex jm.Mat; maxR := maxRowIndex jm.Mat
        minC := minColIndex jm.Mat; maxC := maxColIndex jm.Mat

        o := order first jm.Ind
        col := minC
        JV := jm.Ind
        for i in minR..maxR  until finished? repeat
            resC : L D := empty
            resJ : L JB := empty
            for jv in JV  for j in col..maxC _
                    while zero? qelt(jm.Mat, i, j) repeat
                col := col + 1
                JV := rest JV
            for jv in JV  for j in col..maxC repeat
                d := qelt(jm.Mat, i, j)::D
                if not zero? d then
                    resC := cons(d, resC)
                    resJ := cons(jv, resJ)
            finished? := empty? resJ
            if not finished? then
                res := cons([reverse! resC, reverse! resJ, 0$D, o, true], res)

        reverse! res
)endif

    SEMD_to_SEM(jmd : SEMD) : SEM == error "unimplemented"

    M_to_SEM(m: M %) : SEM == error "unimplemented"

    simplify(sys : L %, jm : SEM) : SIMPREC ==
        -- It is assumed that the columns of the Jacobi matrix are ordered.
        -- If sys contains truly non-linear functions, the simplify of D is
        -- called. Otherwise the highest-order part of sys is made triangular.
        print("simplify")$OUT
        reduce("or", [nonlinear? eq  for eq in sys], false) =>
            sysd : L D := [eq::D  for eq in sys]
            -- jmd : M D := map(coerce, jm.Mat)$MCF
            -- tmp := simplify(sysd, [jmd, jm.Ind, jm.Echelon?])$D
            jmd := SEM_to_SEMD(jm)
            tmp := simplify(sysd, jmd)$D
            nsys : L % := [convert eq  for eq in tmp.Sys]
            -- njm : M % := map(convert, tmp.JM.Mat)$MCFD
            njm := SEMD_to_SEM(tmp.JM)
            [nsys, njm, tmp.Depend]
        print("quasi-linear system")$OUT
        -- jm.Echelon? => [sys, jm, [[i::NNI]  for i in 1..#sys]]
        -- print("noch nicht in Dreiecksform")$OUT

        q : NNI := 0
        for eq in sys repeat
            q := max(q, order eq)

        -- sort out all equations of lower order
        fsys : L % := empty
        fdep : L L NNI := empty
        ssys : L % := empty
        sind : V NNI := new(#sys, 0)
        lsjm : L L % := empty
        lfjm : L L % := empty
        k : I := 0
        jmm := jm::M(%)
        for eq in reverse sys  for i in #sys..1 by -1 repeat
            rjm : V % := row(jmm, i)
            if order(eq) < q then
                fsys := cons(eq, fsys)
                fdep := cons([i::NNI], fdep)
                lfjm := cons(entries rjm, lfjm)
            else
                k := k+1
                ssys := cons(eq, ssys)
                qsetelt!(sind, k, i::NNI)
                lsjm := cons(entries rjm, lsjm)
        zero? k => [sys, jm, fdep]
        sjm : M % := matrix lsjm

        -- split Jacobi matrix in columns for p of highest order
        -- and for remaining jet variables
        i1 : I := minRowIndex sjm
        i2 : I := maxRowIndex sjm
        j1 : I := minColIndex sjm
        j2 : I := maxColIndex sjm
        js : I := 0
        JV : L JB := allIndices(jm)
        for jv in allIndices(jm)  while order(jv) = q repeat
            js := js + 1
            JV := rest JV
        mat1 : M % := subMatrix(sjm, i1, i2, j1, js + j1 - 1)
        print(message("Symbol"))$OUT
        print(mat1::OUT)$OUT
        print(assign(message("JV"), JV::OUT))$OUT
        if j1 + js <= j2 then
            mat2 : M % := subMatrix(sjm, i1, i2, js + j1, j2)

        -- make symbol triangular
        -- (non-linear part must be computed separately)
        RRec := rowEchelon(M_to_SEM(mat1))$SEM
        Trafo := RRec.Lt
        minR := minRowIndex Trafo
        maxR := maxRowIndex Trafo
        qlinSys := rewrite [RRec.R, first(jm.Ind, js::NNI), true]$MATREC
        groundSys := [ground eq  for eq in sys]
        redGSys : L % := empty
        redInd : L I := empty
        for g in groundSys  for j in minR.. repeat
            if not zero? g then
                redGSys := cons(g, redGSys)
                redInd := cons(j, redInd)
        if empty? redInd then
            newEq := qlinSys
        else
            newEq : L % := empty
            for eq in qlinSys  for i in minR.. repeat
                neq := eq
                for g in redGSys  for j in redInd repeat
                    neq := neq + g*qelt(Trafo, i, j)
                newEq := cons(neq, newEq)
            if #qlinSys < nrows(Trafo) then
                for i in (#qlinSys + minR)..maxR repeat
                    neq : % := 0
                    for g in redGSys  for j in redInd repeat
                        neq := neq + g*qelt(Trafo, i, j)
                    newEq := cons(neq, newEq)
            newEq := reverse! newEq

        -- complete Jacobi matrix
        if j1 + js <= j2 then
            NMat := horizConcat(RRec.R, Trafo*mat2)
        else
            NMat := RRec.R
        i2 := i2 + #newEq - #sys
        NMat := subMatrix(NMat, i1, i2, j1, j2)

        -- adjust Jacobi matrix for non-constant entries in trafo
        -- and build dependency list
        dep : L L NNI := empty
        for j in maxIndex(newEq)..minIndex(newEq) by -1 repeat
            depj : L NNI := empty
            for k in maxR..minR by -1 repeat
                t : % := qelt(Trafo, j, k)
                kb := k + minIndex(sys) - minR
                if not zero? t then
                    depj := _
                        cons((qelt(sind, k) - minR + minIndex(depj))::NNI, depj)
                    for jv in JV  for pos in j+1.. repeat
                      if not freeOf?(t, jv) then
                          qsetelt!(NMat, j, pos, qelt(NMat, j, pos) + _
                                     qelt(sys, kb)*differentiate(t, jv))
            dep := cons(depj, dep)

        empty? lfjm => [newEq, [NMat, jm.Ind, true], dep]
        fjm : M % := matrix lfjm
        [concat!(newEq, fsys), [vertConcat(NMat, fjm), jm.Ind, false], _
         concat!(dep, fdep)]


    simpOne(sys : L %) : L % ==
        res : L % := empty
        for eq in sys repeat
            if nonlinear? eq then
                res := cons(convert first simpOne [eq.low], res)
            else if (one?(#eq.hJV) and zero?(eq.low)$D) then
                res := cons([ [1$D], eq.hJV, 0$D, eq.ord, false], res)
            else
                res := cons(eq, res)
        res
)endif
