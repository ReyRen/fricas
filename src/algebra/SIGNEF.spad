)abbrev package SIGNEF ElementaryFunctionSign
++ Author: Manuel Bronstein
++ Date Created: 25 Aug 1989
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: elementary function, sign
++ Examples:
++ References:
++ Description:
++   This package provides functions to determine the sign of an
++   elementary function around a point or infinity.
ElementaryFunctionSign(R, F) : Exports == Implementation where
  R : Join(IntegralDomain, Comparable, RetractableTo Integer, _
           LinearlyExplicitOver Integer, GcdDomain)
  F : Join(AlgebraicallyClosedField, TranscendentalFunctionCategory, _
            FunctionSpace R)

  N  ==> NonNegativeInteger
  Z  ==> Integer
  SY ==> Symbol
  RF ==> Fraction Polynomial R
  ORF ==> OrderedCompletion RF
  OFE ==> OrderedCompletion F
  K  ==> Kernel F
  P  ==> SparseMultivariatePolynomial(R, K)
  U  ==> Union(Z, "failed")
  FS2 ==> FunctionSpaceFunctions2

  Exports ==> with
    sign : F -> U
      ++ sign(f) returns 1 if f is always non-negative; returns -1 is f is
      ++ always non-positive; returns 0 if f is always 0; returns "failed"
      ++ if the sign of f varies or can't be determined.
    sign : (F, SY, OFE) -> U
      ++ sign(f, x, a) returns the sign of f as x nears \spad{a}, from both
      ++ sides if \spad{a} is finite.
    sign : (F, SY, F, String) -> U
      ++ sign(f, x, a, s) returns the sign of f as x nears \spad{a} from below
      ++ if s is "left", or above if s is "right".

  Implementation ==> add
    import from ToolsForSign R
    import from RationalFunctionSign(R)
    import from PowerSeriesLimitPackage(R, F)
    import from TrigonometricManipulations(R, F)

    smpsign : P -> U
    sqfrSign : P -> U
    termSign : P -> U
    kerSign : K -> U
    listSign : (List P, Z) -> U
    insign  : (F, SY, OFE, N) -> U
    psign   : (F, SY, F, String, N) -> U
    ofesign : OFE -> U
    overRF  : OFE -> Union(ORF, "failed")

    sign(f, x, a) ==
      not real? f => "failed"
      insign(f, x, a, 0)

    sign(f, x, a, st) ==
      not real? f => "failed"
      psign(f, x, a, st, 0)

    sign f ==
      not real? f => "failed"
      -- ATM sign in RF is weaker than smpsign.
      -- (u := retractIfCan(f)@Union(RF,"failed")) case RF => sign(u::RF)
      (un := smpsign numer f) case Z and (ud := smpsign denom f) case Z =>
        un::Z * ud::Z
      --abort if there are any variables
      not empty? variables f => "failed"
      -- abort in the presence of algebraic numbers
      member?(coerce("rootOf")::Symbol,map(name,operators f)$ListFunctions2(BasicOperator,Symbol)) => "failed"
      -- In the last resort try interval evaluation where feasible.
      if R has ConvertibleTo Float then
        import from Interval(Float)
        import from Expression(Interval Float)
        mapfun : (R -> Interval(Float)) := z1 +-> interval(convert(z1)$R)
        f2u : Union(Expression(Interval(Float)), "failed") :=
            trappedSpadEval(map(mapfun, f)$FS2(R, F, Interval(Float),
                              Expression(Interval(Float))))$Lisp
        f2u case "failed" => "failed"
        f2 := f2u::Expression(Interval(Float))
        r : Union(Interval(Float),"failed") := retractIfCan f2
        if r case "failed" then  return "failed"
        negative? r => return(-1)
        positive? r => return 1
        zero? r => return 0
        "failed"
      "failed"

    overRF a ==
      (n := whatInfinity a) = 0 =>
        (u := retractIfCan(retract(a)@F)@Union(RF,"failed")) _
               case "failed" => "failed"
        u::RF::ORF
      n > 0 => plusInfinity()$ORF
      minusInfinity()$ORF

    ofesign a ==
      (n := whatInfinity a) ~= 0 => convert(n)@Z
      sign(retract(a)@F)

    insign(f, x, a, m) ==
      m > 10 => "failed"                 -- avoid infinite loops for now
      (uf := retractIfCan(f)@Union(RF,"failed")) case RF and
                   (ua := overRF a) case ORF => sign(uf::RF, x, ua::ORF)
      eq : Equation OFE := equation(x :: F :: OFE, a)
      (u := limit(f,eq)) case "failed" => "failed"
      u case OFE =>
        (n := whatInfinity(u::OFE)) ~= 0 => convert(n)@Z
        (v := retract(u::OFE)@F) = 0 =>
          (s := insign(differentiate(f, x), x, a, m + 1)) case "failed"
                                                             => "failed"
          - s::Z * n
        sign v
      (u.leftHandLimit case "failed") or
         (u.rightHandLimit case "failed") => "failed"
      (ul := ofesign(u.leftHandLimit::OFE))  case "failed" => "failed"
      (ur := ofesign(u.rightHandLimit::OFE)) case "failed" => "failed"
      (ul::Z) = (ur::Z) => ul
      "failed"

    psign(f, x, a, st, m) ==
      m > 10 => "failed"                 -- avoid infinite loops for now
      f = 0 => 0
      (uf := retractIfCan(f)@Union(RF,"failed")) case RF and
           (ua := retractIfCan(a)@Union(RF,"failed")) case RF =>
            sign(uf::RF, x, ua::RF, st)
      eq : Equation F := equation(x :: F, a)
      (u := limit(f,eq,st)) case "failed" => "failed"
      u case OFE =>
        (n := whatInfinity(u::OFE)) ~= 0 => convert(n)@Z
        (v := retract(u::OFE)@F) = 0 =>
          (s := psign(differentiate(f, x), x, a, st, m + 1)) case "failed" =>
            "failed"
          direction(st) * s::Z
        sign v

    smpsign2(p : P) : U ==
      (r := retractIfCan(p)@Union(R,"failed")) case R => sign(r::R)
      (u := sign(retract(unit(s := squareFree p))@R)) case "failed" =>
        "failed"
      ans := u::Z
      for term in factorList s | odd?(term.exponent) repeat
        (u := sqfrSign(term.factor)) case "failed" => return "failed"
        ans := ans * u::Z
      ans

    DFINTTLS ==> DefiniteIntegrationTools(R, F)
    sas := create()$SingletonAsOrderedSet

    smpsign p ==
        resu := smpsign2(p)
        resu case Z => resu
        vl : List(K) := variables(p)
        #vl = 1 =>
            k := first(vl)
            s0 := kerSign(k)
            a : OFE := minusInfinity()
            b : OFE := plusInfinity()
            x0 : F := 0
            if s0 case Z then
                if s0 = 1 then
                    a := 0$F::OFE
                if s0 = -1 then
                    b := 0$F::OFE
            if is?(k, 'atan) then
                a := (a = 0$F::OFE => a; (-(1$F))::OFE)
                b := (b = 0$F::OFE => b; (1$F)::OFE)
            up := map(coerce@(R -> F), univariate(p)
                     )$SparseUnivariatePolynomialFunctions2(R, F)
            zu := checkForZero(up, a, b, true)$DFINTTLS
            zu case "failed" => "failed"
            (zu::Boolean) => "failed"
            sign(retract(eval(up, sas, x0))@F)
        "failed"

    sqfrSign p ==
      (u := termSign first(l := monomials p)) case "failed" => "failed"
      listSign(rest l, u::Z)

    listSign(l, s) ==
      for term in l repeat
        (u := termSign term) case "failed" => return "failed"
        not(s = u::Z) => return "failed"
      s

    termSign term ==
      (us := sign leadingCoefficient term) case "failed" => "failed"
      for var in (lv := variables term) repeat
        odd? degree(term, var) =>
          empty? rest lv and (vs := kerSign first lv) case Z =>
                                                   return(us::Z * vs::Z)
          return "failed"
      us::Z

    kerSign k ==
      op := operator k
      is?(op, 'pi) or is?(op, 'exp) or
                           is?(op, 'cosh) or is?(op, 'sech) => 1
      empty?(arg := argument k) => "failed"
      (s := sign first arg) case "failed" =>
        is?(op, 'nthRoot) =>
          even?(retract(second arg)@Z) => 1
          "failed"
        "failed"
      is?(op, 'log) =>
        s::Z < 0 => "failed"
        sign(first arg - 1)
      is?(op, 'tanh) or is?(op, 'sinh) or
                     is?(op, 'csch) or is?(op, 'coth) => s
      is?(op, 'atan) or is?(op, 'Si) or is?(op, 'fresnelS)
             or is?(op, 'fresnelC) => s
      is?(op, 'nthRoot) =>
        even?(retract(second arg)@Z) =>
          s::Z < 0 => "failed"
          s
        s
      "failed"

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
