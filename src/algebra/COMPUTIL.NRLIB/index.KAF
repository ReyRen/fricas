3095                (|compUtil| UT)
|package|
(((|compUtil| |#1|)
  (CATEGORY |package|
   (SIGNATURE |coerce| ((|Lambda| |#1|) (|SKICombinators| |#1|)))
   (SIGNATURE |coerce| ((|SKICombinators| |#1|) (|Lambda| |#1|)))
   (SIGNATURE |coerce| ((|ILogic|) (|SKICombinators| |#1|))))
  (|VarCat|))
 (T |compUtil|))
(CATEGORY |package|
 (SIGNATURE |coerce| ((|Lambda| |#1|) (|SKICombinators| |#1|)))
 (SIGNATURE |coerce| ((|SKICombinators| |#1|) (|Lambda| |#1|)))
 (SIGNATURE |coerce| ((|ILogic|) (|SKICombinators| |#1|))))
"/git/fricas/src/algebra/COMPUTIL.spad"
((|coerce| (*1 *2 *3)
           (AND (|isDomain| *3 (|SKICombinators| *4))
                (|ofCategory| *4 (|VarCat|)) (|isDomain| *2 (|ILogic|))
                (|isDomain| *1 (|compUtil| *4))))
 (|coerce| (*1 *2 *3)
           (AND (|isDomain| *3 (|Lambda| *4)) (|ofCategory| *4 (|VarCat|))
                (|isDomain| *2 (|SKICombinators| *4))
                (|isDomain| *1 (|compUtil| *4))))
 (|coerce| (*1 *2 *3)
           (AND (|isDomain| *3 (|SKICombinators| *4))
                (|ofCategory| *4 (|VarCat|)) (|isDomain| *2 (|Lambda| *4))
                (|isDomain| *1 (|compUtil| *4)))))
((|coerce| (((|ILogic|) (|SKICombinators| |#1|)) 58)
           (((|SKICombinators| |#1|) (|Lambda| |#1|)) 49)
           (((|Lambda| |#1|) (|SKICombinators| |#1|)) 33)))
COMPUTIL
((|constructor| (NIL "macro to simplify output"))
 (|coerce|
  (((|ILogic|) (|SKICombinators| |#1|))
   "\\spad{coerce combinators} to intuitionistic logic this is known as the Curry-Howard isomorphism it uses the following rules: rule SI1: Ski[Kab] \\spad{=>} a \\spad{->} (\\spad{b} \\spad{->} a),{} rule SI2: Ski[Sabc] \\spad{=>} (a \\spad{->} (\\spad{b} \\spad{->} \\spad{c})) \\spad{->} ((a \\spad{->} \\spad{b}) \\spad{->} (a \\spad{->} \\spad{c})),{} rule SI3: Ski[a a-\\spad{>b}] \\spad{=>} \\spad{b} the last rule is function application (modus ponens)")
  (((|SKICombinators| |#1|) (|Lambda| |#1|))
   "\\spad{coerce Lambda} term to SKI combinators. this process is known as abstraction elimination. it is done by applying the following rules until all lambda terms have been eliminated. rule LS1: Lam[\\spad{x}] \\spad{=>} \\spad{x} rule LS2: Lam[(\\spad{E1} \\spad{E2})] \\spad{=>} (Lam[\\spad{E1}] Lam[\\spad{E2}]) rule LS3: Lam[\\spad{\\x}.\\spad{E}] \\spad{=>} (\\spad{K} Lam[\\spad{E}]) (if \\spad{x} does not occur free in \\spad{E}) rule LS4: Lam[\\spad{\\x}.\\spad{x}] \\spad{=>} \\spad{I} rule LS5: Lam[\\spad{\\x}.\\y.\\spad{E}] \\spad{=>} Lam[\\spad{\\x}.Lam[\\y.\\spad{E}]] (if \\spad{x} occurs free in \\spad{E}) rule LS6: Lam[\\spad{\\x}.(\\spad{E1} \\spad{E2})] \\spad{=>} (\\spad{S} Lam[\\spad{\\x}.\\spad{E1}] Lam[\\spad{\\x}.\\spad{E2}])")
  (((|Lambda| |#1|) (|SKICombinators| |#1|))
   "\\spad{coerce SKI} combinators to Lambda term. this conversion is done by applying the following rules rule SL1: Ski[\\spad{I}] = \\spad{\\x}.0 rule SL2: Ski[\\spad{K}] = \\spad{\\x}.\\y.1 rule SL3: Ski[\\spad{S}] = \\spad{\\x}.\\y.\\spad{\\z}.(2 0 (1 0)) rule SL4: Ski[(\\spad{E1} \\spad{E2})] = (Ski[\\spad{E1}] Ski[\\spad{E2}])")))
(("documentation" 0 1342) ("ancestors" 0 NIL) ("parents" 0 NIL)
 ("abbreviation" 0 1333) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 1162) ("modemaps" 0 561) ("sourceFile" 0 521)
 ("constructorCategory" 0 313) ("constructorModemap" 0 46)
 ("constructorKind" 0 36) ("constructorForm" 0 20))