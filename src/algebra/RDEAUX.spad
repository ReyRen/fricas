)abbrev package RDEAUX RDEaux
RDEaux(F) : Exports == Implementation where
  F : Field
  Z ==> Integer
  UP  ==> SparseUnivariatePolynomial F
  RSOL ==> Record(ans : UP, remainder : UP)
  DSOL ==> Record(ans : List(UP), acoeff : UP, eegen : UP, bpar : UP,
                  lcpar : List UP, dpar : Z)
  USOL ==> Union(List(RSOL), DSOL)
  Exports ==> with

    multi_SPDE : (UP, UP, List(UP), Z, UP -> UP) -> USOL
      ++ multi_SPDE(a, b, lc, d, der)
    SPDE1 : (UP, UP, UP -> UP) -> RSOL
      ++ SPDE1(b, c, D) solves Q' + b Q = c and returns [Q, r] where
      ++ r = c - ( Q' + b Q).  That is when r is zero then Q is
      ++ true solution, otherwise r represets unsolved part of c.
      ++ Moreover def(r) < deg(bQ).  Note: SPDE1 assumes that
      ++ deg(Q') < deg(bQ) for all Q.

  Implementation ==> add

    EE_Rec ==> Record(coef1 : UP, coef2 : UP)

    multi_SPDE(a, b, lc, d, der) ==
        d <$Z 0 => [[0, c]$RSOL for c in lc]
        every?(zero?, lc) => [[0, 0]$RSOL for c in lc]
        ee := extendedEuclidean(a, b)
        ee.generator ~= 1 =>
            [[0 for c in lc], 1, ee.generator, b, lc, d]$DSOL
        lr : List(UP) := []
        lnc : List(UP) := []
        for c in lc repeat
            cc1 := ee.coef1*c
            cc2 := ee.coef2*c
            qr := divide(cc2, a)
            r := qr.remainder
            nc := cc1 + b*qr.quotient - der(r)
            lnc := cons(nc, lnc)
            lr := cons(r, lr)
        lr := reverse!(lr)
        res1 := multi_SPDE(a, b + der(a), reverse!(lnc), d - degree(a)$UP, der)
        res1 case DSOL =>
            dres := res1::DSOL
            [[a*s2 + r for s2 in dres.ans for r in lr], a*dres.acoeff,
             dres.eegen, dres.bpar, dres.lcpar, dres.dpar]$DSOL
        [[a*s1.ans + r, s1.remainder]$RSOL for s1 in res1::List(RSOL)
                                           for r in lr]

    SPDE1(b, c, der) ==
      q : UP := 0
      db := (degree b)::Z
      lb := leadingCoefficient b
      while c ~= 0 repeat
          (n := (degree c)::Z - db) < 0 => return [q, c]
          qq := monomial((leadingCoefficient c) / lb, n::NonNegativeInteger)
          c := c - b*qq - der(qq)
          q := q + qq
      [q, 0]


