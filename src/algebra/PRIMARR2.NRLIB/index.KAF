3197                (|PrimitiveArrayFunctions2| A B)
|package|
(((|PrimitiveArrayFunctions2| |#1| |#2|)
  (CATEGORY |package|
   (SIGNATURE |scan|
    ((|PrimitiveArray| |#2|) (|Mapping| |#2| |#1| |#2|) (|PrimitiveArray| |#1|)
     |#2|))
   (SIGNATURE |reduce|
    (|#2| (|Mapping| |#2| |#1| |#2|) (|PrimitiveArray| |#1|) |#2|))
   (SIGNATURE |map|
    ((|PrimitiveArray| |#2|) (|Mapping| |#2| |#1|) (|PrimitiveArray| |#1|))))
  (|Type|) (|Type|))
 (T |PrimitiveArrayFunctions2|))
(CATEGORY |package|
 (SIGNATURE |scan|
  ((|PrimitiveArray| |#2|) (|Mapping| |#2| |#1| |#2|) (|PrimitiveArray| |#1|)
   |#2|))
 (SIGNATURE |reduce|
  (|#2| (|Mapping| |#2| |#1| |#2|) (|PrimitiveArray| |#1|) |#2|))
 (SIGNATURE |map|
  ((|PrimitiveArray| |#2|) (|Mapping| |#2| |#1|) (|PrimitiveArray| |#1|))))
"/git/fricas/src/algebra/PRIMARR2.spad"
((|map| (*1 *2 *3 *4)
  (AND (|isDomain| *3 (|Mapping| *6 *5)) (|isDomain| *4 (|PrimitiveArray| *5))
       (|ofCategory| *5 (|Type|)) (|ofCategory| *6 (|Type|))
       (|isDomain| *2 (|PrimitiveArray| *6))
       (|isDomain| *1 (|PrimitiveArrayFunctions2| *5 *6))))
 (|reduce| (*1 *2 *3 *4 *2)
  (AND (|isDomain| *3 (|Mapping| *2 *5 *2))
       (|isDomain| *4 (|PrimitiveArray| *5)) (|ofCategory| *5 (|Type|))
       (|ofCategory| *2 (|Type|))
       (|isDomain| *1 (|PrimitiveArrayFunctions2| *5 *2))))
 (|scan| (*1 *2 *3 *4 *5)
  (AND (|isDomain| *3 (|Mapping| *5 *6 *5))
       (|isDomain| *4 (|PrimitiveArray| *6)) (|ofCategory| *6 (|Type|))
       (|ofCategory| *5 (|Type|)) (|isDomain| *2 (|PrimitiveArray| *5))
       (|isDomain| *1 (|PrimitiveArrayFunctions2| *6 *5)))))
((|scan|
  (((|PrimitiveArray| |#2|) (|Mapping| |#2| |#1| |#2|) (|PrimitiveArray| |#1|)
    |#2|)
   16))
 (|reduce| ((|#2| (|Mapping| |#2| |#1| |#2|) (|PrimitiveArray| |#1|) |#2|) 18))
 (|map|
  (((|PrimitiveArray| |#2|) (|Mapping| |#2| |#1|) (|PrimitiveArray| |#1|)) 13)))
PRIMARR2
((|constructor|
  (NIL
   "\\indented{1}{This package provides tools for operating on primitive arrays} with unary and binary functions involving different underlying types"))
 (|map|
  (((|PrimitiveArray| |#2|) (|Mapping| |#2| |#1|) (|PrimitiveArray| |#1|))
   "\\spad{map(f,{} a)} applies function \\spad{f} to each member of primitive array \\spad{a} resulting in a new primitive array over a possibly different underlying domain."))
 (|reduce|
  ((|#2| (|Mapping| |#2| |#1| |#2|) (|PrimitiveArray| |#1|) |#2|)
   "\\spad{reduce(f,{} a,{} r)} applies function \\spad{f} to each successive element of the primitive array \\spad{a} and an accumulant initialized to \\spad{r}. For example,{} \\spad{reduce(_+\\$Integer,{} [1,{} 2,{} 3],{} 0)} does \\spad{3+(2+(1+0))}. Note: third argument \\spad{r} may be regarded as the identity element for the function \\spad{f}."))
 (|scan|
  (((|PrimitiveArray| |#2|) (|Mapping| |#2| |#1| |#2|) (|PrimitiveArray| |#1|)
    |#2|)
   "\\spad{scan(f,{} a,{} r)} successively applies \\spad{reduce(f,{} x,{} r)} to more and more leading sub-arrays \\spad{x} of primitive array \\spad{a}. More precisely,{} if \\spad{a} is \\spad{[a1,{} a2,{} ...]},{} then \\spad{scan(f,{} a,{} r)} returns \\spad{[reduce(f,{} [a1],{} r),{} reduce(f,{} [a1,{} a2],{} r),{} ...]}.")))
(("documentation" 0 1894) ("ancestors" 0 NIL) ("parents" 0 NIL)
 ("abbreviation" 0 1885) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 1610) ("modemaps" 0 830) ("sourceFile" 0 790)
 ("constructorCategory" 0 482) ("constructorModemap" 0 63)
 ("constructorKind" 0 53) ("constructorForm" 0 20))