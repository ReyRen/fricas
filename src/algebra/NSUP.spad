)abbrev domain NSUP NewSparseUnivariatePolynomial
++ Author: Marc Moreno Maza
++ Date Created: 23/07/98
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: A post-facto extension for \spadtype{SUP} in order
++ to speed up operations related to pseudo-division and gcd for
++ both \spadtype{SUP} and, consequently, \spadtype{NSMP}.

NewSparseUnivariatePolynomial(R) : Exports == Implementation where

  R : Ring
  NNI ==> NonNegativeInteger
  SUPR ==> SparseUnivariatePolynomial R

  Exports == Join(UnivariatePolynomialCategory(R),
   CoercibleTo(SUPR), RetractableTo(SUPR)) with
     monicModulo : (%, %) -> %
        ++ \spad{monicModulo(a, b)} returns \spad{r} such that \spad{r} is
        ++ reduced w.r.t. \spad{b} and \spad{b} divides \spad{a - r}
        ++ where \spad{b} is monic.
     lazyResidueClass : (%, %) -> Record(polnum : %, polden : R, power : NNI)
        ++ \spad{lazyResidueClass(a, b)} returns \spad{[r, c, n]} such that
        ++ \spad{r} is reduced w.r.t. \spad{b} and \spad{b} divides
        ++ \spad{c^n * a - r} where \spad{c} is \spad{leadingCoefficient(b)}
        ++ and \spad{n} is as small as possible with the previous properties.
     lazyPseudoRemainder : (%, %) -> %
        ++ \spad{lazyPseudoRemainder(a, b)} returns \spad{r} if \spad{lazyResidueClass(a, b)}
        ++ returns \spad{[r, c, n]}. This lazy pseudo-remainder is computed by
        ++ means of the \spadopFrom{fmecg}{NewSparseUnivariatePolynomial} operation.
     lazyPseudoDivide : (%, %) -> Record(coef : R, gap : NNI, quotient : %, remainder : %)
        ++ \spad{lazyPseudoDivide(a, b)} returns \spad{[c, g, q, r]} such that
        ++ \spad{c^n * a = q*b +r} and \spad{lazyResidueClass(a, b)} returns \spad{[r, c, n]}
        ++ where \spad{n + g = max(0, degree(b) - degree(a) + 1)}.
     lazyPseudoQuotient : (%, %) -> %
        ++ \spad{lazyPseudoQuotient(a, b)} returns \spad{q} if \spad{lazyPseudoDivide(a, b)}
        ++ returns \spad{[c, g, q, r]}
     if R has IntegralDomain then
       subResultantsChain : (%, %) -> List %
         ++ \spad{subResultantsChain(a, b)} returns the list of the non-zero
         ++ sub-resultants of \spad{a} and \spad{b} sorted by increasing
         ++ degree.
       lastSubResultant : (%, %) -> %
         ++ \spad{lastSubResultant(a, b)} returns \spad{resultant(a, b)}
         ++ if \spad{a} and \spad{b} has no non-trivial gcd in \spad{R^(-1) P}
         ++ otherwise the non-zero sub-resultant with smallest index.
       extendedSubResultantGcd : (%, %) -> Record(gcd : %, coef1 : %, coef2 : %)
         ++ \spad{extendedSubResultantGcd(a, b)} returns \spad{[g, ca, cb]} such
         ++ that \spad{g} is a gcd of \spad{a} and \spad{b} in \spad{R^(-1) P}
         ++ and \spad{g = ca * a + cb * b}
       halfExtendedSubResultantGcd1 : (%, %) -> Record(gcd : %, coef1 : %)
         ++ \spad{halfExtendedSubResultantGcd1(a, b)} returns \spad{[g, ca]} such that
         ++ \spad{extendedSubResultantGcd(a, b)} returns \spad{[g, ca, cb]}
       halfExtendedSubResultantGcd2 : (%, %) -> Record(gcd : %, coef2 : %)
         ++ \spad{halfExtendedSubResultantGcd2(a, b)} returns \spad{[g, cb]} such that
         ++ \spad{extendedSubResultantGcd(a, b)} returns \spad{[g, ca, cb]}
       extendedResultant : (%, %) -> Record(resultant : R, coef1 : %, coef2 : %)
         ++ \spad{extendedResultant(a, b)} returns \spad{[r, ca, cb]} such that
         ++ \spad{r} is the resultant of \spad{a} and \spad{b} and
         ++ \spad{r = ca * a + cb * b}
       halfExtendedResultant1 : (%, %) -> Record(resultant : R, coef1 : %)
         ++ \spad{halfExtendedResultant1(a, b)} returns \spad{[r, ca]} such that
         ++ \spad{extendedResultant(a, b)} returns \spad{[r, ca, cb]}
       halfExtendedResultant2 : (%, %) -> Record(resultant : R, coef2 : %)
         ++ \spad{halfExtendedResultant2(a, b)} returns \spad{[r, ca]} such that
         ++ \spad{extendedResultant(a, b)} returns \spad{[r, ca, cb]}

  Implementation == SparseUnivariatePolynomial(R) add

     Term ==> Record(k : NonNegativeInteger, c : R)
     Rep ==> List Term

     rep(s : %) : Rep == s pretend Rep
     per(l : Rep) : % == l pretend %

     coerce (p : %) : SUPR ==
       p pretend SUPR

     coerce (p : SUPR) : % ==
       p pretend %

     retractIfCan (p:%) : Union(SUPR,"failed") ==
       (p pretend SUPR)::Union(SUPR,"failed")

     monicModulo(x, y) ==
                zero? y =>
                   error "in monicModulo$NSUP: division by 0"
                ground? y =>
                   error "in monicModulo$NSUP: ground? #2"
                yy := rep y
                not ((yy.first.c) = 1) =>
                   error "in monicModulo$NSUP: not monic #2"
                xx := rep x; empty? xx => x
                e := yy.first.k; y := per(yy.rest)
                -- while (not empty? xx) repeat
                repeat
                  if (u := subtractIfCan(xx.first.k,e)) case "failed" then break
                  xx := rep fmecg(per rest(xx), u, xx.first.c, y)
                  if empty? xx then break
                per xx

     lazyResidueClass(x, y) ==
                zero? y =>
                   error "in lazyResidueClass$NSUP: division by 0"
                ground? y =>
                   error "in lazyResidueClass$NSUP: ground? #2"
                yy := rep y; co := yy.first.c; xx : Rep := rep x
                empty? xx => [x, co, 0]
                pow : NNI := 0; e := yy.first.k; y := per(yy.rest);
                repeat
                  if (u := subtractIfCan(xx.first.k,e)) case "failed" then break
                  xx := rep fmecg(co * per rest(xx), u, xx.first.c, y)
                  pow := pow + 1
                  if empty? xx then break
                [per xx, co, pow]

     lazyPseudoRemainder(x, y) ==
                zero? y =>
                   error "in lazyPseudoRemainder$NSUP: division by 0"
                ground? y =>
                   error "in lazyPseudoRemainder$NSUP: ground? #2"
                ground? x => x
                yy := rep y; co := yy.first.c
                (co = 1) => monicModulo(x, y)
                (co = -1) => - monicModulo(-x, -y)
                xx := rep x; e := yy.first.k; y := per(yy.rest)
                repeat
                  if (u := subtractIfCan(xx.first.k,e)) case "failed" then break
                  xx := rep fmecg(co * per rest(xx), u, xx.first.c, y)
                  if empty? xx then break
                per xx

     lazyPseudoDivide(x, y) ==
                zero? y =>
                   error "in lazyPseudoDivide$NSUP: division by 0"
                ground? y =>
                   error "in lazyPseudoDivide$NSUP: ground? #2"
                yy := rep y; e := yy.first.k;
                xx : Rep := rep x; co := yy.first.c
                (empty? xx) or (xx.first.k < e) => [co, 0, 0, x]
                pow : NNI := subtractIfCan(xx.first.k, e)::NNI + 1
                qq : Rep := []; y := per(yy.rest)
                repeat
                  if (u := subtractIfCan(xx.first.k,e)) case "failed" then break
                  qq := cons([u::NNI, xx.first.c]$Term, rep (co * per qq))
                  xx := rep fmecg(co * per rest(xx), u, xx.first.c, y)
                  pow := subtractIfCan(pow, 1)::NNI
                  if empty? xx then break
                [co, pow, per reverse qq, per xx]

     lazyPseudoQuotient(x, y) ==
                zero? y =>
                   error "in lazyPseudoQuotient$NSUP: division by 0"
                ground? y =>
                   error "in lazyPseudoQuotient$NSUP: ground? #2"
                yy := rep y; e := yy.first.k; xx : Rep := rep x
                (empty? xx) or (xx.first.k < e) => 0
                qq : Rep := []; co := yy.first.c; y := per(yy.rest)
                repeat
                  if (u := subtractIfCan(xx.first.k,e)) case "failed" then break
                  qq := cons([u::NNI, xx.first.c]$Term, rep (co * per qq))
                  xx := rep fmecg(co * per rest(xx), u, xx.first.c, y)
                  if empty? xx then break
                per reverse qq

     if R has IntegralDomain then

       pack ==> PseudoRemainderSequence(R, %)

       subResultantGcd(p1, p2) == subResultantGcd(p1, p2)$pack

       subResultantsChain(p1, p2) == chainSubResultants(p1, p2)$pack

       lastSubResultant(p1, p2) == lastSubResultant(p1, p2)$pack

       resultant(p1, p2) == resultant(p1, p2)$pack

       extendedResultant(p1, p2) ==
          re : Record(coef1 : %, coef2 : %, resultant : R) := resultantEuclidean(p1, p2)$pack
          [re.resultant, re.coef1, re.coef2]

       halfExtendedResultant1(p1 : %, p2 : %) : Record(resultant : R, coef1 : %) ==
          re : Record(coef1 : %, resultant : R) := semiResultantEuclidean1(p1, p2)$pack
          [re.resultant, re.coef1]

       halfExtendedResultant2(p1 : %, p2 : %) : Record(resultant : R, coef2 : %) ==
          re : Record(coef2 : %, resultant : R) := semiResultantEuclidean2(p1, p2)$pack
          [re.resultant, re.coef2]

       extendedSubResultantGcd(p1, p2) ==
          re : Record(coef1 : %, coef2 : %, gcd : %) := subResultantGcdEuclidean(p1, p2)$pack
          [re.gcd, re.coef1, re.coef2]

       halfExtendedSubResultantGcd1(p1 : %, p2 : %) : Record(gcd : %, coef1 : %) ==
          re : Record(coef1 : %, gcd : %) := semiSubResultantGcdEuclidean1(p1, p2)$pack
          [re.gcd, re.coef1]

       halfExtendedSubResultantGcd2(p1 : %, p2 : %) : Record(gcd : %, coef2 : %) ==
          re : Record(coef2 : %, gcd : %) := semiSubResultantGcdEuclidean2(p1, p2)$pack
          [re.gcd, re.coef2]

