)abbrev package EFACTOR ExpressionFactorPolynomial
ExpressionFactorPolynomial(R, F) : Exports == Implementation where
  R : Join(GcdDomain, Comparable)
  F : FunctionSpace R
  UP  ==> SparseUnivariatePolynomial F
  K   ==> Kernel F
  MP ==> SparseMultivariatePolynomial(R, K)
  UMP ==> SparseUnivariatePolynomial MP

  Exports ==> with

    factorPolynomial : UP -> Factored(UP)
      ++ factorPolynomial(p) factors p into irreducible factors over
      ++ field generated by its coefficients.
    factor : (UP, List F) -> Factored(UP)
      ++ factor(p, [k1, ..., kn]) factors p into irreducible factors over
      ++ field generated by its coefficients and k1, ..., kn.
    poly_factor : UMP -> Factored(UMP)
      ++ poly_factor(p) should be local but conditional.

  Implementation ==> add

    if (R is Integer or R is Complex(Integer)) then

      Exp ==> IndexedExponents(K)

      MULTFACT ==> MultivariateFactorize(K, Exp, R, MP)

      poly_factor(p) == factor(p)$MULTFACT

    else if MP has PolynomialFactorizationExplicit then

      poly_factor(p) == factorPolynomial(p)$MP

    else

      poly_factor(p) == error "factorPolynomial unimplemented"

    dummy := create()$SingletonAsOrderedSet
    xs := new()$Symbol
    xk := kernel(xs)$K

    UPCF2 ==> UnivariatePolynomialCategoryFunctions2

    fpoly_factor(p : UP) : Factored(UP) ==
        cn := leadingCoefficient(p)
        cn = 0 => nilFactor(p, 1)
        p := p/cn
        cnp := cn::UP
        pf := retract(eval(p, dummy, xk::F))@F
        p2 := univariate(numer(pf), xk)
        fres1 := poly_factor(p2)
        res : Factored(UP) := makeFR(cnp, [])
        for frec in factorList(fres1) repeat
            fr1 := frec.factor
            degree(fr1) < 1 => "iterate"
            frec.flag ~= "prime" and frec.flag ~= "irred" => error "impossible"
            fru := map(c1 +-> c1::F, fr1
                       )$UPCF2(MP, UMP, F, UP)
            fr2 := fru/leadingCoefficient(fru)
            res := res*primeFactor(fr2, frec.exponent)
        res

    PCQF ==> PolynomialCategoryQuotientFunctions(IndexedExponents K,
                           K, R, MP, F)

    ifactor(p : UP, lk : List K) : Factored(UP) ==
        n := degree(p)
        cn := leadingCoefficient(p)
        cn = 0 => nilFactor(p, 1)
        cnp := cn::UP
        n < 1 => makeFR(cnp, [])
        n = 1 => makeFR(cnp, [["prime", p, 1]])
        empty? lk => fpoly_factor(p)
        q   := minPoly(k1 := reduce(max, lk))
        lk2 := [k for k in lk | k ~= k1]
        sae := SimpleAlgebraicExtension(F, UP, q)
        ups := SparseUnivariatePolynomial sae
        p2 := map(x +-> reduce univariate(x, k1, q)$PCQF, p
                 )$UPCF2(F, UP, sae, ups)
        fres1 := factor(p2, x +-> ifactor(x, lk2)
                       )$InnerAlgFactor(F, UP, sae, ups)
        res : Factored(UP) := makeFR(cnp, [])
        kf := k1::F
        for frec in factorList(fres1) repeat
            fr1 := frec.factor
            frec.flag ~= "prime" and frec.flag ~= "irred" => error "impossible"
            fru := map(c1 +-> lift(c1)(kf), fr1
                      )$UPCF2(sae, ups, F, UP)
            fr2 := fru/leadingCoefficient(fru)
            res := res*primeFactor(fr2, frec.exponent)
        res

    factorPolynomial(p) == ifactor(p, algtower(coefficients(p)))

    factor(p, lf) ==
        ifactor(p, algtower(concat(lf, coefficients(p))))

