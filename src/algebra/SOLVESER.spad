)abbrev package SOLVESER TransSolvePackageService
++ Author: W. Wiwianka
++ Date Created: Summer 1991
++ Basic Operations: decomposeFunc, unvectorise
++ Related Constructors:
++ Keywords:
++ Description: This package finds the function func3 where  func1 and func2
++  are given and  func1 = func3(func2) .  If there is no solution then
++  function func1 will be returned.
++  An example would be  \spad{func1 := 8*X^3+32*X^2-14*X ::EXPR INT} and
++  \spad{func2 := 2*X ::EXPR INT} convert them via univariate
++  to FRAC SUP EXPR INT and then the solution is \spad{func3 := X^3+X^2-X}
++  of type FRAC SUP EXPR INT
TransSolvePackageService(R) : Exports == Implementation where
   R   :   Join(Comparable, IntegralDomain)

   RE  ==> Expression R
   EQ  ==> Equation
   S   ==> Symbol
   V   ==> Variable
   L   ==> List
   SUP ==> SparseUnivariatePolynomial
   ACF ==> AlgebraicallyClosedField()


   Exports == with

     decomposeFunc : ( Fraction SUP RE , Fraction SUP RE, Fraction SUP RE )  -> Fraction SUP RE
       ++ decomposeFunc(func1, func2, newvar)  returns a function  func3 where
       ++ func1 = func3(func2)  and expresses it in the new variable  newvar.
       ++ If there is no solution then func1 will be returned.
     unvectorise : ( Vector RE , Fraction SUP RE , Integer ) -> Fraction SUP RE
       ++ unvectorise(vect, var, n) returns
       ++ \spad{vect(1) + vect(2)*var + ... + vect(n+1)*var^(n)} where
       ++ vect  is the vector of the coefficients of the polynomial, var
       ++ the new variable and n the degree.


   Implementation == add
     import from ACF
     import from TranscendentalManipulations(R, RE)
     import from ElementaryFunctionStructurePackage(R, RE)
     import from SparseUnivariatePolynomial(R)
     import from LinearSystemMatrixPackage(RE, Vector RE, Vector RE, Matrix RE)
     import from HomogeneousAggregate(R)

        ---- Local Function Declarations ----

     subsSolve : ( SUP RE, NonNegativeInteger, SUP RE, SUP RE, Integer, Fraction SUP RE) -> Union(SUP RE , "failed" )
       --++ subsSolve(f, degf, g1, g2, m, h)


    -- exported functions


     unvectorise(vect : Vector RE, var : Fraction SUP RE, n : Integer) : Fraction SUP RE ==
       Z := new()@Symbol
       polyvar : Fraction SUP RE := 0
       for i in 1..((n+1)::Integer) repeat
          vecti := univariate(vect.i, kernel Z)
          polyvar := polyvar + ( vecti )*( var )^( (n-i+1)::NonNegativeInteger )
       polyvar


     decomposeFunc(exprf : Fraction SUP RE , exprg : Fraction SUP RE, newH : Fraction SUP RE ) : Fraction SUP RE ==
       X := new()@Symbol
       f1 := numer(exprf)
       f2 := denom(exprf)
       g1 := numer(exprg)
       g2 := denom(exprg)
       degF := max(degree(numer(exprf)), degree(denom(exprf)))
       degG := max(degree(g1), degree(g2))
       newF1,newF2 : Union(SUP RE, "failed")
       N := degF exquo degG
       if not ( N case "failed" ) then
         m := N::Integer
         newF1 := subsSolve(f1, degF, g1, g2, m, newH)
         if f2 = 1 then
           newF2 := 1 :: SUP RE
         else newF2 := subsSolve(f2, degF, g1, g2, m, newH)
         if ( not ( newF1 case "failed" ) ) and ( not ( newF2 case "failed" ) ) then
           newF := newF1/newF2
         else return exprf
       else return exprf


    -- local functions


     subsSolve(F:SUP RE, DegF:NonNegativeInteger, G1:SUP RE, G2:SUP RE, M:Integer, HH : Fraction SUP RE) : Union(SUP RE , "failed" ) ==
       coeffmat := new((DegF+1), 1, 0)@Matrix RE
       for i in 0..M repeat
          coeffmat := horizConcat(coeffmat, (vectorise( ( ( G1^((M-i)::NonNegativeInteger) )*G2^i ), (DegF+1) )::Matrix RE) )
       vec := vectorise(F, DegF+1)
       coeffma := subMatrix(coeffmat, 1, (DegF+1), 2, (M+2))
       solvar := solve(coeffma, vec)
       if not ( solvar.particular  case  "failed" ) then
         solvevarlist := (solvar.particular)::Vector RE
         resul := numer(unvectorise(solvevarlist, ( HH ), M))
         resul
       else return "failed"

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
