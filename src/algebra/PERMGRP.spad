)abbrev domain PERMGRP PermutationGroup
++ Authors: G. Schneider, H. Gollan, J. Grabmeier
++ Date Created: 13 February 1987
++ Basic Operations:
++ Related Constructors: PermutationGroupExamples, Permutation
++ Also See: RepresentationTheoryPackage1
++ AMS Classifications:
++ Keywords: permutation, permutation group, group operation, word problem
++ References:
++   C. Sims: Determining the conjugacy classes of a permutation group,
++   in Computers in Algebra and Number Theory, SIAM-AMS Proc., Vol. 4,
++    Amer. Math. Soc., Providence, R. I., 1971, pp. 191-195
++ Description:
++  PermutationGroup implements permutation groups acting
++  on a set S, i.e. all subgroups of the symmetric group of S,
++  represented as a list of permutations (generators). Note that
++  therefore the objects are not members of the \Language category
++  \spadtype{Group}.
++  Using the idea of base and strong generators by Sims,
++  basic routines and algorithms
++  are implemented so that the word problem for
++  permutation groups can be solved.
--++  Note: we plan to implement lattice operations on the subgroup
--++  lattice in a later release

PermutationGroup(S : SetCategory) : public == private where

  L    ==> List
  PERM ==> Permutation
  FSET ==> Set
  I    ==> Integer
  NNI  ==> NonNegativeInteger
  V    ==> Vector
  B    ==> Boolean
  OUT   ==> OutputForm
  SYM  ==> Symbol
  REC  ==> Record ( orb : L NNI, svc : V I )
  REC2 ==> Record(order : NNI, sgset : L V NNI, _
             gpbase : L NNI, orbs : V REC, mp : L S, wd : L L NNI)
  REC3 ==> Record(elt : V NNI, lst : L NNI)
  REC4 ==> Record(bool : B, lst : L NNI)

  public ==> SetCategory with

    coerce           : %         -> L PERM S
      ++ coerce(gp) returns the generators of the group {\em gp}.
    generators           : %         -> L PERM S
      ++ generators(gp) returns the generators of the group {\em gp}.
    elt              : (%, NNI)   -> PERM S
      ++ elt(gp, i) returns the i-th generator of the group {\em gp}.
    random           : (%, I)     -> PERM S
      ++ random(gp, i) returns a random product of maximal i generators
      ++ of the group {\em gp}.
    random           : %         -> PERM S
      ++ random(gp) returns a random product of maximal 20 generators
      ++ of the group {\em gp}.
      ++ Note: {\em random(gp)=random(gp, 20)}.
    order            : %         -> NNI
      ++ order(gp) returns the order of the group {\em gp}.
    degree           : %         -> NNI
      ++ degree(gp) returns the number of points moved by all permutations
      ++ of the group {\em gp}.
    base             : %         -> L S
      ++ base(gp) returns a base for the group {\em gp}.
    strongGenerators : %         -> L PERM S
      ++ strongGenerators(gp) returns strong generators for
      ++ the group {\em gp}.
    wordsForStrongGenerators      : %         -> L L NNI
      ++ wordsForStrongGenerators(gp) returns the words for the strong
      ++ generators of the group {\em gp} in the original generators of
      ++ {\em gp}, represented by their indices in the list, given by
      ++ {\em generators}.
    coerce           : L PERM S  -> %
      ++ coerce(ls) coerces a list of permutations {\em ls} to the group
      ++ generated by this list.
    permutationGroup          : L PERM S  -> %
      ++ permutationGroup(ls) coerces a list of permutations {\em ls} to
      ++ the group generated by this list.
    orbit            : (%, S)     -> FSET S
      ++ orbit(gp, el) returns the orbit of the element {\em el} under the
      ++ group {\em gp}, i.e. the set of all points gained by applying
      ++ each group element to {\em el}.
    orbits           : %         -> FSET FSET S
      ++ orbits(gp) returns the orbits of the group {\em gp}, i.e.
      ++ it partitions the (finite) of all moved points.
    orbit            : (%, FSET S)-> FSET FSET S
      ++ orbit(gp, els) returns the orbit of the unordered
      ++ set {\em els} under the group {\em gp}.
    orbit            : (%, L S)   -> FSET L S
      ++ orbit(gp, ls) returns the orbit of the ordered
      ++ list {\em ls} under the group {\em gp}.
      ++ Note: return type is L L S temporarily because FSET L S has an error.
      -- (GILT DAS NOCH?)
    member?          : (PERM S, %)-> B
      ++ member?(pp, gp) answers the question, whether the
      ++ permutation {\em pp} is in the group {\em gp} or not.
    wordInStrongGenerators : (PERM S, %)-> L NNI
      ++ wordInStrongGenerators(p, gp) returns the word for the
      ++ permutation p in the strong generators of the group {\em gp},
      ++ represented by the indices of the list, given by
      ++ {\em strongGenerators}.
    wordInGenerators : (PERM S, %)-> L NNI
      ++ wordInGenerators(p, gp) returns the word for the permutation p
      ++ in the original generators of the group {\em gp},
      ++ represented by the indices of the list, given by {\em generators}.
    movedPoints      : %         -> FSET S
      ++ movedPoints(gp) returns the points moved by the group {\em gp}.
    "<"              : (%,%)     -> B
      ++ gp1 < gp2 returns true if and only if {\em gp1}
      ++ is a proper subgroup of {\em gp2}.
    "<="             : (%,%)     -> B
      ++ gp1 <= gp2 returns true if and only if {\em gp1}
      ++ is a subgroup of {\em gp2}.
      ++ Note: because of a bug in the parser you have to call this
      ++ function explicitly by {\em gp1 <=$(PERMGRP S) gp2}.
      -- (GILT DAS NOCH?)
    initializeGroupForWordProblem : %   -> Void
      ++ initializeGroupForWordProblem(gp) initializes the group {\em gp}
      ++ for the word problem.
      ++ Notes: it calls the other function of this name with parameters
      ++ 0 and 1: {\em initializeGroupForWordProblem(gp, 0, 1)}.
      ++ Notes: (1) be careful: invoking this routine will destroy the
      ++ possibly information about your group (but will recompute it again)
      ++ (2) users need not call this function normally for the soultion of
      ++ the word problem.
    initializeGroupForWordProblem : (%, I, I) -> Void
      ++ initializeGroupForWordProblem(gp, m, n) initializes the group
      ++ {\em gp} for the word problem.
      ++ Notes: (1) with a small integer you get shorter words, but the
      ++ routine takes longer than the standard routine for longer words.
      ++ (2) be careful: invoking this routine will destroy the possibly stored
      ++ information about your group (but will recompute it again).
      ++ (3) users need not call this function normally for the soultion of
      ++ the word problem.
    relationsInStrongGenerators : % -> L(L(I))
      ++ relationsInStrongGenerators(gp) computes relations between
      ++ strong generators.
    relationsInGenerators : % -> L(L(I))
      ++ relationsInGenerators(gp) computes relations between
      ++ generators.
    pointList : % -> L S
      ++ pointList(gp) should be local but conditional
    perm_to_vec : (L S, PERM S, NNI) -> V NNI
      ++ perm_to_vec(supp, p, degree) should be local but conditional
  private ==> add

    -- representation of the object:

    Rep  := Record(gens : L PERM S, information : REC2)

    -- import of domains and packages

    import from Permutation S
    import from OutputForm
    import from Symbol
    import from Void

  --local functions first, signatures:

    shortenWord : (L NNI, %)->L NNI
    times : (V NNI, V NNI)->V NNI
    orbitInternal : (%, L S )->L L S
    inv : V NNI->V NNI
    ranelt : (L V NNI, L L NNI, I)->REC3
    testIdentity : V NNI->B
    orbitWithSvc : (L V NNI, NNI )->REC
    bsgs1 : (L V NNI, NNI, L L NNI, I, %, I)->NNI
    initialize : %->FSET PERM S
    knownGroup? : %->Void
    subgroup : (%, %)->B
    memberInternal : (PERM S, %, B)->REC4

  --local functions first, implementations:

    shortenWord ( lw : L NNI, gp : % ) : L NNI ==
        -- tries to shorten a word in the generators by removing identities
        gpgens : L PERM S := coerce gp
        orderList : L NNI := [ order gen for gen in gpgens ]
        newlw : L NNI := copy lw
        for i in 1.. maxIndex orderList repeat
            if orderList.i = 1 then
                while member?(i, newlw) repeat
                    -- removing the trivial element
                    pos := position(i, newlw)
                    newlw := delete(newlw, pos)
        #newlw < 2 => newlw
        test := first(newlw)
        anzahl : NNI := 0
        flag1 : B := true
        do_res : B := false
        res : L NNI
        while flag1 repeat
            test := first(newlw)
            anzahl := 1
            if do_res then res := [test]
            flag2 : B := true
            for el in newlw while flag2 repeat
                if do_res then res := cons(el, res)
                anzahl := anzahl + 1
                anzahl = 1 => test := el
                test ~= el =>
                    test := el
                    anzahl := 1
                anzahl = orderList.test =>
                    if do_res then
                        res := rest(res, anzahl)
                    else
                        flag2 := false
                    anzahl := 0
            if do_res then
                newlw := reverse!(res)
            flag1 := do_res
            do_res := not(flag2)
        newlw

    -- internal multiplication of permutations
    times!(res : V NNI, p : V NNI, q : V NNI) : Void ==
        degree := #p
        for i in 1..degree repeat
            qsetelt!(res, i, qelt(p, qelt(q, i)))

    times ( p : V NNI, q : V NNI ) : V NNI ==
        degree := #p
        res : V NNI := new(degree, 0)
        times!(res, p, q)
        res

    -- internal inverse of a permutation
    inv ( p : V NNI ) : V NNI ==
        degree := #p
        q : V NNI := new(degree, 0)$(V NNI)
        for i in 1..degree repeat qsetelt!(q, (qelt(p, i)), i)
        q

    -- internal test for identity
    testIdentity ( p : V NNI ) : B ==
        degree := #p
        for i in 1..degree repeat qelt(p, i) ~= i => return false
        true

    cosetRep1(ppt : NNI, do_words : Boolean, o : REC, grpv : V V NNI,
              wordv : V L NNI) : REC3 ==
        #grpv = 0 => error "cosetRep needs nonempty group"
        degree := #(grpv(1))
        xelt : V NNI := [ n for n in 1..degree ]
        word         := []$(L NNI)
        oorb         := o.orb
        osvc         := o.svc
        p := qelt(osvc, ppt)
        p < 0 => return [xelt, word]
        tmpv : V NNI := new(degree, 0)
        repeat
            x    := qelt(grpv, p)
            times!(tmpv, x, xelt)
            (tmpv, xelt) := (xelt, tmpv)
            if do_words then word := append(wordv.p, word)
            ppt  := qelt(x, ppt)
            p := qelt(osvc, ppt)
            p < 0 => return [xelt, word]

    strip1(element : V NNI, orbit : REC, group : L V NNI, words : L L NNI
          ) : REC3 ==
        grpv := vector(group)$Vector(V NNI)
        wordv : V L NNI := empty()
        do_words := not(empty?(words))
        if do_words then
            wordv := vector(words)
        point := qelt(element, qelt(orbit.orb, 1))
        cr := cosetRep1(point, do_words, orbit, grpv, wordv)
        [times(cr.elt, element), reverse(cr.lst)]$REC3

    strip(z : V NNI, i : I, do_words : Boolean,
            orbs : V REC, grpv : V V NNI, wordv : V L NNI) : REC3 ==
        degree := #z
        word := []$(L NNI)
        tmpv : V NNI := new(degree, 0)
        noresult : Boolean := true
        for j in i..1 by -1 while noresult repeat
            orbj := qelt(orbs, j)
            s := orbj.svc
            p := first(orbj.orb)
            while noresult repeat
                entry := qelt(s, qelt(z, p))
                if entry < 0 then
                    if entry = -1 then break
                    noresult := false
                else
                    ee := qelt(grpv, entry)
                    times!(tmpv, ee, z)
                    (z, tmpv) := (tmpv, z)
                    if do_words then word := append(wordv.entry, word)
        [z, word]

    orbitInternal(gp : %, startList : L S) : L L S ==
        orbitList : L L S := [ startList ]
        pos  : I := 1
        while not zero? pos  repeat
            gpset : L PERM S := gp.gens
            for gen in gpset repeat
                newList  := []$(L S)
                workList := orbitList.pos
                for j in #workList..1 by -1 repeat
                    newList := cons(eval(gen, workList.j), newList)
                if not member?( newList, orbitList ) then
                    orbitList := cons(newList, orbitList)
                    pos  := pos + 1
            pos := pos - 1
        reverse orbitList

    ranelt(group : L V NNI, word : L L NNI, maxLoops : I) : REC3 ==
        -- generate a "random" element
        numberOfGenerators    := # group
        randomInteger : I     := 1 + random(numberOfGenerators)$Integer
        randomElement : V NNI := group.randomInteger
        words                 := []$(L NNI)
        do_words : Boolean := not(empty?(word))
        if do_words then words := word.(randomInteger::NNI)
        if maxLoops > 0 then
            numberOfLoops : I  := 1 + random(maxLoops)$Integer
        else
            numberOfLoops : I := maxLoops
        while numberOfLoops > 0 repeat
            randomInteger : I := 1 + random(numberOfGenerators)$Integer
            randomElement := times(group.randomInteger, randomElement)
            if do_words then words := append(word.(randomInteger::NNI), words)
            numberOfLoops := numberOfLoops - 1
        [randomElement, words]

    if S has OrderedSet then
        pointList(group : %) : L S ==
            not(empty?(group.information.mp)) => group.information.mp
            support : L S := []
            for perm in group.gens repeat
                support := merge(sort((listRepresentation perm).preimage),
                                 support)
            res :  L S := []
            empty?(support) => res
            p0 := first(support)
            res := [p0]
            for p in rest(support) repeat
                p = p0 => "iterate"
                p0 := p
                res := cons(p, res)
            group.information.mp := reverse!(res)
    else
        pointList(group : %) : L S ==
            not(empty?(group.information.mp)) => group.information.mp
            support : FSET S := empty()
            for perm in group.gens repeat
                support := union(support, movedPoints perm)
            group.information.mp := parts support

    if S has OrderedSet then
        REC5 ==> Record(preimage : NNI, image : S)
        ls_to_lnni(ls : L S, supp : L S) : L NNI ==
            empty?(ls) => []
            ls2 := [[i, p]$REC5 for p in ls for i in 1..]
            ls2 := sort((x : REC5, y : REC5) : Boolean +->
                           x.image <= y.image,
                        ls2)
            pel := first(ls2)
            p1 := pel.image
            ls2 := rest(ls2)
            rp2 : L L NNI := []
            flag : Boolean := true
            for p2 in supp for i in 1.. while flag repeat
                if p1 = p2 then
                    rp2 := cons([pel.preimage, i], rp2)
                    empty?(ls2) => flag := false
                    pel := first(ls2)
                    p1 := pel.image
                    ls2 := rest(ls2)
            rp2 := sort((x : L NNI, y : L NNI) : Boolean +->
                           first(x) <= first(y),
                        rp2)
            [second(pp) for pp in rp2]

        perm_to_vec(supp : L S, p : PERM S, degree : NNI) : V NNI ==
            pr := listRepresentation p
            q := new(degree, 0)$(V NNI)
            for i in 1..degree repeat
                q(i) := i
            pl := ls_to_lnni(pr.preimage, supp)
            il := ls_to_lnni(pr.image, supp)
            for pp in pl for ip in il repeat
                q(pp) := ip
            q
    else
        perm_to_vec(supp : L S, p : PERM S, degree : NNI) : V NNI ==
            q := new(degree, 0)$(V NNI)
            for i in 1..degree repeat
                newEl := eval(p, supp.i)
                pos2  := position(newEl, supp)
                q.i   := qcoerce(pos2)
            q

    orbitWithSvc1(group : L V NNI, grpinv : L V NNI, point : NNI) : REC ==
        -- compute orbit with Schreier vector, "-2" means not in the orbit,
        -- "-1" means starting point, the PI correspond to generators
        degree := #(first(group))
        orbit          : L NNI := [ point ]
        orbitv         : V NNI := new(degree, 0)
        orbitv(1) := point
        orbit_size : NNI := 1
        schreierVector : V I   := new ( degree, -2 )
        schreierVector.point   := -1
        position : I := 1
        while not zero? position repeat
            for i in 1..#grpinv for grv in grpinv repeat
                newPoint := qelt(orbitv, orbit_size - position + 1)
                newPoint := qelt(grv, newPoint)
                if qelt(schreierVector, newPoint) = -2 then
                    orbit                   := cons ( newPoint, orbit )
                    orbit_size := orbit_size + 1
                    orbitv(orbit_size) := newPoint
                    position                := position + 1
                    schreierVector.newPoint := i
            position := position - 1
        [reverse!(orbit), schreierVector ]

    orbitWithSvc(group : L V NNI, point : NNI) : REC ==
        grpinv := []$(L V NNI)
        for el in group repeat
            grpinv := cons(inv el, grpinv)
        grpinv := reverse grpinv
        orbitWithSvc1(group, grpinv, point)

    bsgs1(group : L V NNI, number1 : NNI, words : L L NNI, maxLoops : I,
          gp : %, diff : I, out : Reference(L L V NNI),
          outword : Reference(L L L NNI)) : NNI ==
        -- try to get a good approximation for the strong generators and base
        degree := #(first(group))
        gp_info := gp.information
        wordProblem : Boolean := not(empty?(words))
        -- i := find moved point
        for i in number1..degree repeat
            ort := orbitWithSvc(group, i)
            k   := ort.orb
            k1  := # k
            if k1 ~= 1 then break
        gpsgs := []$(L V NNI)
        words2 := []$(L L NNI)
        gplength : NNI := #group
        -- j := nontrivial element
        for jj in 1..gplength repeat if (group.jj).i ~= i then break
        for k in 1..gplength repeat
            el2 := group.k
            if el2.i ~= i then
                gpsgs := cons(el2, gpsgs)
                if wordProblem then words2 := cons(words.k, words2)
            else
                gpsgs := cons(times(group.jj, el2), gpsgs)
                if wordProblem then
                      words2 := cons(append(words.jj, words.k), words2)
        group2 := []$(L V NNI)
        words3 := []$(L L NNI)
        j : I  := 15
        while j > 0 repeat
            -- find generators for the stabilizer
            ran := ranelt(group, words, maxLoops)
            str := strip1(ran.elt, ort, group, words)
            el2 := str.elt
            if not testIdentity el2 then
                if not member?(el2, group2) then
                    group2 := cons ( el2, group2 )
                    if wordProblem then
                        help : L NNI := append(reverse str.lst, ran.lst)
                        help         := shortenWord(help, gp)
                        words3       := cons(help, words3)
                    j := j - 2
            j := j - 1
        -- this is for word length control
        if wordProblem then maxLoops    := maxLoops - diff
        if empty?(group2) or (maxLoops < 0) then
            gp_info.gpbase := [i]
            setref(out, [gpsgs])
            setref(outword, [words2])
            return k1
        k2 := bsgs1(group2, i + 1, words3, maxLoops, gp, diff,
                    out, outword)
        sizeOfGroup : NNI := k1 * k2
        setref(out, append(deref(out), [gpsgs]))
        setref(outword, append(deref(outword), [words2]))
        gp_info.gpbase := cons(i, gp_info.gpbase)
        sizeOfGroup

    reduceGenerators(kkk : I, do_words : Boolean, gp_info : REC2,
                     outl : L L V NNI, outword : L L L NNI) : L V NNI ==
        -- try to reduce number of strong generators
        base_lst := gp_info.gpbase
        orbv := gp_info.orbs
        sgs : L V NNI := []
        res : L V NNI := []
        grpinv := []$(L V NNI)
        for i in 1..kkk repeat
            sgs := append(sgs, outl(i))
            grpinv := append(grpinv, map(inv, outl(i)))
        removedGenerator : Boolean := false
        baseLength : NNI := #base_lst
        pt  := baseLength - kkk + 1
        obs := orbitWithSvc1(sgs, grpinv, base_lst(pt))
        orbv(kkk) := obs
        obs_len := # obs.orb
        if obs_len = 1 then
            removedGenerator := true
            outl(kkk) := []
        i   := 1
        outlk := outl(kkk)
        while not (i > # outlk) and # outlk > 1 repeat
            pos  := position(outlk(i), sgs)
            sgs2 := delete(sgs, pos)
            grpinv2 := delete(grpinv, pos)
            obs2 := orbitWithSvc1(sgs2, grpinv2, base_lst(pt))
            if # obs2.orb = obs_len then
                res := cons(outlk(i), res)
                sgs := sgs2
                grpinv := grpinv2
                outlk := delete(outlk, i)
                outl(kkk) := outlk
                orbv(kkk) := obs2
                if do_words then _
                    outword(kkk) := delete(outword(kkk), i)
             else
                i := i + 1
        res


    bsgs(group : %, wordProblem : Boolean, maxLoops : I, diff : I) : NNI ==
        -- the MOST IMPORTANT part of the package
        basePoint    : NNI           := 0
        newBasePoint : B := false
        baseOfGroup  : L NNI         := []
        out               : L L V NNI     := []
        outword           : L L L NNI     := []
        outr              : Reference(L L V NNI) := ref([])
        outwordr          : Reference(L L L NNI) := ref([])
        supp   := pointList group
        degree := # supp
        gp_info := [1, [], [], [], [], []]$REC2
        if degree = 0 then
            group.information := gp_info
            return 1
        newGroup := []$(L V NNI)
        tmpv : V NNI := new(degree, 0)
        gp       : L PERM S := group.gens
        words := []$(L L NNI)
        for ggg in 1..#gp for ggp in gp repeat
            q := perm_to_vec(supp, ggp, degree)
            newGroup := cons(q, newGroup )
            if wordProblem then words := cons(list ggg, words)
        if maxLoops < 1 then
            -- try to get the (approximate) base length
            if zero? (# ((group.information).gpbase)) then
                k := bsgs1(newGroup, 1, []$(L L NNI), 20, group, 0,
                                 outr, outwordr)
            maxLoops := #((group.information).gpbase) - 1
        k := bsgs1(newGroup, 1, words, maxLoops, group, diff, outr, outwordr)
        out := deref(outr)
        outword := deref(outwordr)
        kkk : I := 1
        newGroup := reverse newGroup
        noAnswer : B := true
        z : V NNI
        add_cnt : I := 0
        wordlist : L L NNI
        dummy_rec : REC := [[], empty()]
        baseOfGroup := (group.information).gpbase
        gp_info.gpbase := baseOfGroup
        orbv : V REC := new(# baseOfGroup, dummy_rec)$(V REC)
        while noAnswer repeat
            gp_info.gpbase := baseOfGroup
            gp_info.orbs := orbv
            -- test whether we have a base and a strong generating set
            sgs : L V NNI := []
            wordlist := []
            for i in 1..(kkk-1) repeat
                sgs := append(sgs, out.i)
                if wordProblem then wordlist := append (wordlist, outword.i)
            noresult : B := true
            z := new(degree, 0)
            for i in kkk..#baseOfGroup while noresult repeat
                rejects := reduceGenerators(i, wordProblem, gp_info,
                                            out, outword)
                sgs := append(sgs, out.i)
                sgsv := vector(sgs)$V(V NNI)
                wordv : V L NNI := empty()
                if wordProblem then
                    wordlist := append(wordlist, outword.i)
                    wordv := vector(wordlist)
                gporbi := orbv(i)
                for z0 in rejects while noresult repeat
                    z := copy(z0)
                    ppp := strip(z, i, false, orbv, sgsv, wordv)
                    noresult := testIdentity ppp.elt
                    if not(noresult) then
                        if wordProblem then
                            z := copy(z0)
                            ppp := strip(z, i, true, orbv, sgsv, wordv)
                        z := ppp.elt
                        word := ppp.lst
                for pt in gporbi.orb while noresult repeat
                    ppp   := cosetRep1(pt, wordProblem, gporbi, sgsv, wordv)
                    y1    := inv ppp.elt
                    word3 := ppp.lst
                    for jjj in 1..#sgs while noresult repeat
                        word         := []$(L NNI)
                        times!(z, qelt(sgsv, jjj), y1)
                        if wordProblem then word := qelt(wordv, jjj)
                        ppp := strip(z, i, false, orbv, sgsv, wordv)
                        z := ppp.elt
                        noresult := testIdentity z
                        if not(noresult) and wordProblem then
                            z := times (qelt(sgsv, jjj), y1)
                            ppp := strip(z, i, true, orbv, sgsv, wordv)
                            z := ppp.elt
                            word := append(ppp.lst, word)
                if not(noresult) then
                    for p in baseOfGroup for ii in 1.. repeat
                        basePoint    := 1
                        newBasePoint := true
                        if qelt(z, p) ~= p then
                            newBasePoint := false
                            basePoint    := (#baseOfGroup - ii + 1)::NNI
                            break
            noAnswer := not (testIdentity z)
            if noAnswer then
                add_cnt := add_cnt + 1
                -- we have missed something
                word2 := []$(L NNI)
                if wordProblem then
                    for wdi in word3 repeat
                        ttt := newGroup.wdi
                        while not (testIdentity ttt) repeat
                            word2 := cons(wdi, word2)
                            ttt   := times(ttt, newGroup.wdi)
                    word := append(word, word2)
                    word := shortenWord(word, group)
                if newBasePoint then
                    for i in 1..degree repeat
                        if z.i ~= i then
                            baseOfGroup := append(baseOfGroup, [ i ])
                            break
                    orbv := new(# baseOfGroup, dummy_rec)$(V REC)
                    out := cons(list  z, out)
                    if wordProblem then outword := cons(list word, outword)
                else
                    out.basePoint := cons(z, out.basePoint)
                    if wordProblem then
                        outword.basePoint := cons(word, outword.basePoint)
                kkk := basePoint
        sizeOfGroup : NNI := 1
        for j in 1..#baseOfGroup repeat
            sizeOfGroup := sizeOfGroup * # orbv(j).orb
        group.information := [sizeOfGroup, sgs, baseOfGroup, orbv, supp,
                              wordlist]$REC2
        sizeOfGroup


    initialize(group : %) : FSET PERM S ==
        group2 := empty()$(FSET PERM S)
        gp : L PERM S := group.gens
        for gen in gp repeat
            if degree gen > 0 then insert!(gen, group2)
        group2

    knownGroup?(gp : %) : Void ==
        -- do we know the group already?
        if gp.information.order = 0 then
            bsgs(gp, false, 20, 0)
        void

    subgroup(gp1 : %, gp2 : %) : B ==
        gpset1 := initialize gp1
        gpset2 := initialize gp2
        empty? difference(gpset1, gpset2) => true
        for el in parts gpset1 repeat
            not member?(el, gp2) => return false
        true

    memberInternal(p : PERM S, gp : %, do_words : B) : REC4 ==
        -- internal membership testing
        gr_supp     := pointList gp
        mP : L S := parts movedPoints p
        gp_info : REC2
        for x in mP repeat
            not member?(x, gr_supp) =>
                return [false, []$(L NNI)]
        if not(do_words) then
            member?(p, gp.gens) => return [true, []$(L NNI)]
        knownGroup? gp
        gp_info := gp.information
        sgsl := gp_info.sgset
        orbv := gp_info.orbs
        base_lst := gp_info.gpbase
        degree : NNI := #gr_supp

        pp := perm_to_vec(gr_supp, p, degree)

        wordv : V L NNI := empty()
        if do_words then
            wordv := new(#sgsl, [])
            for i in 1..#sgsl repeat
                wordv(i) := [i]
        grpv : V V NNI := vector(sgsl)
        str := strip(pp, #base_lst, do_words, orbv, grpv, wordv)
        [testIdentity str.elt, str.lst]

    orbit_words1(p0 : NNI, p : NNI, grp : L V NNI, acc : L NNI, res : V L NNI
                ) : Void ==
        for g in grp for i in 1.. repeat
            q := qelt(g, p)
            p0 = q => "skip"
            not(empty?(qelt(res, q))) => "skip"
            acc1 := cons(qcoerce(i)@NNI, acc)
            res(q) := acc1
            orbit_words1(p0, q, grp, acc1, res)

    orbit_words(p : NNI, grp : L V NNI) : V L NNI ==
        n := #first(grp)
        res := new(n, [])$(V L NNI)
        orbit_words1(p, p, grp, [], res)
        res

    relations_for_orbit(p : NNI, m : NNI, orbd : V REC,
                        grpv : V V NNI) : L L I ==
        -- print("relations_for_orbit"::OutputForm)
        -- print(p::OutputForm)
        res : L L I := []
        grpl := first(members(grpv), m)
        ww := orbit_words(p, grpl)
        -- print(ww::OutputForm)
        n0 := #(orbd(1).svc)
        wv := new(n0, empty()$Vector(NNI))$(V V NNI)
        wvi := new(n0, empty()$Vector(NNI))$(V V NNI)
        wordv := new(n0, empty())$(V L NNI)
        for i in 1..n0 repeat
            wordv(i) := [i]
            wi_l := qelt(ww, i)
            empty?(wi_l) => "skip"
            wi := new(n0, 0)$Vector(NNI)
            for j in 1..n0 repeat
                qsetelt!(wi, j, j)
            for j in reverse(wi_l) repeat
                times!(wi, qelt(grpv, j), wi)
            qsetelt!(wv, i, wi)
            qsetelt!(wvi, i, inv(wi))
        for i in 1..n0 repeat
            wi_l := qelt(ww, i)
            empty?(wi_l) => "skip"
            -- print("wi_l = "::OutputForm)
            -- print(wi_l::OutputForm)
            wi := qelt(wv, i)
            for j in 1..m repeat
                -- print("doing"::OutputForm)
                -- print(j::OutputForm)
                nw := times(grpv(j), wi)
                p1 := qelt(nw, p)
                iw : L NNI := []
                if p1 ~= p then
                    nw := times(wvi(p1), nw)
                    iw := ww(p1)
                cons(j, wi_l) = iw => "skip"
                nw := inv(nw)
                rhr := strip(nw, #orbd, true, orbd, grpv, wordv)
                rh := concat(iw, rhr.lst)
                -- print(rh::OutputForm)
                rl : L I := []
                for k in rh repeat
                    rl := cons(-k, rl)
                ll : L I := []
                for k in qelt(ww, i) repeat
                    ll := cons(k, ll)
                ll := reverse!(ll)
                rl := concat(ll, rl)
                rl := cons(j, rl)
                -- print(rl::OutputForm)
                res := cons(rl, res)
        res

    relations_in_strong_generators(orbd : V REC, grpv : V V NNI
                                  ) : L L I ==
        k := #orbd
        m := #grpv
        res : L L I := []
        bl : L NNI := []
        for i in 1..k repeat
            orbi := qelt(orbd, i)
            bl := cons(first(orbi.orb), bl)
        gri_l : L NNI := [m]
        blp := bl
        -- print(blp::OutputForm)
        p1 := first(blp)
        blp := rest(blp)
        for j in m..1 by -1 repeat
            gv := qelt(grpv, j)
            p2 := qelt(gv, p1)
            -- print(p2::OutputForm)
            if p1 = p2 then
                gri_l := cons(j, gri_l)
                empty?(blp) => break
                p1 := first(blp)
                blp := rest(blp)
        -- print(gri_l :: OutputForm)
        for p0 in reverse(bl) for m1 in gri_l repeat
            res := concat(relations_for_orbit(p0, m1, orbd, grpv), res)
        res

  --now the exported functions

    relationsInStrongGenerators(gp : %) : L(L(I)) ==
        knownGroup?(gp)
        gi := gp.information
        grpv := vector(gi.sgset)$V(V(NNI))
        relations_in_strong_generators(gi.orbs, grpv)

    relationsInGenerators(gp : %) : L(L(I)) ==
        gi := gp.information
        if #(gi.wd) = 0 then
            initializeGroupForWordProblem(gp)
            gi := gp.information
        grpv := vector(gi.sgset)$V(V(NNI))
        orbd := gi.orbs
        srels := relations_in_strong_generators(orbd, grpv)
        words := new(#(gi.wd), empty())$V(L(I))
        iwords := new(#words, empty())$V(L(I))
        for i in 1..#words for wli in gi.wd repeat
           words(i) := [j for j in wli]
           iwd := []$L(I)
           for j in wli repeat
               iwd := cons(-j, iwd)
           iwords(i) := iwd
        res : L(L(I)) := []
        for srel in srels repeat
            nrel : L(I) := []
            for i in srel repeat
                cw :=
                    i > 0 => qelt(words, i)
                    qelt(iwords, -i)
                for j in cw repeat
                    nrel := cons(j, nrel)
            res := cons(reverse!(nrel), res)
        supp := pointList(gp)
        nn := #supp
        n0 := #grpv
        wordv := new(n0, empty())$(V L NNI)
        for i in 1..n0 repeat
            wordv(i) := [i]
        for i in 1..#words for ggp in gp.gens repeat
            q := perm_to_vec(supp, ggp, nn)
            rhr := strip(q, #orbd, true, orbd, grpv, wordv)
            nrel : L(I) := []
            for j in rhr.lst repeat
                cw := words(j)
                for k in cw repeat
                    nrel := cons(k, nrel)
            nrel := reverse!(nrel)
            nrel := cons(i, nrel)
            res := cons(nrel, res)
        res

    coerce(gp : %) : L PERM S == gp.gens
    generators(gp : %) : L PERM S == gp.gens

    strongGenerators(group) ==
        knownGroup? group
        gr_supp := group.information.mp
        gr_sgs := group.information.sgset
        degree := # gr_supp
        strongGens := []$(L PERM S)
        for i in gr_sgs repeat
            pairs := []$(L L S)
            for j in 1..degree repeat
                pairs := cons([ gr_supp.j, gr_supp.(i.j)], pairs)
            strongGens := cons(coerceListOfPairs pairs, strongGens)
        reverse strongGens

    elt(gp, i) == (gp.gens).i

    movedPoints(gp) == set(pointList(gp))

    random(group, maximalNumberOfFactors) ==
        maximalNumberOfFactors < 1 => 1$(PERM S)
        gp : L PERM S := group.gens
        numberOfGenerators := # gp
        randomInteger : I  := 1 + random(numberOfGenerators)$Integer
        randomElement      := gp.randomInteger
        numberOfLoops : I  := 1 + random(maximalNumberOfFactors)$Integer
        while numberOfLoops > 0 repeat
            randomInteger : I  := 1 + random(numberOfGenerators)$Integer
            randomElement := gp.randomInteger * randomElement
            numberOfLoops := numberOfLoops - 1
        randomElement

    random(group) == random(group, 20)

    order(group) ==
        knownGroup? group
        group.information.order

    degree(group) == # pointList group

    base(group) ==
        knownGroup? group
        gr_base := group.information.gpbase
        gr_supp := group.information.mp
        groupBase := []$(L S)
        for i in gr_base repeat
            groupBase := cons(gr_supp.i, groupBase)
        reverse groupBase

    wordsForStrongGenerators(group) ==
        gi := group.information
        if #(gi.wd) = 0 then
            initializeGroupForWordProblem(group)
            gi := group.information
        gi.wd

    coerce (gp : L PERM S) : % ==
        result : REC2 := [0, [], [], [], [], []]
        group         := [gp, result]

    permutationGroup (gp : L PERM S) : % ==
        result : REC2 := [0, [], [], [], [], []]
        group         := [gp, result]

    coerce(group : %) : OUT ==
        outList := []$(L OUT)
        gp : L PERM S := group.gens
        for i in (maxIndex gp)..1 by -1 repeat
            outList := cons(coerce gp.i, outList)
        postfix(outputForm(">"::SYM),
                postfix(commaSeparate outList, outputForm("<"::SYM)))

    orbit(gp : %, el : S) : FSET S ==
        elList : L S := [el]
        outList      := orbitInternal(gp, elList)
        outSet       := empty()$(FSET S)
        for i in 1..#outList repeat
            insert!(outList.i.1, outSet )
        outSet

    orbits(gp) ==
        spp    := movedPoints(gp)
        orbits := []$(L FSET S)
        while cardinality spp > 0 repeat
            el       := extract! spp
            orbitSet := orbit(gp, el)
            orbits   := cons(orbitSet, orbits)
            spp      := difference(spp, orbitSet)
        set(orbits)

    member? (p, gp) ==
        mi := memberInternal(p, gp, false)
        mi.bool

    wordInStrongGenerators (p, gp) ==
        mi := memberInternal(inv p, gp, true)
        not mi.bool => error "p is not an element of gp"
        mi.lst

    wordInGenerators(p, gp) ==
        gp_info := gp.information
        if #(gp_info.wd) = 0 then
            initializeGroupForWordProblem gp
            gp_info := gp.information
        lll : L NNI := wordInStrongGenerators(p, gp)
        outlist := []$(L NNI)
        words := gp.information.wd
        for n in lll repeat
            outlist := append (outlist, words(n))
        shortenWord(outlist, gp)

    gp1 < gp2 ==
        not empty? difference(movedPoints gp1, movedPoints gp2) => false
        not subgroup(gp1, gp2) => false
        order(gp1) = order(gp2) => false
        true

    gp1 <= gp2 ==
        not empty? difference(movedPoints gp1, movedPoints gp2) => false
        subgroup(gp1, gp2)

    gp1 = gp2 ==
        movedPoints gp1 ~= movedPoints gp2 => false
        if #(gp1.gens) <= #(gp2.gens) then
            not subgroup(gp1, gp2) => return false
        else
            not subgroup(gp2, gp1) => return false
        order(gp1) = order(gp2) => true
        false

    orbit(gp : %, startSet : FSET S) : FSET FSET S ==
        startList : L S := parts startSet
        outList         := orbitInternal (gp, startList)
        outSet          := empty()$(FSET FSET S)
        for i in 1..#outList repeat
            newSet : FSET S := set(outList.i)
            insert!(newSet, outSet)
        outSet

    orbit(gp : %, startList : L S) : FSET L S ==
        set(orbitInternal(gp, startList))

    initializeGroupForWordProblem(gp, maxLoops, diff) ==
        bsgs(gp, true, maxLoops, diff)
        void

    initializeGroupForWordProblem(gp) ==
        initializeGroupForWordProblem(gp, 0, 1)

