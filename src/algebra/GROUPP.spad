)abbrev domain GROUPP GroupPresentation
++ Author: Martin Baker
++ Description:
++   Group represented by its generators and relations.
++   Here we use it to hold homotopy group such as fundamental group.
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/finiteGroup/presentation/
++ Date Created: Jan 2016
++ Basic Operations:
++ Related packages:
++ Related categories:
++ Related Domains: PermutationGroup
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:

GroupPresentation() : Exports == Impl where
  NNI ==> NonNegativeInteger
  PI ==> PositiveInteger
  x<<y ==> hconcat(x::OutputForm, y::OutputForm)
  GENMAP ==> List(Record(OldGen : NNI, NewGen : NNI))
  Exports ==> SetCategory() with
    groupPresentation : (v : List(NNI), rels1 : List(List(Integer))) -> %
      ++ construct from generators and relations
    groupPresentation : (v : List(NNI)) -> %
      ++ construct free group with generators but no relations
    groupPresentation : () -> %
      ++ construct trivial group with no generators or relations
    simplify : (s : %) -> %
      ++ There may not be a simplest form but it is possible to
      ++ do some simplifications as follows:
      ++ 1. Remove all zero terms in relations.
      ++ 2. If a relation consists of a single generator then remove
      ++    that generator.
      ++ 3. If a relation consists of a pair of generators then make the
      ++    second generator the inverse of the first.
      ++ 4. If a generator is adjacent to its inverse then cancel them out.
      ++ 5. Remove duplicate relations.
      ++ 6. Substitute one relation in another.
    simplify : (s : %, trace : Boolean) -> %
      ++ simplify with option to trace
    refactor : (a : %) -> %
      ++ actual value of generators is not important, it is only important that
      ++ they correspond to the appropriate entries in the relations.
      ++ Therefore we can refactor the generators without changing the
      ++ group represented.
    quotient : (a : %, remgen : List(NNI)) -> %
      ++ take quotient by removing generators specified by remgen
    quotient : (a : %, addrel : List(List(Integer))) -> %
      ++ take quotient by adding relations specified by addrel
    directProduct : (a : %, b : %) -> %
      ++ directProduct of two groups
    cyclicGroup : (n : PI) -> %
      ++ cyclicGroup(n) constructs the cyclic group of order n acting
      ++ on the integers 1, ..., n.
    dihedralGroup : (n : PI) -> %
      ++ dihedralGroup(n) constructs the dihedral group of order 2n
      ++ acting on integers 1, ..., N.
    symmetricGroup : (n : PI) -> %
      ++ symmetricGroup(n) constructs the symmetric group of order n-1.
      ++ Note: generates all possible relations may not be minimal.
    toPermutationIfCan : (a : %) -> Union(PermutationGroup Integer, "failed")
      ++ convert to permutation group return "failed" for infinite groups.
      ++ For more information about the algorithm see:
      ++ \url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/finiteGroup/pres2perm/}
    toPermutationIfCan : (a : %, trace : Boolean)
                          -> Union(PermutationGroup Integer, "failed")
      ++ convert to permutation group return "failed" for infinite groups.
      ++ For more information about the algorithm see:
      ++ \url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/finiteGroup/pres2perm/}
    toPermutationIfCan : (a : %, sg : List(List(Integer)), trace : Boolean)
                          -> Union(PermutationGroup Integer, "failed")
      ++ toPermutationIfCan(a, sg, trace) returns permutation
      ++ representation of a on cosets of subgroup generate by sg
      ++ or "failed" if computation exceed resource limit.
      ++ trace activates debugging printouts.

  Impl ==> add

   -- Representation holds the group as a set of generators and a set of
   -- relations.
   -- Each generator is a NNI
   -- Each relation is a list of indexes to generators.
   -- if index is positive it represents a generator output as an
   -- alphabetic digit followed by number if required.
   -- if index is zero it represents identity output as 'e'.
   -- if index is negative it represents an inverse generator.

   Rep := Record(gens : PrimitiveArray(NNI), rels : List(List(Integer)))

   -- construct from generators and relations
   groupPresentation(gens1 : List(NNI), rels1 : List(List(Integer))) : % ==
       -- print("  groupPresentation construct (" << gens1 << ", "
       --       << rels1<< ")")
       g := construct(gens1)$PrimitiveArray(NNI)
       --print("groupPresentation constuct : " << rels1)
       -- remove empty relations since this simplifies equality function
       [g, [r for r in rels1 | not(empty?(r))]]

   -- construct free group with generators but no relations
   groupPresentation(gens1 : List(NNI)) : % ==
       -- print("  groupPresentation construct (" << gens1 << ", "
       --       << rels1<< ")")
       g := construct(gens1)$PrimitiveArray(NNI)
       rels2 := []$List(List(Integer))
       [g, rels2]

   -- construct trivial group with no generators or relations
   groupPresentation() : % ==
       gens1 := []$List(NNI)
       rels1 := []$List(List(Integer))
       groupPresentation(gens1, rels1)

   -- Local function used by refactor to map a given generator in a relation.
   mapGen(a : Integer, ms : GENMAP) : Integer ==
       for m  in ms repeat
           if abs(a) = m.OldGen then return m.NewGen
           if abs(a) = -m.OldGen then return -m.NewGen
       error concat(["cant map ", string(a), " in refactor"])
       a

   -- Actual value of generators is not important, it is only important that
   -- they correspond to the appropriate entries in the relations.
   -- Therefore we can refactor the generators (to be ascending integers
   -- starting as 1) without changing the group represented.
   refactor(a : %) : % ==
       -- first generate a map from existing generators to new generators
       gms : GENMAP := empty()$GENMAP
       for g in entries(a.gens) for gn in 1..(#(a.gens)) repeat
           gm : Record(OldGen : NNI, NewGen : NNI) := [g, gn]
           gms := concat(gms, gm)
       -- now use this map to change elements of relations
       rels1 := []$List(List(Integer))
       for rel in a.rels repeat
           newRel : List(Integer) := empty()$List(Integer)
           for ele in rel repeat
               newEle : Integer := mapGen(ele, gms)
               newRel := concat(newRel, newEle)
           rels1 := concat(rels1, newRel)
       gens1 : List(NNI) := [gn for gn in 1..(#(a.gens))]
       groupPresentation(gens1, rels1)

   -- Isomorphism is the most useful level of 'equality' for
   -- groups but unfortunately this is not computable in
   -- the general case for presentations.
   -- Although exact equality is less useful it is still useful to
   -- compare very simple presentations in the validation code which
   -- is useful to give some level of confidence that the
   -- correct presentation was generated.
   -- TODO result can be dependent on initial generator order, for
   -- example <a, b | a*a, b*b*b> = <b, a | a*a, b*b*b> would be false
   -- should really check all permutations of generators and return
   -- true if any of them gives equality.
   _=(a : %, b : %) : Boolean ==
       ar : % := refactor(a)
       br : % := refactor(b)
       ags : List(NNI) := entries(ar.gens)
       bgs : List(NNI) := entries(br.gens)
       if set(ags)$Set(NNI) ~= set(bgs)$Set(NNI) then return false
       ars : List(List(Integer)) := entries(ar.rels)
       brs : List(List(Integer)) := entries(br.rels)
       set(ars)$Set(List(Integer)) = set(brs)$Set(List(Integer))

   -- Display generators as alphabetic digits
   -- Local function used by coerce to OutputForm and other functions.
   -- if i2 is positive it represents a generator shown as an
   -- alphabetic digit followed by number if required.
   -- if i2 is zero it represents identity shown as 'e'.
   -- if i2 is negative it represents an inverse generator.
   -- The notation uses '-' to indicate an inverse generator (I know
   -- this is an abuse of notation, because the group is not
   -- necessarily Abelian). I don't like the alternatives,
   -- '-1' exponent uses too much space and upper case for inverses
   -- may not be clear to people who don't read documentation.
   outputGen(i2 : Integer) : OutputForm ==
       (suffix, i) := divide(abs(i2), 25)
       letters : String := "eabcdfghijklmnopqrstuvwxyz"
       n : OutputForm := (letters(i + 1))::OutputForm
       -- print("  groupPresentation outputGen(" << i2 <<
       --       ") gives " << n)
       if suffix > 0 then n := hconcat(n, outputForm(suffix + 1))
       if i2 < 0 then return hconcat(message"-", n)
       n

   -- display a relation using alphabetic digits
   outputRel(r : List(Integer)) : OutputForm ==
       eleout : OutputForm := message("")
       seperator : OutputForm := message(" ")
       for ele in r repeat
           newterm : OutputForm := outputGen(ele)
           eleout := hconcat([eleout, seperator, newterm])$OutputForm
           seperator := message("*")
       eleout

   -- display a list of relations using alphabetic digits
   outputRelList(i2 : List(List(Integer))) : OutputForm ==
       rels1 : List(OutputForm) := []$List(OutputForm)
       for r in i2 repeat
           rels1 := concat(rels1,outputRel(r))
       if #rels1 > 0 then return commaSeparate(rels1)
       message(" ")

   -- display a list of generators using alphabetic digits
   outputGenList(ps : List(NNI)) : OutputForm ==
       gens1 : List(OutputForm) := []$List(OutputForm)
       for p in ps repeat
           gens1 := concat(gens1, outputGen(p::Integer))
       if #gens1 > 0 then return blankSeparate(gens1)
       message(" ")

   -- local function to return indexes to each relation containing a given
   -- generator.
   indexesOfRelUsingGen(s : %, gen : NNI) : List(NNI) ==
       res : List(NNI) := []
       r : List(List(Integer)) := s.rels
       for rel in r for reln in 1..(#r) repeat
           if member?(gen::Integer,rel) then res := concat(res,reln)
           if gen > 0 and member?(-(gen::Integer),rel)
               then res := concat(res,reln)
       res

   -- local function to remove generator 'val' from generators
   removeGen(gens1 : PrimitiveArray(NNI), val : NNI) : PrimitiveArray(NNI) ==
       remove(val, gens1)

   -- local function to remove generator 'val' from relations
   removeGen2(rels1 : List(List(Integer)), val : NNI) : List(List(Integer)) ==
       [remove(-val, remove(val::Integer, rel)) for rel in rels1]

   -- local function to replace generator 'val1' with 'val2'
   -- in relations
   replaceGen(rels1 : List(List(Integer)), val1 : NNI, val2 : Integer
             ) : List(List(Integer)) ==
       --print("  groupPresentation replaceGen=" << rels1 << _
       --      " val1=" << val1 << " val2=" << val2)
       rels2 := []$List(List(Integer))
       for rel in rels1 repeat
           rel2 := []$List(Integer)
           for ele in rel repeat
               e : Integer := abs(ele)
               if e = val1 then e := val2
               if ele < 0 then e := -e
               rel2 := concat(rel2, e)
           rels2 := concat(rels2, rel2)
       rels2

   -- Tietze Transformation to remove a generator that is equal to
   -- the identity element. That is there is a relation containing only one
   -- generator.
   -- This procedure searches for a single element relation, if found, it
   -- removes the corresponding generator and also removes it from
   -- any relations containing it.
   -- This procedure only removes one generator, if there are several
   -- such relations then this procedure needs to be called several times.
   -- This is a local function used by simplify.
   TTRemoveGeneratorIfIdentity(s : %, trace : Boolean) : % ==
       gens1 : PrimitiveArray(NNI) := s.gens
       rels1 : List(List(Integer)) := s.rels
       toBeRemoved : NNI := 0
       for rel in rels1 repeat
           if #rel = 1 and toBeRemoved = 0 then
               toBeRemoved := qcoerce(abs(first(rel)))
       if toBeRemoved = 0 then return s
       if trace then
           print hconcat([message("simplify: generator '"), _
               outputGen(toBeRemoved), _
               message("' is identity so remove it")])
       gens1 := removeGen(gens1, toBeRemoved)
       rels1 := removeGen2(rels1, toBeRemoved)
       if trace then print outputRelList(rels1)
       [gens1, rels1]

   -- Tietze Transformation to rename a generator.
   -- If a relation consists of a pair of generators then make the
   -- second generator the inverse of the first.
   -- This procedure searches for a two element relation, if found, it
   -- replaces the second element with the inverse of the first.
   -- This procedure only replaces one generator, if there are several
   -- such relations then this procedure needs to be called several times.
   -- This is a local function used by simplify.
   TTRenameGenerator(s : %, trace : Boolean) : % ==
       gens1 : PrimitiveArray(NNI) := s.gens
       rels1 : List(List(Integer)) := s.rels
       replaceFrom : NNI := 0
       replaceTo : Integer := 0
       for rel in rels1 repeat
           if #rel = 2 and replaceFrom = 0 then
               replaceTo := second(rel)
               replaceFrom := qcoerce(abs(first(rel)))
               if first(rel) > 0 then replaceTo := -replaceTo
               -- don't replace an element with itself or its inverse
               if replaceFrom = abs(replaceTo) then replaceFrom := 0
       if replaceFrom=0 then return s
       if trace then
           print hconcat([message("simplify: generator '"), _
               outputGen(replaceFrom), _
               message("' is replaced by '"), _
               outputGen(replaceTo), _
               message("'")])
       gens1 := removeGen(gens1, replaceFrom)
       rels1 := replaceGen(rels1, replaceFrom, replaceTo)
       if trace then print outputRelList(rels1)
       [gens1, rels1]

   -- This is a local function used by simplify.
   TTRemoveEmpty(s : %, trace : Boolean) : % ==
       gens1 : PrimitiveArray(NNI) := s.gens
       rels1 : List(List(Integer)) := s.rels
       rels2 : List(List(Integer)) := empty()$List(List(Integer))
       for rel in rels1 repeat
           --print("  groupPresentation simplify rel=" << rel)
           if not empty?(rel) then
               rels2 := concat(rels2, rel)
       [gens1, rels2]

   -- This is a local function used by simplify.
   TTRemoveZero(s : %, trace : Boolean) : % ==
       gens1 : PrimitiveArray(NNI) := s.gens
       rels1 : List(List(Integer)) := s.rels
       gens1 := removeGen(gens1, 0)
       rels1 := removeGen2(rels1, 0)
       [gens1, rels1]


   -- This is a local function used by simplify.
   TTRemoveEleTimesInverse(s : %, trace : Boolean) : % ==
       gens1 : PrimitiveArray(NNI) := s.gens
       rels1 : List(List(Integer)) := s.rels
       --print("TTRemoveEleTimesInverse relations in =" << rels1)
       rels2 : List(List(Integer)) := empty()$List(List(Integer))
       changed : Boolean := false
       for rel in rels1 repeat
           --print("TTRemoveEleTimesInverse rel=" << rel)
           rel2 : List(Integer) := empty()$List(Integer)
           lastele : Integer := 0
           for ele in rel repeat
               if abs(ele) = abs(lastele) and sign(ele) ~= sign(lastele) then
                   if trace then print hconcat([_
                       message("simplify: generator '"), _
                       outputGen(ele), _
                       message("' is adjacent to its inverse")])
                   changed := true
                   lastele := 0
               else
                   if lastele ~= 0 then rel2 := concat(rel2, lastele)
                   lastele := ele
           if lastele ~= 0 then rel2 := concat(rel2, lastele)
           if not empty?(rel2) then rels2 := concat(rels2, rel2)
       if trace and changed then print outputRelList(rels2)
       [gens1, rels2]

   -- local function to invert relation. Used by TTSubstitute,
   -- TTMinimiseInverses and relationEquivalent.
   -- We invert each element and then reverse the order.
   -- A bit like De Morgan's laws
   invertRelation(relationIn : List(Integer)) : List(Integer) ==
       relationOut := []$List(Integer)
       for ele in relationIn repeat
           relationOut := concat(-ele, relationOut)
       relationOut

   -- local function to cycle relation. Used by relationEquivalent.
   -- The effect of a relation is not changed by cycling
   cycleRelation(relationIn : List(Integer)) : List(Integer) ==
       relationOut : List(Integer) := concat(relationIn.rest,relationIn.first)
       --print(message "cycleRelation " << relationIn << message " to " << relationOut)
       relationOut

   -- Local function to test equivalence of two relations.
   -- Used by TTRemoveDuplicateRelation.
   -- Relations are considered equivalent if they are identical or
   -- if they are the same after being cycled or if they are the
   -- same after being inverted.
   relationEquivalent(relA : List(Integer),relB : List(Integer)) : Boolean ==
       -- first filter out cases where relations are different lengths
       if #relA ~= #relB then return false
       -- test for equality
       if relA = relB then return true
       -- test for equality with inverted.
       if relA = invertRelation(relB) then return true
       -- test for equality with cycle
       relBCycle : List(Integer) := copy relB
       for n in 1..(#relA) repeat
           relBCycle := cycleRelation(relBCycle)
           if relA = relBCycle then return true
           if relA = invertRelation(relBCycle) then return true
       false

   -- This is a local function used by simplify.
   -- It looks for and removes any duplicated relations.
   -- Relations are considered duplicates if they are identical or
   -- if they are the same after being cycled or if they are the
   -- same after being inverted.
   TTRemoveDuplicateRelation(s : %, trace : Boolean) : % ==
       gens1 : PrimitiveArray(NNI) := s.gens
       rels1 : List(List(Integer)) := s.rels
       rels2 := []$List(List(Integer))
       --print(message "TTRemoveDuplicateRelation =" << rels1)
       for rela in rels1 for nrela in 1..(#rels1) repeat
           -- include relation
           include : Boolean := true
           for relb in rels1 for nrelb in 1..(#rels1) repeat
               if nrela > nrelb then
                   if relationEquivalent(rela,relb) then
                       include : Boolean := false
                       if trace then
                           m ==> "TTRemoveDuplicateRelation duplicate found "
                           print(message m << rela << message "=" << relb)
           if include then
               rels2 := concat(rels2, rela)
       [gens1, rels2]

   -- This is a local function used by simplify.
   -- If a relation contains more inverted elements that non-inverted
   -- elements then it is easier to read if we invert all the terms.
   TTMinimiseInverses(s : %, trace : Boolean) : % ==
       gens1 : PrimitiveArray(NNI) := s.gens
       rels1 : List(List(Integer)) := s.rels
       rels2 := []$List(List(Integer))
       for rel in rels1 repeat
           numInverts : NNI := 0
           numNonInverts : NNI := 0
           for ele in rel repeat
               if ele < 0 then
                   numInverts := numInverts + 1
               else
                   numNonInverts := numNonInverts + 1
           if numInverts > numNonInverts then
               rels2 := concat(rels2, invertRelation(rel))
           else
               rels2 := concat(rels2, rel)
       [gens1, rels2]

   -- This is a local function used by TTSubstitute.
   -- Counts the number of times a generator (or its inverse) occurs
   -- in a relation.
   generatorOccurrences(rel : List(Integer),gen : NNI) : NNI ==
       res : NNI := 0
       for g in rel repeat
           if g = gen then res := res + 1
           if gen > 0 and g = -gen then res := res + 1
       res

   -- local function to remove relations containing given generator
   removeRelations(rels1 : List(List(Integer)), val : NNI
                  ) : List(List(Integer)) ==
       res : List(List(Integer)) := []$List(List(Integer))
       for rel in rels1 repeat
           if (not member?(val,rel)) and (not member?(-val,rel))then
               res := concat(res,rel)
       res

   -- This is a local function used by simplify.
   -- If a generator is contained in exactly 2 relations then we may be
   -- able to substitute one relation in another and remove that generator.
   -- If, in at least one of these relations, the generator is contained
   -- only once then we can move it to one side of the equation and
   -- substitute it in the other relation.
   TTSubstitute(s : %, trace : Boolean) : % ==
       gs : List(NNI) := entries(s.gens)
       rs : List(List(Integer)) := s.rels
       r1 : List(Integer) := []
       r2 : List(Integer) := []
       n1 : NNI := 0
       n2 : NNI := 0
       genToBeRemoved : NNI := 0
       for g in gs repeat
           indexes : List(NNI) := indexesOfRelUsingGen(s, g)
           if #indexes = 2 and genToBeRemoved=0 then
               -- we have a candidate for substitution but, to be
               -- sure generator must occur once in a relation
               genToBeRemoved := g
               r1 := rs.(indexes.1)
               r2 := rs.(indexes.2)
               n1 := generatorOccurrences(r1,g)
               n2 := generatorOccurrences(r2,g)
               if n1 ~= 1::NNI then
                   -- swap first and second relations
                   r3 : List(Integer) := r1 ; n3 : NNI := n1
                   r1 := r2 ; n1 := n2
                   r2 := r3 ; n2 := n3
               if n1 ~= 1::NNI then
                   genToBeRemoved := 0
       if n1 ~= 1::NNI then return s
       -- If we have got to this point then we know a substitution
       -- is possible.
       if trace then
           print(message("simplify: TTSubstitute (") << s << message(")"))
           print(message("genToBeRemoved=") << outputGen(genToBeRemoved) << _
                 message(" r1=") << outputRel(r1) <<
                 message(" r2=") << outputRel(r2))
           print(message("n1=") << n1 << message(" n2=") << n2)
       restr : List(Integer) := r1
       prer  : List(Integer) := []
       found : Boolean := false
       genInverted : Boolean := false
       while (not empty?(restr)) and (not found)repeat
           x : Integer := first(restr)
           restr := rest(restr)
           if x=genToBeRemoved or x= -genToBeRemoved
               then
                   found := true
                   if x<0 then genInverted := true
               else prer := concat(prer,x)
       postr  : List(Integer) := []
       while not empty?(restr) repeat
           x : Integer := first(restr)
           restr := rest(restr)
           postr := concat(postr,x)
       replacement := concat(invertRelation(prer),invertRelation(postr))
       -- now substitute replacement for genToBeRemoved in r2
       if trace then
           print(message("we will substitute ") << outputRel(replacement) <<
                 message(" for ") << outputGen(genToBeRemoved) <<
                 message(" in ") << outputRel(r2))
       newRel : List(Integer) := []
       for x in r2 repeat
           if abs(x)=abs(genToBeRemoved)
             then
                 if genInverted
                     then newRel := concat(newRel,invertRelation(replacement))
                     else newRel := concat(newRel,replacement)
             else newRel := concat(newRel,x)
       if trace then print(message("newRel=") << outputRel(newRel))
       gens1 : PrimitiveArray(NNI) := s.gens
       rels1 : List(List(Integer)) := s.rels
       gens1 := removeGen(gens1, genToBeRemoved)
       rels1 := removeRelations(rels1, genToBeRemoved)
       rels1 := concat(rels1,newRel)
       if trace then print(message("gens=") << outputGenList(entries(gens1))
                           << message(" rels=") << outputRelList(rels1))
       [gens1, rels1]

   -- true if 'a' is simpler than 'b'.
   -- There may not be an absolute measure of whether one presentation
   -- is simpler than another but this procedure is used only in specific
   -- circumstances, that is where we have attempted to simplify the
   -- presentation and we want to test if it is actually simpler.
   -- We do this by testing if the number of generators or relations has
   -- reduced or if the complexity of the relations has reduced.
   -- This is a local function used by simplify.
   isSimpler?(a : %, b : %) : Boolean ==
       gensa : PrimitiveArray(NNI) := a.gens
       relsa : List(List(Integer)) := a.rels
       gensb : PrimitiveArray(NNI) := b.gens
       relsb : List(List(Integer)) := b.rels
       if #gensa < #gensb then return true
       if #relsa < #relsb then return true
       relationCompleityA : NNI := 0
       for rel in relsa repeat
           relationCompleityA := relationCompleityA + #rel
       relationCompleityB : NNI := 0
       for rel in relsb repeat
           relationCompleityB := relationCompleityB + #rel
       if relationCompleityA < relationCompleityB then return true
       false

   simplify(s : %) : % ==
       simplify(s, false)

   -- There may not be a simplest form but it is possible to
   -- do some simplifications as follows:
   -- 1) remove all zero terms in relations
   -- 2) if a relation consists of a single generator then remove that
   --    generator
   -- 3) if a relation consists of a pair of generators then make the
   --    second generator the inverse of the first
   -- 4) if a generator is adjacent to its inverse then cancel them out.
   -- 5) remove duplicate relations
   -- 6) Substitute one relation in another
   simplify(s : %, trace : Boolean) : % ==
       if trace then
           print(message("simplify(") << s << message(")"))
       res : % := s
       lastpass : % := s
       level : NNI := 0
       loopBreaker : NNI := 0
       while loopBreaker < 10000 repeat
           loopBreaker := loopBreaker + 1
           if level=0 then res := TTRemoveEmpty(res, trace)
           if level=1 then res := TTRemoveZero(res, trace)
           if level=2 then res := TTRemoveGeneratorIfIdentity(res, trace)
           if level=3 then res := TTRenameGenerator(res, trace)
           if level=4 then res := TTRemoveEleTimesInverse(res, trace)
           if level=5 then res := TTRemoveDuplicateRelation(res, trace)
           if level=6 then res := TTSubstitute(res, trace)
           if level=7 then return TTMinimiseInverses(res, trace)
           if isSimpler?(res, lastpass)
               then level := 0
               else level := level + 1
           if trace then
               print(message(" level=") << level << _
                     message(" loop=") << loopBreaker << _
                     message(" res=") << res)
           lastpass := res
       print(message("simplify excessive time - loop suspected") << s)
       res

   -- local function used by directProduct to offset indexes
   offsetIndexes(a : %, offset : NNI) : % ==
       ga : List(NNI) := entries(a.gens)
       ra : List(List(Integer)) := a.rels
       gb := [x+offset for x in ga]
       rb := [[(if y > 0 then y + offset else y - offset) for y in z]
                  for z in ra]
       groupPresentation(gb, rb)

   -- take quotient by removing generators specified by remgen
   quotient(a : %, remgen : List(NNI)) : % ==
       gens1 : PrimitiveArray(NNI) := a.gens
       rels1 : List(List(Integer)) := a.rels
       for toBeRemoved in remgen repeat
           gens1 := removeGen(gens1, toBeRemoved)
           rels1 := removeGen2(rels1, toBeRemoved)
       simplify(groupPresentation(entries(gens1), rels1))

   -- take quotient by adding relations specified by addrel
   quotient(a : %, addrel : List(List(Integer))) : % ==
       gens1 : List(NNI) := entries(a.gens)
       rels1 : List(List(Integer)) := a.rels
       simplify(groupPresentation(entries(gens1), concat(rels1,addrel)))

   -- directProduct of two groups
   directProduct(a : %, b : %) : % ==
       a2 : % := refactor(a)
       ga : List(NNI) := entries(a2.gens)
       ra : List(List(Integer)) := a2.rels
       sa : NNI := #ga
       b2 : % := offsetIndexes(refactor(b), sa)
       gb : List(NNI) := entries(b2.gens)
       rb : List(List(Integer)) := b2.rels
       rc : List(List(Integer)) := []
       for gax in ga repeat
           for gbx in gb repeat
               gcx : List(Integer) := [gax::Integer, gbx::Integer,
                                       gax::Integer, gbx::Integer]
               rc := concat(rc,gcx)
       groupPresentation(concat(entries(ga), gb), concat([ra, rb, rc]))

   -- cyclicGroup(n) constructs the cyclic group of order n acting
   -- on the integers 1, ..., n.
   cyclicGroup(n : PI) : % ==
       ga : List(NNI) := [1]
       ra : List(List(Integer)) := [[1 for x in 1..(n@Integer)]]
       groupPresentation(ga, ra)

   -- dihedralGroup(n) constructs the dihedral group of order 2n
   -- acting on integers 1, ..., n.
   dihedralGroup(n : PI) : % ==
       c1 : % := cyclicGroup(n)
       c2 : % := cyclicGroup(2)
       directProduct(c1, c2)

   -- symmetricGroup(n) constructs the symmetric group of order n-1.
   symmetricGroup(n : PI) : % ==
       if n<2 then return groupPresentation([])
       m : PI := (n-1) :: PI
       ga : List(NNI) := [x for x in 1..m]
       r : List(List(Integer)) := []$List(List(Integer))
       for a in 1..m repeat
           for b in 1..m repeat
               if a = b then
                   -- all generators square to 1
                   y : List(Integer) := [a,a]
                   r := cons(y, r)
               if a + 1 < b then
                   -- non squares commute
                   y : List(Integer) := [a,b,-a,-b]
                   r := cons(y, r)
               if a+1 = b then
                   -- swapping the ith and (i + 1)th position cubed
                   y : List(Integer) := [a,b,a,b,a,b]
                   r := cons(y, r)
       groupPresentation(ga, reverse!(r))

   A2D ==> TwoDimensionalArray NNI
   A1D ==> OneDimensionalArray NNI

   -- TC_state (Todd-Cox State)
   -- This holds tables while they are being built up during the
   -- Todd-Cox algorithm. Initially the elements of coset tables
   -- are set to zero then index values are incrementally
   -- derived during the algorithm. When complete the coset table
   -- will be used to determine the coset permutations.
   -- The components of this state are:
   -- coset_table          : A 2D array with
   --                      a row for each point
   --                      only 'number_of_indices' are used
   --                      other rows are empty.
   --                      a column for a generator/coset
   -- equiv_table          : Tracks coincidences
   --                      non-coincidences are self loops
   --                      coincidences are chained to non-coincidences
   -- inverse_table        : Inverse of generators (not yet used).
   -- number_of_generators : Actual number of distinct cosets.
   --                        So we can compress tables if there are
   --                        too many coincidences.
   -- number_of_indices    : allocated rows (may not be used) of
   --                        coset table.
   -- number_of_points     : size of set being permuted.
   TC_state ==> Record(coset_table : A2D, equiv_table : A1D,
                       inverse_table : A1D, closed_point : NNI,
                       number_of_generators : NNI,
                       number_of_indices : NNI, number_of_points : NNI,
                       max_number_of_indices : NNI)

   -- Local function to print CosetTable
   -- Using this avoids displaying empty rows that are not used yet.
   outCosetTable(ct : A2D,np : NNI) : OutputForm ==
       if np < 1 then return ct::OutputForm
       if nrows(ct) > np then
           part1 : NNI := np
           part2 : NNI := subtractIfCan(nrows(ct),np) :: NNI
           cts : List(A2D) := vertSplit(ct,[part1,part2])
           ct := cts.1
           --return ct::OutputForm << cts.2
       ct::OutputForm

   -- Local function to print status
   -- Using this avoids displaying empty rows that are not used yet.
   outStatus(state : TC_state) : OutputForm ==
       ct : A2D := state.coset_table
       np : NNI := state.number_of_indices
       outCosetTable(ct,np)

   -- Local function to find an index in equiv_table.
   -- Parameter information:
   -- et = equiv_table
   -- ind = index to be found
   find(et : A1D, ind : NNI) : NNI ==
       ind = 0 => ind
       qelt(et, ind) = ind => ind
       j := ind
       -- starting at ind follow pointer until j=pj
       pj := 0
       while not(j = pj) repeat
           pj := j
           j := qelt(et, j)
       j := ind
       -- track compression
       while not(j = pj) repeat
           nj := qelt(et, j)
           qsetelt!(et, j, pj)
           j := nj
       pj

   -- Local function to infer coincidencies
   -- Parameter information:
   -- ct = coset_table
   -- et = equiv_table
   -- pb = pointer begin
   -- pe = pointer end
   infer_coincidencies(ct : A2D, et : A1D, pb : NNI, pe : NNI,_
                       trace : Boolean) : Void ==
       if trace then print(message("coincidence: begin=") << pb _
                        << message(" end=") << pe)
       if pe < pb then
           (pb, pe) := (pe, pb)
       qsetelt!(et, pe, pb)
       nn := maxColIndex(ct)
       for i in 1..nn repeat
           i1 := qelt(ct, pb, i)
           i2 := qelt(ct, pe, i)
           i2 = 0 => "skip"
           if i1 = 0 then
               qsetelt!(ct, pb, i, i2)
       for i in 1..nn repeat
           i1 := qelt(ct, pb, i)
           i1 = 0 => "skip"
           i2 := qelt(ct, pe, i)
           i2 = 0 => "skip"
           i1 := find(et, i1)
           i2 := find(et, i2)
           i1 = i2 => "skip"
           infer_coincidencies(ct, et, i1, i2, trace)

   add_point ==>
        if n_ind >= o_size then
            n_ind = state.max_number_of_indices => return true
            n_size : NNI :=
                qcoerce(min(2*o_size, state.max_number_of_indices))
            n_ct_cols := maxColIndex(ct)
            nct := new(n_size, qcoerce(n_ct_cols), 0)$A2D
            net := new(n_size, 0)$A1D
            for i in 1..o_size repeat
                qsetelt!(net, i, qelt(et, i))
                for j in 1..n_ct_cols repeat
                    qsetelt!(nct, i, j, qelt(ct, i, j))
            for i in (o_size + 1)..n_size repeat
                qsetelt!(net, i, qcoerce(i))
            ct := nct
            et := net
            o_size := n_size
            state.coset_table := ct
            state.equiv_table := et
        n_ind := n_ind + 1
        if trace then
            print(message("adding action of ") << add_gen <<
                  message(" on ") << add_to << message(" to be ")
                  << n_ind)
        qsetelt!(ct, add_to, add_gen, n_ind)
        add_gen := inv_tab(add_gen)
        qsetelt!(ct, n_ind, add_gen, add_to)
        if trace then print outStatus(state)
        state.number_of_indices := n_ind


   -- Local function used by toPermutationIfCan.
   -- If we still have gaps (zeroes) in permutations then we may
   -- be able to infer a step from the relations.
   -- If there is a single step gap then we can use this to fill in
   -- information because relations are loops and therefore start and
   -- end with the same value.
   -- If permutations are changed then we return true.
   -- If so permutations is mutated.
   -- gensR is called as a Reference in case we need to
   -- eliminate duplicate points.
   inferFromRelations(state : TC_state, rels : List(List(NNI)),
                      rrels : List(List(NNI)), rel_lens : List(NNI),
                      trace : Boolean) : Boolean ==
       ct := state.coset_table
       et := state.equiv_table
       n_ind : NNI := state.number_of_indices
       inv_tab := state.inverse_table
       if trace then print(message "inferFromRelations rels=" << rels)
       add_to : NNI := 0
       add_gen : Integer := 0
       add_gap : Integer := 0
       pn := state.closed_point + 1
       pn > n_ind => false
       state.closed_point := pn
       not(qelt(et, pn) = pn) => true
       o_size := maxRowIndex(ct)
       closed := false
       while not(closed) repeat
           closed := true
           not(qelt(et, pn) = pn) => break
           for rel in rels for rrel in rrels for r_len in rel_lens repeat
               -- in rel look for gap of length 1
               gb : NNI := 0 -- generator index in forward sequence
               pb : NNI := pn -- point index in forward sequence
               -- how far can we get from beginning
               i : NNI := pn
               genIn : Integer := 0
               for genIndex in rel repeat
                   genIn := genIndex
                   i := qelt(ct, i, genIndex)
                   i = 0 => break
                   i := find(et, i)
                   gb := gb + 1
                   pb := i
               gap := r_len - gb
               ge : NNI := 0 -- generator index in backward sequence
               pe : NNI := pn -- point index in backward sequence
               -- how far can we get from end
               i : NNI := pn
               genInv : Integer := 0
               for genIndex in rrel while ge < gap repeat
                   genInv := genIndex
                   i := qelt(ct, i, genIndex)
                   i = 0 => break
                   i := find(et, i)
                   ge := ge + 1
                   pe := i
               gap := gap - ge
               if gap > 1 then
                   add_to := pb
                   add_gen := genIn
                   add_point
                   gap := gap - 1
                   prel := rel
                   for i in 0..gb repeat
                       prel := rest(prel)
                   gb := gb + 1
                   while gap > 1 repeat
                       add_to := n_ind
                       add_gen := first(prel)
                       prel := rest(prel)
                       add_point
                       gap := gap - 1
                       gb := gb + 1
                   pb := n_ind
                   genIn := first(prel)
               gap = 1 =>
                   not((npe := qelt(ct, pb, genIn)) = 0) =>
                       npe = pe => "skip"
                       if trace then
                           print(message("coincidence: ") << pe <<
                                message(" ") << npe <<
                                message(" rel = ") << rel <<
                                message(" pn = ") << pn)
                       infer_coincidencies(ct, et, pe, npe, trace)
                   if trace then
                       print(message "inferFromRelations genIn=" << genIn << _
                             message " gb=" << gb)
                   not(qelt(inv_tab, genIn) = genInv) => error "impossible 3"
                   qsetelt!(ct, pb, genIn, pe)
                   not((npb := qelt(ct, pe, genInv)) = 0) =>
                       npb = pb => "skip"
                       if trace then
                          print(message("coincidence: ") << npb <<
                                message(" ") << pb <<
                                message(" rel = ") << rel <<
                                message(" pn = ") << pn)
                       infer_coincidencies(ct, et, pb, npb, trace)
                   qsetelt!(ct, pe, genInv, pb)
               gap = 0 =>
                   pb = pe => "skip"
                   -- coincidence
                   if trace then
                      print(message("coincidence: ") << pb << message(" ") <<
                          pe << message(" rel = ") << rel << message(" pn = ")
                          << pn)
                      -- print(ct::OutputForm)
                   infer_coincidencies(ct, et, pb, pe, trace)
               error "impossible 4"

           if not(closed) then
               error "impossible 5"
       true

   -- Local function used by relatorTables.
   -- Invert a map that is implemented as a 1D table
   invertMap(a : TwoDimensionalArray NNI) : TwoDimensionalArray NNI ==
       invm : TwoDimensionalArray NNI := new(nrows(a),ncols(a),0)
       for x in 1..nrows(a) repeat
           i : NNI := elt(a,x,1)
           if i ~= 0 then
               setelt!(invm,i,1,x)
       --print(message "invertMap a=" << a << message " invm=" << invm)
       invm

   -- Local function to construct relator tables.
   -- Although relator tables are used when manually calculating
   -- Todd-Cod for computations it seems easier to construct
   -- dynamically as required. So this function only used for trace
   -- output.
   relatorTables(state : TC_state,_
                 rels : List(List(Integer))) : List A2D ==
       ct := state.coset_table
       np : NNI := state.number_of_indices
       --generators : A2D := deref(gensR)
       genLists : List A2D := _
                  horizSplit(ct,ncols(ct) :: PositiveInteger)
       invGenLists : List A2D :=
                            [invertMap(a) for a in genLists]
       relators : List A2D := []
       for r in rels repeat
           relator : A2D := new(0,0,0)
           fst : Boolean := true
           for g in r repeat
               gNum : NNI := abs(g) :: NNI
               relatorn : A2D := _
                   if g>0 then genLists.gNum else invGenLists.gNum
               --print(message "relatorTables genLists=" << genLists << _
               --      message " gNum=" << gNum)
               if fst
                   then
                       relator := relatorn
                       fst := false
                   else
                       relator := horizConcat(relator,relatorn)
           relatorTrim := relator
           if nrows(relatorTrim) > np then
               part1 : NNI := np
               part2 : NNI := subtractIfCan(nrows(relatorTrim),np) :: NNI
               cts : List(A2D) := vertSplit(relatorTrim,[part1,part2])
               relatorTrim := cts.1
           relators := concat(relators,relatorTrim)
       relators

   -- convert list of generators to PermutationGroup
   generators2Permutation(state : TC_state,
                          trace : Boolean) : PermutationGroup Integer ==
       ct := state.coset_table
       if trace then print(message "generators2Permutation generators=")
       n_gens := state.number_of_generators
       n_inds := state.number_of_indices
       et := state.equiv_table
       net := new(n_inds, 0)$A1D
       j : SingleInteger := 0
       for i in 1..n_inds repeat
           not(qelt(et, i) = i) => "skip"
           j := j + 1
           qsetelt!(net, i, qcoerce(convert(j)))
       perm_lists := new(n_gens, empty())$Vector(List(Integer))
       for i in 1..n_inds repeat
           not(qelt(et, i) = i) => "skip"
           for j in 1..n_gens repeat
               kk := qelt(ct, i, j)
               kk = 0 =>
                   print(message("i = ") << i << message(" j = ") <<
                         j << message(" ct(i) = ") << row(ct, i))
                   error "incomplete coset table"
               kk := qelt(net, find(et, kk))
               qsetelt!(perm_lists, j, cons(kk, qelt(perm_lists, j)))
       pl : List(Permutation(Integer)) := []
       if trace then print(perm_lists::OutputForm)
       for j in 1..n_gens repeat
           gl := reverse!(perm_lists(j))
           p := coerceImages(gl)$Permutation(Integer)
           pl := cons(p, pl)
       pl := reverse!(pl)
       permutationGroup(pl)

   -- Convert to permutation group. Return "failed" for infinite groups.
   toPermutationIfCan(a : %) : Union(PermutationGroup Integer, "failed") ==
       toPermutationIfCan(a,false)

   -- Convert to permutation group. Return "failed" for infinite groups.
   -- This function implements the Todd-Coxeter algorithm.
   -- For more information about the algorithm see:
   -- \url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/finiteGroup/pres2perm/}

   toPermutationIfCan(a : %,trace : Boolean
                     ) : Union(PermutationGroup Integer, "failed") ==
       toPermutationIfCan(a, [], trace)

   convert_words(words : List(List(Integer)), inv_tab : A1D
                ) : List(List(List(NNI))) ==
       nwords : List(List(NNI)) := []
       nrwords : List(List(NNI)) := []
       for word in words repeat
           nword : List(NNI) := []
           for i in word repeat
               gen :=
                   i > 0 => i
                   inv_tab(-i)
               nword := cons(qcoerce(gen)@NNI, nword)
           nwords := cons(nword, nwords)
           nrwords := cons(reverse!([inv_tab(i) for i in nword]), nrwords)
       nwords := reverse!(nwords)
       nrwords := reverse!(nrwords)
       [nwords, nrwords]

   toPermutationIfCan(a : %, sg : List(List(Integer)), trace : Boolean
                     ) : Union(PermutationGroup Integer, "failed") ==
       numberPoints : NNI := 1
       -- numberPoints is the number of points being permuted. This starts
       -- at 1 and increases when required to fill in a gap in relator tables.
       gs : List(NNI) := entries(a.gens)
       rs : List(List(Integer)) := a.rels
       if #gs = 0 and #rs = 0 then
           -- if no generators return trivial group
           unit : Permutation(Integer) := 1
           return permutationGroup([unit])
       if #gs > #rs then
           -- if more generators than relations then must be infinite.
           return "failed"
       numGens : NNI := #gs
       ct := new(10, 2*numGens, 0)$A2D
       et := new(10, 0)$A1D
       for i in 1..10 repeat
           qsetelt!(et, i, i)
       inv_tab := new(2*numGens, 0)$A1D
       for i in 1..numGens repeat
           qsetelt!(inv_tab, i, i + numGens)
           qsetelt!(inv_tab, i + numGens, i)
       (nrels, nrrels) := convert_words(rs, inv_tab)
       rel_lens : List(NNI) := [#rel for rel in nrels]
       loopLimit : NNI := 5000000 quo numGens
       state := [ct, et, inv_tab, 0, numGens, 1, 1, loopLimit]$TC_state
       (nsgens, nrsgens) := convert_words(sg, inv_tab)
       sgens_lens := [#word for word in nsgens]
       dummy := inferFromRelations(state, concat(nsgens, nrels),
                                   concat(nrsgens, nrrels),
                                   concat(sgens_lens, rel_lens),
                                   trace)
       -- Permutations will hold a permutation for each generator. This will
       -- be built up as we get more information.
       while true repeat
           changedByDeduction : Boolean :=
               inferFromRelations(state, nrels, nrrels, rel_lens, trace)
           if not(changedByDeduction) then
               if trace then
                   print(message("finished using ") << state.number_of_indices)
               return generators2Permutation(state, trace)
           if trace then print(message "relatorTables=" <<
                               relatorTables(state,rs))
           state.number_of_indices >= loopLimit => break
       "failed"

   -- output
   coerce(s : %) : OutputForm ==
       ps : List(NNI) := parts(s.gens)
       g : OutputForm := outputGenList(ps)
       rs : List(List(Integer)) := s.rels
       r : OutputForm := outputRelList(rs)
       hconcat([message("<"), g, message(" | "), r, message(">")])


