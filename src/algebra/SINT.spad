)abbrev domain SINT SingleInteger

++ Author:  Michael Monagan
++ Date Created: January 1988
++ Basic Operations: max, min,
++    not, and, or, xor, Not, And, Or
++ Related Constructors:
++ Keywords: single integer
++ Description: SingleInteger is intended to support machine integer
++ arithmetic.

-- MAXINT  (machine integer constants)


-- Lisp dependencies
-- EQ, ABSVAL, TIMES, INTEGER-LENGTH, HASHEQ, REMAINDER
-- QSLESSP, QSGREATERP, QSADD1, QSSUB1, QSMINUS, QSPLUS, QSDIFFERENCE
-- QSTIMES, QSREMAINDER, QSODDP, QSZEROP, QSMAX, QSMIN, QSNOT, QSAND
-- QSOR, QSXOR, QSLEFTSHIFT, QSADDMOD, QSDIFMOD, QSMULTMOD


SingleInteger() : Join(IntegerNumberSystem, ConvertibleTo String,
       Logic, OpenMath, Canonical, canonicalsClosed) with

   qconvert : Integer -> %
      ++ qconvert(x) converts x to % trusting that x is
      ++ in correct range.
   max      : () -> %
      ++ max() returns the largest single integer.
   min      : () -> %
      ++ min() returns the smallest single integer.

   -- bit operations
   "not":   % -> %
      ++ not(n) returns the bit-by-bit logical {\em not} of the single integer n.
   "~"  :   % -> %
      ++  ~ n returns the bit-by-bit logical {\em not} of the single integer n.
   "/\": (%, %) -> %
      ++ n /\ m  returns the bit-by-bit logical {\em and} of
      ++ the single integers n and m.
   "\/" : (%, %) -> %
      ++ n \/ m  returns the bit-by-bit logical {\em or} of
      ++ the single integers n and m.
   "xor": (%, %) -> %
      ++ xor(n, m)  returns the bit-by-bit logical {\em xor} of
      ++ the single integers n and m.
   Not  : % -> %
      ++ Not(n) returns the bit-by-bit logical {\em not} of the single integer n.
   And  : (%, %) -> %
      ++ And(n, m)  returns the bit-by-bit logical {\em and} of
      ++ the single integers n and m.
   Or   : (%, %) -> %
      ++ Or(n, m)  returns the bit-by-bit logical {\em or} of
      ++ the single integers n and m.

 == add

   MAXINT ==> MOST_-POSITIVE_-FIXNUM$Lisp
   MININT ==> MOST_-NEGATIVE_-FIXNUM$Lisp

   writeOMSingleInt(dev : OpenMathDevice, x : %) : Void ==
    if x < 0 then
      OMputApp(dev)
      OMputSymbol(dev, "arith1", "unary_minus")
      OMputInteger(dev, convert(-x))
      OMputEndApp(dev)
    else
      OMputInteger(dev, convert(x))

   OMwrite(dev : OpenMathDevice, x : %, wholeObj : Boolean) : Void ==
    if wholeObj then
      OMputObject(dev)
    writeOMSingleInt(dev, x)
    if wholeObj then
      OMputEndObject(dev)

   coerce(x) : OutputForm == (convert(x)@Integer)::OutputForm
   convert(x : %) : Integer == x pretend Integer
   convert(x : %) : String == string(convert(x)@Integer)
   i : Integer * y : %      == i::% * y
   0         == 0$Lisp
   1         == 1$Lisp
   base()    == 2$Lisp
   max()     == MAXINT
   min()     == MININT
   x = y     == eql_SI(x, y)$Lisp
   _~ x      == not_SI(x)$Lisp
   not(x)    == not_SI(x)$Lisp
   _/_\(x, y) == and_SI(x, y)$Lisp
   _\_/(x, y) == or_SI(x, y)$Lisp
   Not(x)    == not_SI(x)$Lisp
   And(x, y)  == and_SI(x, y)$Lisp
   Or(x, y)   == or_SI(x, y)$Lisp
   xor(x, y)  == xor_SI(x, y)$Lisp
   x < y     == less_SI(x, y)$Lisp
   inc x     == inc_SI(x)$Lisp
   dec x     == dec_SI(x)$Lisp
   - x       == minus_SI(x)$Lisp
   x + y     == add_SI(x, y)$Lisp
   x : % - y : % == sub_SI(x, y)$Lisp
   x : % * y : % == mul_SI(x, y)$Lisp
   x : % ^ n : NonNegativeInteger == ((EXPT(x, n)$Lisp) pretend Integer)::%
   x quo y   == quo_SI(x, y)$Lisp
   x rem y   == rem_SI(x, y)$Lisp
   divide(x, y)   == CONS(quo_SI(x, y)$Lisp, rem_SI(x, y)$Lisp)$Lisp
   gcd(x, y)  == GCD(x, y)$Lisp
   abs(x)    == abs_SI(x)$Lisp
   odd?(x)   == odd?_SI(x)$Lisp
   zero?(x)  == zero?_SI(x)$Lisp
   one?(x)   == x = 1
   max(x, y)  == max_SI(x, y)$Lisp
   min(x, y)  == min_SI(x, y)$Lisp
   hashUpdate!(hs, s) == update!(hs, SXHASH(s)$Lisp)$HashState
   length(x) == INTEGER_-LENGTH(x)$Lisp
   shift(x, n)    == lshift_SI(x, n)$Lisp
   mulmod(a, b, p) == mulmod_SI(a, b, p)$Lisp
   addmod(a, b, p) == addmod_SI(a, b, p)$Lisp
   submod(a, b, p) == submod_SI(a, b, p)$Lisp
   negative?(x)  == negative?_SI$Lisp x


   positiveRemainder(x, n) ==
      r : % := rem_SI(x, n)$Lisp
      negative?_SI(r)$Lisp =>
          negative?_SI(n)$Lisp => sub_SI(x, n)$Lisp
          add_SI(r, n)$Lisp
      r

   qconvert(x : Integer) : % == x pretend %

   coerce(x : Integer) : % ==
      (x <= max pretend Integer) and (x >= min pretend Integer) =>
        x pretend %
      error "integer too large to represent in a machine word"

   random(n) == RANDOM(n)$Lisp

   UCA ==> Record(unit : %, canonical : %, associate : %)
   unitNormal x ==
      x < 0 => [-1, -x, -1]$UCA
      [1, x, 1]$UCA


--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
