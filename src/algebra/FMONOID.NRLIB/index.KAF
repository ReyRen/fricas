14142               (|FreeMonoid| S)
|domain|
(((|FreeMonoid| |#1|)
  (|Join| (|Monoid|) (|RetractableTo| |#1|)
          (CATEGORY |domain| (SIGNATURE * ($ |#1| $)) (SIGNATURE * ($ $ |#1|))
           (SIGNATURE ^ ($ |#1| (|NonNegativeInteger|)))
           (SIGNATURE |first| (|#1| $)) (SIGNATURE |rest| ($ $))
           (SIGNATURE |mirror| ($ $)) (SIGNATURE |hclf| ($ $ $))
           (SIGNATURE |hcrf| ($ $ $))
           (SIGNATURE |lquo| ((|Union| $ "failed") $ $))
           (SIGNATURE |rquo| ((|Union| $ "failed") $ $))
           (SIGNATURE |lquo| ((|Union| $ "failed") $ |#1|))
           (SIGNATURE |rquo| ((|Union| $ "failed") $ |#1|))
           (SIGNATURE |divide|
            ((|Union| (|Record| (|:| |lm| $) (|:| |rm| $)) "failed") $ $))
           (SIGNATURE |overlap|
            ((|Record| (|:| |lm| $) (|:| |mm| $) (|:| |rm| $)) $ $))
           (SIGNATURE |size| ((|NonNegativeInteger|) $))
           (SIGNATURE |length| ((|NonNegativeInteger|) $))
           (SIGNATURE |factors|
            ((|List|
              (|Record| (|:| |gen| |#1|) (|:| |exp| (|NonNegativeInteger|))))
             $))
           (SIGNATURE |nthExpon| ((|NonNegativeInteger|) $ (|Integer|)))
           (SIGNATURE |nthFactor| (|#1| $ (|Integer|)))
           (SIGNATURE |mapExpon|
            ($ (|Mapping| (|NonNegativeInteger|) (|NonNegativeInteger|)) $))
           (SIGNATURE |mapGen| ($ (|Mapping| |#1| |#1|) $))
           (IF (|has| |#1| (|BasicType|))
               (SIGNATURE |varList| ((|List| |#1|) $))
               |noBranch|)
           (IF (|has| |#1| (|Comparable|))
               (ATTRIBUTE (|Comparable|))
               |noBranch|)
           (IF (|has| |#1| (|OrderedSet|))
               (PROGN
                (ATTRIBUTE (|OrderedMonoid|))
                (SIGNATURE |lexico| ((|Boolean|) $ $)))
               |noBranch|)))
  (|SetCategory|))
 (T |FreeMonoid|))
(|Join| (|Monoid|) (|RetractableTo| |#1|)
        (CATEGORY |domain| (SIGNATURE * ($ |#1| $)) (SIGNATURE * ($ $ |#1|))
         (SIGNATURE ^ ($ |#1| (|NonNegativeInteger|)))
         (SIGNATURE |first| (|#1| $)) (SIGNATURE |rest| ($ $))
         (SIGNATURE |mirror| ($ $)) (SIGNATURE |hclf| ($ $ $))
         (SIGNATURE |hcrf| ($ $ $))
         (SIGNATURE |lquo| ((|Union| $ "failed") $ $))
         (SIGNATURE |rquo| ((|Union| $ "failed") $ $))
         (SIGNATURE |lquo| ((|Union| $ "failed") $ |#1|))
         (SIGNATURE |rquo| ((|Union| $ "failed") $ |#1|))
         (SIGNATURE |divide|
          ((|Union| (|Record| (|:| |lm| $) (|:| |rm| $)) "failed") $ $))
         (SIGNATURE |overlap|
          ((|Record| (|:| |lm| $) (|:| |mm| $) (|:| |rm| $)) $ $))
         (SIGNATURE |size| ((|NonNegativeInteger|) $))
         (SIGNATURE |length| ((|NonNegativeInteger|) $))
         (SIGNATURE |factors|
          ((|List|
            (|Record| (|:| |gen| |#1|) (|:| |exp| (|NonNegativeInteger|))))
           $))
         (SIGNATURE |nthExpon| ((|NonNegativeInteger|) $ (|Integer|)))
         (SIGNATURE |nthFactor| (|#1| $ (|Integer|)))
         (SIGNATURE |mapExpon|
          ($ (|Mapping| (|NonNegativeInteger|) (|NonNegativeInteger|)) $))
         (SIGNATURE |mapGen| ($ (|Mapping| |#1| |#1|) $))
         (IF (|has| |#1| (|BasicType|))
             (SIGNATURE |varList| ((|List| |#1|) $))
             |noBranch|)
         (IF (|has| |#1| (|Comparable|))
             (ATTRIBUTE (|Comparable|))
             |noBranch|)
         (IF (|has| |#1| (|OrderedSet|))
             (PROGN
              (ATTRIBUTE (|OrderedMonoid|))
              (SIGNATURE |lexico| ((|Boolean|) $ $)))
             |noBranch|)))
"/git/fricas/src/algebra/FMONOID.spad"
((* (*1 *1 *2 *1)
    (AND (|isDomain| *1 (|FreeMonoid| *2)) (|ofCategory| *2 (|SetCategory|))))
 (* (*1 *1 *1 *2)
    (AND (|isDomain| *1 (|FreeMonoid| *2)) (|ofCategory| *2 (|SetCategory|))))
 (^ (*1 *1 *2 *3)
  (AND (|isDomain| *3 (|NonNegativeInteger|)) (|isDomain| *1 (|FreeMonoid| *2))
       (|ofCategory| *2 (|SetCategory|))))
 (|first| (*1 *2 *1)
  (AND (|isDomain| *1 (|FreeMonoid| *2)) (|ofCategory| *2 (|SetCategory|))))
 (|rest| (*1 *1 *1)
  (AND (|isDomain| *1 (|FreeMonoid| *2)) (|ofCategory| *2 (|SetCategory|))))
 (|mirror| (*1 *1 *1)
  (AND (|isDomain| *1 (|FreeMonoid| *2)) (|ofCategory| *2 (|SetCategory|))))
 (|hclf| (*1 *1 *1 *1)
  (AND (|isDomain| *1 (|FreeMonoid| *2)) (|ofCategory| *2 (|SetCategory|))))
 (|hcrf| (*1 *1 *1 *1)
  (AND (|isDomain| *1 (|FreeMonoid| *2)) (|ofCategory| *2 (|SetCategory|))))
 (|lquo| (*1 *1 *1 *1)
  (|partial| AND (|isDomain| *1 (|FreeMonoid| *2))
   (|ofCategory| *2 (|SetCategory|))))
 (|rquo| (*1 *1 *1 *1)
  (|partial| AND (|isDomain| *1 (|FreeMonoid| *2))
   (|ofCategory| *2 (|SetCategory|))))
 (|lquo| (*1 *1 *1 *2)
  (|partial| AND (|isDomain| *1 (|FreeMonoid| *2))
   (|ofCategory| *2 (|SetCategory|))))
 (|rquo| (*1 *1 *1 *2)
  (|partial| AND (|isDomain| *1 (|FreeMonoid| *2))
   (|ofCategory| *2 (|SetCategory|))))
 (|divide| (*1 *2 *1 *1)
  (|partial| AND
   (|isDomain| *2
               (|Record| (|:| |lm| (|FreeMonoid| *3))
                         (|:| |rm| (|FreeMonoid| *3))))
   (|isDomain| *1 (|FreeMonoid| *3)) (|ofCategory| *3 (|SetCategory|))))
 (|overlap| (*1 *2 *1 *1)
  (AND
   (|isDomain| *2
               (|Record| (|:| |lm| (|FreeMonoid| *3))
                         (|:| |mm| (|FreeMonoid| *3))
                         (|:| |rm| (|FreeMonoid| *3))))
   (|isDomain| *1 (|FreeMonoid| *3)) (|ofCategory| *3 (|SetCategory|))))
 (|size| (*1 *2 *1)
  (AND (|isDomain| *2 (|NonNegativeInteger|)) (|isDomain| *1 (|FreeMonoid| *3))
       (|ofCategory| *3 (|SetCategory|))))
 (|length| (*1 *2 *1)
  (AND (|isDomain| *2 (|NonNegativeInteger|)) (|isDomain| *1 (|FreeMonoid| *3))
       (|ofCategory| *3 (|SetCategory|))))
 (|factors| (*1 *2 *1)
  (AND
   (|isDomain| *2
               (|List|
                (|Record| (|:| |gen| *3) (|:| |exp| (|NonNegativeInteger|)))))
   (|isDomain| *1 (|FreeMonoid| *3)) (|ofCategory| *3 (|SetCategory|))))
 (|nthExpon| (*1 *2 *1 *3)
  (AND (|isDomain| *3 (|Integer|)) (|isDomain| *2 (|NonNegativeInteger|))
       (|isDomain| *1 (|FreeMonoid| *4)) (|ofCategory| *4 (|SetCategory|))))
 (|nthFactor| (*1 *2 *1 *3)
  (AND (|isDomain| *3 (|Integer|)) (|isDomain| *1 (|FreeMonoid| *2))
       (|ofCategory| *2 (|SetCategory|))))
 (|mapExpon| (*1 *1 *2 *1)
  (AND
   (|isDomain| *2 (|Mapping| (|NonNegativeInteger|) (|NonNegativeInteger|)))
   (|isDomain| *1 (|FreeMonoid| *3)) (|ofCategory| *3 (|SetCategory|))))
 (|mapGen| (*1 *1 *2 *1)
  (AND (|isDomain| *2 (|Mapping| *3 *3)) (|ofCategory| *3 (|SetCategory|))
       (|isDomain| *1 (|FreeMonoid| *3))))
 (|varList| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| *3)) (|isDomain| *1 (|FreeMonoid| *3))
       (|ofCategory| *3 (|BasicType|)) (|ofCategory| *3 (|SetCategory|))))
 (|lexico| (*1 *2 *1 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|FreeMonoid| *3))
       (|ofCategory| *3 (|OrderedSet|)) (|ofCategory| *3 (|SetCategory|)))))
((~= (((|Boolean|) $ $) NIL))
 (|varList| (((|List| |#1|) $) 73 (|has| |#1| (|BasicType|))))
 (|smaller?| (((|Boolean|) $ $) 83 (|has| |#1| (|Comparable|))))
 (|size| (((|NonNegativeInteger|) $) 60)) (|sample| (($) NIL T CONST))
 (|rquo| (((|Union| $ "failed") $ $) 62) (((|Union| $ "failed") $ |#1|) 64))
 (|rightRecip| (((|Union| $ #1="failed") $) NIL))
 (|rightPower| (($ $ (|PositiveInteger|)) NIL)
  (($ $ (|NonNegativeInteger|)) NIL))
 (|retractIfCan| (((|Union| |#1| "failed") $) NIL)) (|retract| ((|#1| $) NIL))
 (|rest| (($ $) 75)) (|recip| (((|Union| $ #1#) $) NIL))
 (|overlap| (((|Record| (|:| |lm| $) (|:| |mm| $) (|:| |rm| $)) $ $) 53))
 (|one?| (((|Boolean|) $) 14)) (|nthFactor| ((|#1| $ (|Integer|)) NIL))
 (|nthExpon| (((|NonNegativeInteger|) $ (|Integer|)) NIL))
 (|mirror| (($ $) 76)) (|min| (($ $ $) NIL (|has| |#1| (|OrderedSet|))))
 (|max| (($ $ $) NIL (|has| |#1| (|OrderedSet|))))
 (|mapGen| (($ (|Mapping| |#1| |#1|) $) 37))
 (|mapExpon|
  (($ (|Mapping| (|NonNegativeInteger|) (|NonNegativeInteger|)) $) 34))
 (|lquo| (((|Union| $ "failed") $ $) 49) (((|Union| $ "failed") $ |#1|) 63))
 (|lexico| (((|Boolean|) $ $) 79 (|has| |#1| (|OrderedSet|))))
 (|length| (((|NonNegativeInteger|) $) 69))
 (|leftRecip| (((|Union| $ #1#) $) NIL))
 (|leftPower| (($ $ (|PositiveInteger|)) NIL)
  (($ $ (|NonNegativeInteger|)) NIL))
 (|latex| (((|String|) $) NIL)) (|hcrf| (($ $ $) 25)) (|hclf| (($ $ $) 23))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) NIL))
 (|hash| (((|SingleInteger|) $) NIL)) (|first| ((|#1| $) 74))
 (|factors|
  (((|List| (|Record| (|:| |gen| |#1|) (|:| |exp| (|NonNegativeInteger|)))) $)
   31))
 (|divide| (((|Union| (|Record| (|:| |lm| $) (|:| |rm| $)) "failed") $ $) 57))
 (|coerce| (((|OutputForm|) $) 21) (($ |#1|) NIL))
 (^ (($ $ (|PositiveInteger|)) NIL) (($ $ (|NonNegativeInteger|)) NIL)
  (($ |#1| (|NonNegativeInteger|)) 40))
 (|One| (($) 7 T CONST))
 (>= (((|Boolean|) $ $) NIL (|has| |#1| (|OrderedSet|))))
 (> (((|Boolean|) $ $) NIL (|has| |#1| (|OrderedSet|))))
 (= (((|Boolean|) $ $) 41))
 (<= (((|Boolean|) $ $) NIL (|has| |#1| (|OrderedSet|))))
 (< (((|Boolean|) $ $) 80 (|has| |#1| (|OrderedSet|))))
 (* (($ $ $) 47) (($ |#1| $) 29) (($ $ |#1|) 27)))
((|HasCategory| |#1| '(|OrderedSet|)) (|HasCategory| |#1| '(|Comparable|))
 (OR (|HasCategory| |#1| '(|Comparable|)) (|HasCategory| |#1| '(|OrderedSet|)))
 (|HasCategory| |#1| '(|BasicType|)))
FMONOID
(((|Monoid|) . T) ((|RetractableTo| |#1|) . T)
 ((|Comparable|) |has| |#1| (|Comparable|))
 ((|OrderedMonoid|) |has| |#1| (|OrderedSet|)))
(((|BasicType|) . T) ((|CoercibleTo| (|OutputForm|)) . T)
 ((|Comparable|) |has| |#1| (|Comparable|)) ((|Magma|) . T)
 ((|MagmaWithUnit|) . T) ((|Monoid|) . T)
 ((|OrderedMonoid|) |has| |#1| (|OrderedSet|))
 ((|OrderedSemiGroup|) |has| |#1| (|OrderedSet|))
 ((|OrderedSet|) |has| |#1| (|OrderedSet|))
 ((|PartialOrder|) |has| |#1| (|OrderedSet|)) ((|RetractableTo| |#1|) . T)
 ((|SemiGroup|) . T) ((|SetCategory|) . T))
((|constructor|
  (NIL
   "The free monoid on a set \\spad{S} is the monoid of finite products of the form \\spad{reduce(*,{} [\\spad{si} ^ \\spad{ni}])} where the \\spad{si}\\spad{'s} are in \\spad{S},{} and the \\spad{ni}\\spad{'s} are nonnegative integers. The multiplication is not commutative. When \\spad{S} is an OrderedSet,{} then FreeMonoid(\\spad{S}) has order: for two elements \\spad{x} and \\spad{y} the relation \\spad{x < y} holds if either \\spad{length(x) < length(y)} holds or if these lengths are equal and if \\spad{x} is smaller than \\spad{y} \\spad{w}.\\spad{r}.\\spad{t}. the lexicographical ordering induced by \\spad{S}."))
 (|lexico|
  (((|Boolean|) $ $)
   "\\spad{lexico(x,{} y)} returns \\spad{true} iff \\spad{x} is smaller than \\spad{y} \\spad{w}.\\spad{r}.\\spad{t}. the pure lexicographical ordering induced by \\spad{S}."))
 (|varList|
  (((|List| |#1|) $)
   "\\spad{varList(x)} returns the list of variables of \\spad{x}."))
 (|mapGen|
  (($ (|Mapping| |#1| |#1|) $)
   "\\spad{mapGen(f,{} a1\\^e1 ... an\\^en)} returns \\spad{f(a1)\\^e1 ... f(an)\\^en}."))
 (|mapExpon|
  (($ (|Mapping| (|NonNegativeInteger|) (|NonNegativeInteger|)) $)
   "\\spad{mapExpon(f,{} a1\\^e1 ... an\\^en)} returns \\spad{a1\\^f(e1) ... an\\^f(en)}."))
 (|nthFactor|
  ((|#1| $ (|Integer|))
   "\\spad{nthFactor(x,{} n)} returns the factor of the n^th monomial of \\spad{x}."))
 (|nthExpon|
  (((|NonNegativeInteger|) $ (|Integer|))
   "\\spad{nthExpon(x,{} n)} returns the exponent of the n^th monomial of \\spad{x}."))
 (|factors|
  (((|List| (|Record| (|:| |gen| |#1|) (|:| |exp| (|NonNegativeInteger|)))) $)
   "\\spad{factors(a1\\^e1,{} ...,{} an\\^en)} returns \\spad{[[a1,{} e1],{} ...,{} [an,{} en]]}."))
 (|length|
  (((|NonNegativeInteger|) $)
   "\\spad{length(x)} returns the length of \\spad{x}."))
 (|size|
  (((|NonNegativeInteger|) $)
   "\\spad{size(x)} returns the number of monomials in \\spad{x}."))
 (|overlap|
  (((|Record| (|:| |lm| $) (|:| |mm| $) (|:| |rm| $)) $ $)
   "\\spad{overlap(x,{} y)} returns \\spad{[l,{} m,{} r]} such that \\spad{x = l * m},{} \\spad{y = m * r} and \\spad{l} and \\spad{r} have no overlap,{} \\spadignore{i.e.} \\spad{overlap(l,{} r) = [l,{} 1,{} r]}."))
 (|divide|
  (((|Union| (|Record| (|:| |lm| $) (|:| |rm| $)) "failed") $ $)
   "\\spad{divide(x,{} y)} returns the left and right exact quotients of \\spad{x} by \\spad{y},{} \\spadignore{i.e.} \\spad{[l,{} r]} such that \\spad{x = l * y * r},{} \"failed\" if \\spad{x} is not of the form \\spad{l * y * r}."))
 (|rquo|
  (((|Union| $ "failed") $ |#1|)
   "\\spad{rquo(x,{} s)} returns the exact right quotient of \\spad{x} by \\spad{s}.")
  (((|Union| $ "failed") $ $)
   "\\spad{rquo(x,{} y)} returns the exact right quotient of \\spad{x} by \\spad{y} \\spadignore{i.e.} \\spad{q} such that \\spad{x = q * y},{} \"failed\" if \\spad{x} is not of the form \\spad{q * y}."))
 (|lquo|
  (((|Union| $ "failed") $ |#1|)
   "\\spad{lquo(x,{} s)} returns the exact left quotient of \\spad{x} by \\spad{s}.")
  (((|Union| $ "failed") $ $)
   "\\spad{lquo(x,{} y)} returns the exact left quotient of \\spad{x} by \\spad{y} \\spadignore{i.e.} \\spad{q} such that \\spad{x = y * q},{} \"failed\" if \\spad{x} is not of the form \\spad{y * q}."))
 (|hcrf|
  (($ $ $)
   "\\spad{hcrf(x,{} y)} returns the highest common right factor of \\spad{x} and \\spad{y},{} \\spadignore{i.e.} the largest \\spad{d} such that \\spad{x = a d} and \\spad{y = b d}."))
 (|hclf|
  (($ $ $)
   "\\spad{hclf(x,{} y)} returns the highest common left factor of \\spad{x} and \\spad{y},{} \\spadignore{i.e.} the largest \\spad{d} such that \\spad{x = d a} and \\spad{y = d b}."))
 (|mirror| (($ $) "\\spad{mirror(x)} returns the reversed word of \\spad{x}."))
 (|rest| (($ $) "\\spad{rest(x)} returns \\spad{x} except the first letter."))
 (|first| ((|#1| $) "\\spad{first(x)} returns the first letter of \\spad{x}."))
 (^
  (($ |#1| (|NonNegativeInteger|))
   "\\spad{s ^ n} returns the product of \\spad{s} by itself \\spad{n} times."))
 (*
  (($ $ |#1|)
   "\\spad{x * s} returns the product of \\spad{x} by \\spad{s} on the right.")
  (($ |#1| $)
   "\\spad{s * x} returns the product of \\spad{x} by \\spad{s} on the left.")))
(("documentation" 0 9918) ("ancestors" 0 9498) ("parents" 0 9359)
 ("abbreviation" 0 9351) ("predicates" 0 9158) ("superDomain" 0 NIL)
 ("operationAlist" 0 6947) ("modemaps" 0 3641) ("sourceFile" 0 3602)
 ("constructorCategory" 0 1890) ("constructorModemap" 0 46)
 ("constructorKind" 0 37) ("constructorForm" 0 20))