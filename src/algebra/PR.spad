)abbrev domain PR PolynomialRing
++ Author: Dave Barton, James Davenport, Barry Trager
++ Basic Functions: Ring, degree, coefficient, monomial, reductum
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This domain represents generalized polynomials with coefficients
++ (from a not necessarily commutative ring), and terms
++ indexed by their exponents (from an arbitrary ordered abelian monoid).
++ This type is used, for example,
++ by the \spadtype{DistributedMultivariatePolynomial} domain where
++ the exponent domain is a direct product of non negative integers.

PolynomialRing(R : Join(SemiRng, AbelianMonoid), E : OrderedAbelianMonoid
              ) : T == C
 where
  T == Join(FiniteAbelianMonoidRing(R, E),
            VariablesCommuteWithCoefficients) with
    --assertions
       if R has canonicalUnitNormal then canonicalUnitNormal
          ++ canonicalUnitNormal guarantees that the function
          ++ unitCanonical returns the same representative for all
          ++ associates of any particular element.
       if R has Comparable then Comparable

  C == FreeModule(R, E) add
    --representations
       Term ==>  Record(k : E, c : R)
       Rep :=  List Term

       TermS ==>  Record(k : SingleInteger, c : R)
       RepS ==> List TermS

    --declarations
       x, y, p, p1, p2 : %
       n : Integer
       nn : NonNegativeInteger
       np : PositiveInteger
       e : E
       r : R

       commutative := R has CommutativeRing

    --local operations
       if R has Monoid then
           1  == [[0$E, 1$R]]
       if R has Ring then
           characteristic  == characteristic$R
       degree p == if empty?(p) then 0 else p.first.k
       minimumDegree p == if empty?(p) then 0 else (last p).k
       leadingCoefficient p == if empty?(p) then 0$R else p.first.c
       leadingMonomial p == if empty?(p) then 0 else [p.first]
       reductum p == if empty?(p) then p else p.rest
       retractIfCan(p:%):Union(R,"failed") ==
         empty?(p) => 0$R
         not(empty?(p.rest)) => "failed"
         zero?(p.first.k) => p.first.c
         "failed"

       if E is NonNegativeInteger then
           coefficient(p : %, e : E)  ==
               empty?(p) => 0$R
               degp := first(p).k pretend Integer
               degp < max()$SingleInteger =>
                   not(e pretend Integer < max()$SingleInteger) => 0$R
                   ps := p pretend RepS
                   es := e pretend SingleInteger
                   for tms in ps repeat
                       ks := tms.k pretend SingleInteger
                       ks = es => return tms.c
                       ks < es => return 0$R
                   return 0$R
               for tm in p repeat
                   tm.k = e => return tm.c
                   tm.k < e => return 0$R
               0$R
       else
           coefficient(p : %, e : E)  ==
               for tm in p repeat
                   tm.k = e => return tm.c
                   tm.k < e => return 0$R
               0$R

       recip(p) ==
           empty?(p) => "failed"
           p.first.k > 0$E => "failed"
           (u := recip(p.first.c)) case "failed" => "failed"
           (u::R)::%

       coerce(r) == if zero? r then 0$% else [[0$E, r]]
       if R has Ring then
           coerce(n) == (n::R)::%

       ground?(p) : Boolean == empty? p or (empty? rest p and zero? degree p)

       -- qsetrest!: (Rep, Rep) -> Rep
       -- qsetrest!(l: Rep, e: Rep): Rep == RPLACD(l, e)$Lisp
       qsetrest! ==> RPLACD$Lisp

       times :  (R, E, %) -> %

       entireRing? := R has noZeroDivisors

        --- term * polynomial
       termTimes : (R, E, Term) -> Term
       termTimes(r : R, e : E, tx : Term) : Term == [e+tx.k, r*tx.c]
       times(tco : R, tex : E, rx : %) : % ==
        if entireRing? then
                map(x1+->termTimes(tco, tex, x1), rx::Rep)
        else
                [[tex + tx.k, r] for tx in rx::Rep | not zero? (r := tco * tx.c)]



       -- local addm!
       addm! : (Rep, R, E, Rep) -> Rep
        -- p1 + coef*x^E * p2
        -- `spare' (commented out) is for storage efficiency (not so good for
        -- performance though.
       ADDM_BODY ==>
                res     := empty()
                endcell := empty()
                --spare   := empty()
                while not empty? p1 and not empty? p2 repeat
                        tx := first p1
                        ty := first p2
                        exy := exp + ty.k
                        newcell := empty()
                        if tx.k = exy then
                                newcoef := tx.c + coef * ty.c
                                if not zero? newcoef then
                                        tx.c    := newcoef
                                        newcell := p1
                                --else
                                --      spare   := cons(p1, spare)
                                p1 := rest p1
                                p2 := rest p2
                        else if exy < tx.k then
                                newcell := p1
                                p1      := rest p1
                        else
                                newcoef := coef * ty.c
                                if not entireRing? and zero? newcoef then
                                        newcell := empty()
                                --else if empty? spare then
                                --      ttt := [exy, newcoef]
                                --      newcell := cons(ttt, empty())
                                --else
                                --      newcell := first spare
                                --      spare   := rest spare
                                --      ttt := first newcell
                                --      ttt.k := exy
                                --      ttt.c := newcoef
                                else
                                        ttt := [exy, newcoef]
                                        newcell := cons(ttt, empty())
                                p2 := rest p2
                        if not empty? newcell then
                                if empty? res then
                                        res := newcell
                                        endcell := res
                                else
                                        qsetrest!(endcell, newcell)
                                        endcell := newcell

       addm!(p1 : Rep, coef : R, exp : E, p2 : Rep) : Rep ==
           res, newcell, endcell : Rep
           spare : List Rep
           ADDM_BODY
           if not empty? p1 then  -- then end is const * p1
               newcell := p1
           else  -- then end is (coef, exp) * p2
               newcell := times(coef, exp, p2)
           empty? res => newcell
           qsetrest!(endcell, newcell)
           res

       pomopo! (p1, r, e, p2) ==  addm!(p1, r, e, p2)

       if E is NonNegativeInteger then
           -- addms! works only for SingleInteger exponents
           -- but is much faster than general case
           addms!(pp1 : Rep, coef : R, exp1 : E, pp2 : Rep) : Rep ==
               res, newcell, endcell : RepS
               spare : List RepS
               p1 : RepS := pp1 pretend RepS
               p2 : RepS := pp2 pretend RepS
               exp : SingleInteger := exp1 pretend SingleInteger
               ADDM_BODY
               if not empty? p1 then  -- then end is const * p1
                   newcell := p1
               else  -- then end is (coef, exp) * p2
                   newcell := times(coef, exp pretend NonNegativeInteger,
                                    p2 pretend Rep) pretend RepS
               empty? res => newcell pretend Rep
               qsetrest!(endcell, newcell)
               res pretend Rep

           p1 * p2 ==
                xx := p1::Rep
                empty? xx => p1
                yy := p2::Rep
                empty? yy => p2
                if commutative then
                    lx := # xx
                    ly := # yy
                    if ly < lx then
                        (xx, yy) := (yy, xx)
                        (p1, p2) := (p2, p1)
                degx := first(xx).k
                degy := first(yy).k
                zero? degx => first(xx).c * p2
                zero? degy => p1 * first(yy).c
                xx := reverse xx
                res : Rep := empty()
                if degx + degy < max()$SingleInteger then
                    for tx in xx repeat res := addms!(res, tx.c, tx.k, yy)
                else
                    for tx in xx repeat res := addm!(res, tx.c, tx.k, yy)
                res
       else
           p1 * p2 ==
                xx := p1::Rep
                empty? xx => p1
                yy := p2::Rep
                empty? yy => p2
                zero? first(xx).k => first(xx).c * p2
                zero? first(yy).k => p1 * first(yy).c
                --if #xx > #yy then
                --      (xx, yy) := (yy, xx)
                --      (p1, p2) := (p2, p1)
                xx := reverse xx
                res : Rep := empty()
                for tx in xx repeat res := addm!(res, tx.c, tx.k, yy)
                res

       if % has CommutativeRing  then

         p ^ np == p^(np::NonNegativeInteger)

         p ^ nn  ==
            zero? nn => 1
            empty?(p) => 0
            (nn = 1) => p
            empty? p.rest =>
              zero?(cc := p.first.c ^ nn) => 0
              [[nn * p.first.k, cc]]
            binomThmExpt([p.first], p.rest, nn)

       if R has Field then
         x/r == inv(r)*x
         unitNormal(p) ==
            empty?(p) or (lcf : R := p.first.c) = 1 => [1, p, 1]
            a := inv lcf
            [lcf::%, cons([p.first.k, 1], (a * p.rest)), a::%]
         unitCanonical(p) ==
            empty?(p) or (lcf : R := p.first.c) = 1 => p
            a := inv lcf
            cons([p.first.k, 1], (a * p.rest))
       else if R has IntegralDomain then
         unitNormal(p) ==
            empty?(p) or p.first.c = 1 => [1, p, 1]
            (u, cf, a) := unitNormal(p.first.c)
            [u::%, cons([p.first.k, cf], (a * p.rest)), a::%]
         unitCanonical(p) ==
            empty?(p) or p.first.c = 1 => p
            (u, cf, a) := unitNormal(p.first.c)
            cons([p.first.k, cf], (a * p.rest))
       if R has Ring then
         fmecg(p1 : %, e : E, r : R, p2 : %) : % ==       -- p1 - r * X^e * p2
            rout : % := []
            r := - r
            for tm in p2 repeat
               c2 := r * tm.c
               c2 = 0 => "iterate"
               e2 := e + tm.k
               while not(empty?(p1)) and p1.first.k > e2 repeat
                 (rout := cons(p1.first, rout); p1 := p1.rest)  --use PUSH and POP?
               empty?(p1) or p1.first.k < e2 => rout := cons([e2, c2], rout)
               if (u := p1.first.c + c2) ~= 0 then
                   rout := cons([e2, u], rout)
               p1 := p1.rest
            concat!(reverse! rout, p1)
       if R has IntegralDomain then
         associates?(p1, p2) ==
            empty?(p1) => empty?(p2)
            empty?(p2) => false
            p1.first.k = p2.first.k and
              associates?(p1.first.c, p2.first.c) and
               ((p2.first.c exquo p1.first.c)::R * p1.rest = p2.rest)
         p exquo r  ==
           [(if (a := tm.c exquo r) case "failed"
               then return "failed" else [tm.k,a])
                  for tm in p] :: Union(%,"failed")
         if E has CancellationAbelianMonoid then
           if R has Approximate then
             p1 exquo p2  ==
               empty?(p2) => error "Division by 0"
               p2 = 1 => p1
               p1 = p2 => 1
             --(p1.lastElt.c exquo p2.lastElt.c) case "failed" => "failed"
               rout := []@List(Term)
               while not(empty?(p1)) repeat
                  (a := p1.first.c exquo p2.first.c)
                  a case "failed" => return "failed"
                  ee := subtractIfCan(p1.first.k, p2.first.k)
                  ee case "failed" => return "failed"
                  p1 := fmecg(p1.rest, ee, a, p2.rest)
                  rout := cons([ee, a], rout)
               empty?(p1) => reverse!(rout)::%
               "failed"
           else -- R not Approximate
             p1 exquo p2  ==
               empty?(p2) => error "Division by 0"
               p2 = 1 => p1
             --(p1.lastElt.c exquo p2.lastElt.c) case "failed" => "failed"
               rout := []@List(Term)
               while not(empty?(p1)) repeat
                  (a := p1.first.c exquo p2.first.c)
                  a case "failed" => return "failed"
                  ee := subtractIfCan(p1.first.k, p2.first.k)
                  ee case "failed" => return "failed"
                  p1 := fmecg(p1.rest, ee, a, p2.rest)
                  rout := cons([ee, a], rout)
               empty?(p1) => reverse!(rout)::%
               "failed"

