)abbrev domain JBP JetBundlePolynomial
++ Description:
++ \spadtype{JetBundlePolynomial} implements polynomial sections over
++ a jet bundle. The order is not fixed, thus jet variables of any order
++ can appear.

JetBundlePolynomial(R : Ring, JB : JBC) : Cat == Def where

  L    ==> List
  NNI  ==> NonNegativeInteger
  OUT  ==> OutputForm
  JBC  ==> JetBundleCategory
  JBFC ==> JetBundleFunctionCategory JB
  DP   ==> DirectProduct(#LJV, NNI)
  IE   ==> IndexedExponents JB
  PC   ==> PolynomialCategory(R, IE, JB)
  SMP  ==> SparseMultivariatePolynomial(R, JB)
  JGB  ==> JetGroebner(R, JB, LJV, %, DP)

  Cat ==> Join(JBFC, PC) with

    if R has GcdDomain then
      groebner : L % -> L %
        ++ \spad{groebner(lp)} computes a Groebner basis for the ideal
        ++ generated by \spad{lp} wrt a lexicographic ordering.


  Def ==> SMP add

    Rep := SMP
    -- In principle, a distributed representation would be better for the
    -- Groebner bases computations, but this requires a fixed number of
    -- unknowns. Hence, we transform to polynomials in a finite number of
    -- jet variables, before we compute Groebner bases.

    jetVariables(p : %) : L JB == variables p

    subst(p : %, jv : JB, exp : %) : % == eval(p, jv, exp)

    numerator(l : %) : % == l

    denominator(l : %) : % == 1

    if R has Field then

        solveFor(p : %, jv : JB) : Union(%, "failed") ==
            -- p must be linear in jv with constant coefficient
            c := differentiate(p, jv)
            ground? c =>
                cc : R := retract c
                (1/cc) * p - jv::%
            "failed"

    else

        solveFor(p : %, jv : JB) : Union(%, "failed") ==
            -- p must be linear in jv with constant coefficient
            c := differentiate(p, jv)
            ground? c =>
                cc : R := retract c
                rc := recip cc
                rc case "failed" => "failed"
                rc::R * p - jv::%
            "failed"

    if R has GcdDomain then
        groebner(lp : L %) : L % ==
            print(message("groebner"))$OUT
            lj : L L JB := [jetVariables p  for p in lp]
            LJV : L JB := reduce(setUnion, lj, empty)
            print(assign(message("LJV"), LJV::OUT))$OUT
            groebner(lp)$JGB


