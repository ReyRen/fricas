5586                (|ModularAlgebraicGcdOperations| MP MPT MD)
|category|
(((|ModularAlgebraicGcdOperations| |#1| |#2| |#3|) (|Category|) (|Type|)
  (|Type|) (|Type|))
 (T |ModularAlgebraicGcdOperations|))
(|Join|
 (CATEGORY |package| (SIGNATURE |pseudoRem| (|t#2| |t#2| |t#2| |t#3|))
  (SIGNATURE |canonicalIfCan| ((|Union| |t#2| "failed") |t#2| |t#3|))
  (SIGNATURE |pack_modulus|
   ((|Union| |t#3| "failed") (|List| |t#1|) (|List| (|Symbol|)) (|Integer|)))
  (SIGNATURE |MPtoMPT|
   ((|Union| |t#2| "failed") |t#1| (|Symbol|) (|List| (|Symbol|)) |t#3|))
  (SIGNATURE |zero?| ((|Boolean|) |t#2|))
  (SIGNATURE |degree| ((|Integer|) |t#2|))
  (SIGNATURE |pack_exps|
   ((|SortedExponentVector|) (|Integer|) (|Integer|) |t#3|))
  (SIGNATURE |repack1| ((|Void|) |t#2| (|U32Vector|) (|Integer|) |t#3|))))
"/git/fricas/src/algebra/MAGCDOC.spad"
((|repack1| (*1 *2 *3 *4 *5 *6)
  (AND (|isDomain| *4 (|U32Vector|)) (|isDomain| *5 (|Integer|))
       (|ofCategory| *1 (|ModularAlgebraicGcdOperations| *7 *3 *6))
       (|ofCategory| *7 (|Type|)) (|ofCategory| *3 (|Type|))
       (|ofCategory| *6 (|Type|)) (|isDomain| *2 (|Void|))))
 (|pack_exps| (*1 *2 *3 *3 *4)
  (AND (|isDomain| *3 (|Integer|))
       (|ofCategory| *1 (|ModularAlgebraicGcdOperations| *5 *6 *4))
       (|ofCategory| *5 (|Type|)) (|ofCategory| *6 (|Type|))
       (|ofCategory| *4 (|Type|)) (|isDomain| *2 (|SortedExponentVector|))))
 (|degree| (*1 *2 *3)
  (AND (|ofCategory| *1 (|ModularAlgebraicGcdOperations| *4 *3 *5))
       (|ofCategory| *4 (|Type|)) (|ofCategory| *3 (|Type|))
       (|ofCategory| *5 (|Type|)) (|isDomain| *2 (|Integer|))))
 (|zero?| (*1 *2 *3)
  (AND (|ofCategory| *1 (|ModularAlgebraicGcdOperations| *4 *3 *5))
       (|ofCategory| *4 (|Type|)) (|ofCategory| *3 (|Type|))
       (|ofCategory| *5 (|Type|)) (|isDomain| *2 (|Boolean|))))
 (|MPtoMPT| (*1 *2 *3 *4 *5 *6)
  (|partial| AND (|isDomain| *5 (|List| (|Symbol|)))
   (|ofCategory| *1 (|ModularAlgebraicGcdOperations| *3 *2 *6))
   (|ofCategory| *3 (|Type|)) (|ofCategory| *6 (|Type|))
   (|isDomain| *4 (|Symbol|)) (|ofCategory| *2 (|Type|))))
 (|pack_modulus| (*1 *2 *3 *4 *5)
  (|partial| AND (|isDomain| *3 (|List| *6))
   (|isDomain| *4 (|List| (|Symbol|))) (|isDomain| *5 (|Integer|))
   (|ofCategory| *1 (|ModularAlgebraicGcdOperations| *6 *7 *2))
   (|ofCategory| *6 (|Type|)) (|ofCategory| *7 (|Type|))
   (|ofCategory| *2 (|Type|))))
 (|canonicalIfCan| (*1 *2 *2 *3)
  (|partial| AND (|ofCategory| *1 (|ModularAlgebraicGcdOperations| *4 *2 *3))
   (|ofCategory| *4 (|Type|)) (|ofCategory| *2 (|Type|))
   (|ofCategory| *3 (|Type|))))
 (|pseudoRem| (*1 *2 *2 *2 *3)
  (AND (|ofCategory| *1 (|ModularAlgebraicGcdOperations| *4 *2 *3))
       (|ofCategory| *4 (|Type|)) (|ofCategory| *2 (|Type|))
       (|ofCategory| *3 (|Type|)))))
((|zero?| (((|Boolean|) |#2|) 6))
 (|repack1| (((|Void|) |#2| (|U32Vector|) (|Integer|) |#3|) 6))
 (|pseudoRem| ((|#2| |#2| |#2| |#3|) 6))
 (|pack_modulus|
  (((|Union| |#3| "failed") (|List| |#1|) (|List| (|Symbol|)) (|Integer|)) 6))
 (|pack_exps| (((|SortedExponentVector|) (|Integer|) (|Integer|) |#3|) 6))
 (|degree| (((|Integer|) |#2|) 6))
 (|canonicalIfCan| (((|Union| |#2| "failed") |#2| |#3|) 6))
 (|MPtoMPT|
  (((|Union| |#2| "failed") |#1| (|Symbol|) (|List| (|Symbol|)) |#3|) 6)))
MAGCDOC
((|constructor|
  (NIL
   "This category specifies operations needed by \\indented{1}{ModularAlgebraicGcd package.\\space{2}Since we have multiple} \\indented{1}{implementations we specify interface here and put} \\indented{1}{implementations in separate packages.\\space{2}Most operations} \\indented{1}{are done using special purpose abstract representation.} \\indented{1}{Apropriate types are passesd as parametes: \\spad{MPT} is type} \\indented{1}{of modular polynomials in one variable with coefficients} \\indented{1}{in some algebraic extension.\\space{2}\\spad{MD} is type of modulus.} \\indented{1}{Final results are converted to packed representation,{}} \\indented{1}{with coefficients (from prime field) stored in one} \\indented{1}{array and exponents (in main variable and in auxilary} \\indented{1}{variables representing generators of algebrac extension)} \\indented{1}{stored in parallel array.}"))
 (|repack1|
  (((|Void|) |#2| (|U32Vector|) (|Integer|) |#3|)
   "\\spad{repack1(x,{} a,{} d,{} m)} stores coefficients of \\spad{x} in a. \\spad{d} is degree of \\spad{x}. Corresponding exponents are given by pack_exps."))
 (|pack_exps|
  (((|SortedExponentVector|) (|Integer|) (|Integer|) |#3|)
   "\\spad{pack_exps(d,{} s,{} m)} produces vector of exponents up to degree \\spad{d}. \\spad{s} is size (degree) of algebraic extension. Use together with \\spad{repack1}."))
 (|degree| (((|Integer|) |#2|) "\\spad{degree(x)} gives degree of \\spad{x}."))
 (|zero?| (((|Boolean|) |#2|) "\\spad{zero?(x)} checks if \\spad{x} is zero."))
 (|MPtoMPT|
  (((|Union| |#2| "failed") |#1| (|Symbol|) (|List| (|Symbol|)) |#3|)
   "\\spad{MPtoMPT(p,{} s,{} ls,{} m)} converts \\spad{p} to packed represntation."))
 (|pack_modulus|
  (((|Union| |#3| "failed") (|List| |#1|) (|List| (|Symbol|)) (|Integer|))
   "\\spad{pack_modulus(lp,{} ls,{} p)} converts \\spad{lp},{} \\spad{ls} and prime \\spad{p} which together describe algebraic extension to packed representation."))
 (|canonicalIfCan|
  (((|Union| |#2| "failed") |#2| |#3|)
   "\\spad{canonicalIfCan(x,{} m)} tries to divide \\spad{x} by its leading coefficient modulo \\spad{m}."))
 (|pseudoRem|
  ((|#2| |#2| |#2| |#3|)
   "\\spad{pseudoRem(x,{} y,{} m)} computes pseudoremainder of \\spad{x} by \\spad{y} modulo \\spad{m}.")))
(("documentation" 0 3293) ("ancestors" 0 NIL) ("parents" 0 NIL)
 ("abbreviation" 0 3285) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 2793) ("modemaps" 0 844) ("sourceFile" 0 805)
 ("constructorCategory" 0 207) ("constructorModemap" 0 75)
 ("constructorKind" 0 64) ("constructorForm" 0 20))