)abbrev category SMATCAT SquareMatrixCategory
++ Authors: Grabmeier, Gschnitzer, Williamson
++ Date Created: 1987
++ Basic Operations:
++ Related Domains: SquareMatrix(ndim, R)
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
++   \spadtype{SquareMatrixCategory} is a general square matrix category which
++   allows different representations and indexing schemes.  Rows and
++   columns may be extracted with rows returned as objects of
++   type Row and colums returned as objects of type Col.
SquareMatrixCategory(ndim, R, Row, Col) : Category == Definition where
  ndim : NonNegativeInteger
  R    : Join(SemiRng, AbelianMonoid)
  Row  : DirectProductCategory(ndim, R)
  Col  : DirectProductCategory(ndim, R)
  I ==> Integer

  Definition ==> Join(SemiRng, AbelianMonoid, BiModule(R, R), TwoSidedRecip,
                      RectangularMatrixCategory(ndim, ndim, R, Row, Col), _
                      FullyRetractableTo R) with
    if R has SemiRing then SemiRing
    if R has Ring then
        DifferentialExtension R
        FullyLinearlyExplicitOver R
    scalarMatrix : R -> %
      ++ \spad{scalarMatrix(r)} returns an n-by-n matrix with r's on the
      ++ diagonal and zeroes elsewhere.
    diagonalMatrix : List R -> %
      ++ \spad{diagonalMatrix(l)} returns a diagonal matrix with the elements
      ++ of l on the diagonal.
    diagonal : % -> Row
      ++ \spad{diagonal(m)} returns a row consisting of the elements on the
      ++ diagonal of the matrix m.
    trace : % -> R
      ++ \spad{trace(m)} returns the trace of the matrix m. this is the sum
      ++ of the elements on the diagonal of the matrix m.
    diagonalProduct : % -> R
      ++ \spad{diagonalProduct(m)} returns the product of the elements on the
      ++ diagonal of the matrix m.
    "*": (%,Col) -> Col
      ++ \spad{x * c} is the product of the matrix x and the column vector c.
      ++ Error: if the dimensions are incompatible.
    "*": (Row,%) -> Row
      ++ \spad{r * x} is the product of the row vector r and the matrix x.
      ++ Error: if the dimensions are incompatible.

--% Linear algebra

    if R has CommutativeRing then
      Algebra R
      determinant : % -> R
        ++ \spad{determinant(m)} returns the determinant of the matrix m.
      minordet : % -> R
        ++ \spad{minordet(m)} computes the determinant of the matrix m
        ++ using minors.
      Pfaffian : % -> R
         ++ \spad{Pfaffian(m)} returns the Pfaffian of the matrix m.
         ++ Error: if the matrix is not antisymmetric.

    if R has Field then
      inverse : % -> Union(%,"failed")
        ++ \spad{inverse(m)} returns the inverse of the matrix m, if that
        ++ matrix is invertible and returns "failed" otherwise.
      "^": (%,Integer) -> %
        ++ \spad{m^n} computes an integral power of the matrix m.
        ++ Error: if the matrix is not invertible.

   add
    minr ==> minRowIndex
    maxr ==> maxRowIndex
    minc ==> minColIndex
    maxc ==> maxColIndex
    mini ==> minIndex
    maxi ==> maxIndex

    positivePower : (%, Integer) -> %
    positivePower(x, n) ==
      (n = 1) => x
      odd? n => x * positivePower(x, n - 1)
      y := positivePower(x, n quo 2)
      y * y

    if R has Monoid then
        x : % ^ n : NonNegativeInteger ==
            zero? n => scalarMatrix 1
            positivePower(x, n)

    coerce(r : R) == scalarMatrix r

    differentiate(x : %, d : R -> R) == map(d, x)

    diagonal x ==
      v : Vector(R) := new(ndim, 0)
      for i in minr x .. maxr x
        for j in minc x .. maxc x
          for k in minIndex v .. maxIndex v repeat
            qsetelt!(v, k, qelt(x, i, j))
      directProduct v

    retract(x : %) : R ==
      diagonal? x => retract diagonal x
      error "Not retractable"

    retractIfCan(x:%):Union(R, "failed") ==
      diagonal? x => retractIfCan diagonal x
      "failed"

    if R has Ring then

        equation2R : Vector % -> Matrix R

        equation2R v ==
            ans : Matrix(Col) := new(ndim, #v, 0)
            for i in minr ans .. maxr ans repeat
                for j in minc ans .. maxc ans repeat
                    qsetelt!(ans, i, j, column(qelt(v, j), i))
            reducedSystem ans

        reducedSystem(x : Matrix %) : Matrix(R) ==
            empty? x => new(ndim*ndim*nrows(x), ncols(x), 0)
            reduce(vertConcat, [equation2R row(x, i)
                               for i in minr x .. maxr x])$List(Matrix R)

        reducedSystem(m : Matrix %, v : Vector %
                     ) : Record(mat : Matrix R, vec : Vector R) ==
            vh : Vector(R) :=
                empty? v => new(0, 0)
                rh := reducedSystem(v::Matrix %)@Matrix(R)
                column(rh, minColIndex rh)
            [reducedSystem(m)@Matrix(R), vh]

    trace x ==
      tr : R := 0
      for i in minr(x)..maxr(x) for j in minc(x)..maxc(x) repeat
        tr := tr + x(i, j)
      tr

    diagonalProduct x ==
      pr : R := x(minr(x), minc(x))
      for i in (minr(x) + 1)..maxr(x) for j in (minc(x) + 1)..maxc(x) repeat
        pr := pr * x(i, j)
      pr

    if R has Field then

      x : % ^ n : Integer ==
        zero? n => scalarMatrix 1
        positive? n => positivePower(x, n)
        (xInv := inverse x) case "failed" =>
          error "^: matrix must be invertible"
        positivePower(xInv :: %, -n)


--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

)if false
\begin{thebibliography}{99}
\bibitem{1} G. Rote, Division-free algorithms for the determinant and the
  Pfaffian, in : H. Alt (Ed.), Computational Discrete Mathematics, in : Lecture
  Notes in Comput. Sci., vol. 2122, Springer, Berlin, 2001, pp. 119--135.
  MR1911585 (2003g : 65062), \url{http://page.mi.fu-berlin.de/rote/Papers/abstract/Division-free+algorithms+for+the+determinant+and+the+Pfaffian : +algebraic+and+combinatorial+approaches.html}
\end{thebibliography}
)endif
