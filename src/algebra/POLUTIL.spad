)abbrev package POLUTIL RealPolynomialUtilitiesPackage
++ Author: Renaud Rioboo
++ Date Created: summer 1992
++ Basic Functions: provides polynomial utilities
++ Related Constructors: RealClosure,
++ Also See:
++ AMS Classifications:
++ Keywords: Sturm sequences
++ References:
++ Description:
++ \spadtype{RealPolynomialUtilitiesPackage} provides common functions used
++ by interval coding.
RealPolynomialUtilitiesPackage(TheField, ThePols) : PUB == PRIV where

    TheField : Field
    ThePols : UnivariatePolynomialCategory(TheField)

    Z ==> Integer
    N ==> NonNegativeInteger
    P ==> ThePols

    PUB == with

       sylvesterSequence : (ThePols, ThePols) -> List ThePols
         ++ \spad{sylvesterSequence(p, q)} is the negated remainder sequence
         ++ of p and q divided by the last computed term
       sturmSequence : ThePols -> List ThePols
         ++ \spad{sturmSequence(p) = sylvesterSequence(p, p')}
       if TheField has OrderedRing then
         boundOfCauchy : ThePols -> TheField
           ++ \spad{boundOfCauchy(p)} bounds the roots of p
         sturmVariationsOf : List TheField -> N
           ++ \spad{sturmVariationsOf(l)} is the number of sign variations
           ++ in the list of numbers l,
           ++ note that the first term counts as a sign
         lazyVariations : (List(TheField), Z, Z) -> N
           ++ \spad{lazyVariations(l, s1, sn)} is the number of sign variations
           ++ in the list of non null numbers [s1::l]@sn,


    PRIV == add

     sturmSequence(p) ==
       sylvesterSequence(p, differentiate(p))

     sylvesterSequence(p1, p2) ==
       res : List(ThePols) := [p1]
       while (p2 ~= 0) repeat
         res := cons(p2 , res)
         (p1 , p2) := (p2 , -(p1 rem p2))
       if degree(p1) > 0
       then
         p1 := unitCanonical(p1)
         res := [ term quo p1 for term in res ]
       reverse! res

     if TheField has OrderedRing
     then

       boundOfCauchy(p) ==
         c : TheField := inv(leadingCoefficient(p))
         l := [ c*term for term in rest(coefficients(p))]
         empty?(l) => 1
         1 + ("max" / [ abs(t) for t in l ])

--       sturmVariationsOf(l) ==
--         res : N := 0
--         lsg := sign(first(l))
--         for term in l repeat
--           if (sg := sign(term) ) ~= 0 then
--             if (sg ~= lsg) then res := res + 1
--             lsg := sg
--         res

       sturmVariationsOf(l) ==
         empty?(l) => error "POLUTIL: sturmVariationsOf: empty list !"
         l1 := first(l)
         -- first 0 counts as a sign
         ll : List(TheField) := []
         for term in rest(l) repeat
           -- zeros don't count
           if not(zero?(term)) then ll := cons(term, ll)
         -- if l1 is not zero then ll = reverse(l)
         empty?(ll) => error "POLUTIL: sturmVariationsOf: Bad sequence"
         ln := first(ll)
         ll := reverse(rest(ll))
         -- if l1 is not zero then first(l) = first(ll)
         -- if l1 is zero then first zero should count as a sign
         zero?(l1) => 1 + lazyVariations(rest(ll), sign(first(ll)), sign(ln))
         lazyVariations(ll, sign(l1), sign(ln))

       lazyVariations(l, sl, sh) ==
         zero?(sl) or zero?(sh) => error "POLUTIL: lazyVariations: zero sign!"
         empty?(l) =>
           if sl = sh then 0 else 1
         empty?(rest(l)) =>
           if zero?(first(l))
           then error "POLUTIL: lazyVariations: zero sign!"
           else
             if sl = sh
             then
               if (sl = sign(first(l)))
               then 0
               else 2
             -- in this case we save one test
             else 1
         s := sign(l.2)
         lazyVariations([first(l)], sl, s) +
           lazyVariations(rest(rest(l)), s, sh)

