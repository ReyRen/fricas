3439                (MAKEPROP '|VarCat| 'NILADIC T)
(|VarCat|)
|category|
(((|VarCat|) (|Category|)) (T |VarCat|))
(|Join| (|Type|) (|CoercibleTo| (|OutputForm|))
        (CATEGORY |domain| (SIGNATURE |var| ($ (|String|)))
         (SIGNATURE |var| ($ (|String|) (|ILogic|)))
         (SIGNATURE |getName| ((|String|) $))
         (SIGNATURE |getType| ((|ILogic|) $))
         (SIGNATURE |toString| ((|String|) $))
         (SIGNATURE |parseVar| ($ (|String|)))
         (SIGNATURE |parseVarTerm|
          ((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|)))
           (|String|) (|NonNegativeInteger|)))
         (SIGNATURE = ((|Boolean|) $ $))))
"/git/fricas/src/algebra/VARCAT.spad"
((|var| (*1 *1 *2)
  (AND (|isDomain| *2 (|String|)) (|ofCategory| *1 (|VarCat|))))
 (|var| (*1 *1 *2 *3)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *3 (|ILogic|))
       (|ofCategory| *1 (|VarCat|))))
 (|getName| (*1 *2 *1)
  (AND (|ofCategory| *1 (|VarCat|)) (|isDomain| *2 (|String|))))
 (|getType| (*1 *2 *1)
  (AND (|ofCategory| *1 (|VarCat|)) (|isDomain| *2 (|ILogic|))))
 (|toString| (*1 *2 *1)
  (AND (|ofCategory| *1 (|VarCat|)) (|isDomain| *2 (|String|))))
 (|parseVar| (*1 *1 *2)
  (AND (|isDomain| *2 (|String|)) (|ofCategory| *1 (|VarCat|))))
 (|parseVarTerm| (*1 *2 *3 *4)
  (AND (|isDomain| *3 (|String|)) (|isDomain| *4 (|NonNegativeInteger|))
       (|isDomain| *2
                   (|Record| (|:| |rft| *1)
                             (|:| |pout| (|NonNegativeInteger|))))
       (|ofCategory| *1 (|VarCat|))))
 (= (*1 *2 *1 *1)
    (AND (|ofCategory| *1 (|VarCat|)) (|isDomain| *2 (|Boolean|)))))
((|var| (($ (|String|)) 6) (($ (|String|) (|ILogic|)) 6))
 (|toString| (((|String|) $) 6))
 (|parseVarTerm|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   6))
 (|parseVar| (($ (|String|)) 6)) (|getType| (((|ILogic|) $) 6))
 (|getName| (((|String|) $) 6)) (|coerce| (((|OutputForm|) $) 6))
 (= (((|Boolean|) $ $) 6)))
VARCAT
(((|Type|) . T) ((|CoercibleTo| (|OutputForm|)) . T))
(((|CoercibleTo| (|OutputForm|)) . T) ((|Type|) . T))
((|constructor|
  (NIL
   "VarCat represents a variable in Lambda and Ski domains. Since we are working in terms of functions then a variable will be a function (possibly a constant function) a variable has a name represented by a String. If the Lambda or Ski calculus is typed then the variable will also have a type."))
 (=
  (((|Boolean|) $ $)
   "return \\spad{true} if equal,{} that is names are equal and if there is a type then they must also be equal"))
 (|parseVarTerm|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   "construct a variable by parsing a string pin is index to string at start of parse pout is index to string at end of parse"))
 (|parseVar| (($ (|String|)) "construct a variable by parsing a string"))
 (|toString| (((|String|) $) "returns the name and the type in string form."))
 (|getType|
  (((|ILogic|) $)
   "returns the type of the variable. This may be a compound type,{} for instance [\"a\",{}\\spad{\"b\"}] represents a-\\spad{>b} a function from type a to type \\spad{b} untyped implementations return []"))
 (|getName| (((|String|) $) "returns the name of the variable."))
 (|var|
  (($ (|String|) (|ILogic|))
   "constructs variable with a name and also a type.")
  (($ (|String|)) "constructs variable with a name but no type.")))
(("documentation" 0 2110) ("ancestors" 0 2056) ("parents" 0 2002)
 ("abbreviation" 0 1995) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 1618) ("modemaps" 0 697) ("sourceFile" 0 659)
 ("constructorCategory" 0 115) ("constructorModemap" 0 74)
 ("constructorKind" 0 63) ("constructorForm" 0 52) ("NILADIC" 0 20))