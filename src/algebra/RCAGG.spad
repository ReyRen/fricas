)abbrev category RCAGG RecursiveAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A recursive aggregate over a type S is a model for a
++ a directed graph containing values of type S.
++ Recursively, a recursive aggregate is either empty or a {\em node}
++ consisting of a \spadfun{value} from S and 0 or more \spadfun{children}
++ which are recursive aggregates.
++ A node with no children is called a \spadfun{leaf} node.
++ A recursive aggregate may be cyclic for which some operations as noted
++ may go into an infinite loop.
RecursiveAggregate(S : Type) : Category == HomogeneousAggregate(S) with
   children : % -> List %
     ++ children(u) returns a list of the children of aggregate u.
   -- should be % -> %* and also needs children: % -> Iterator(S, S)
   nodes : % -> List %
     ++ nodes(u) returns a list of all of the nodes of aggregate u.
   -- to become % -> %* and also nodes: % -> Iterator(S, S)
   leaf? : % -> Boolean
     ++ leaf?(u) tests if u is a terminal node.
   value : % -> S
     ++ value(u) returns the value of the node u.
   elt : (%, "value") -> S
     ++ elt(u, "value") (also written: \spad{u.value}) is
     ++ equivalent to \spad{value(u)}.
   cyclic? : % -> Boolean
     ++ cyclic?(u) tests if u has a cycle.
   leaves : % -> List S
     ++ leaves(u) returns the list of leaves in aggregate \spad{u}.
   distance : (%, %) -> Integer
     ++ distance(u, v) returns the path length (an integer) from node u to v.
   if S has BasicType then
      child? : (%, %) -> Boolean
        ++ child?(u, v) tests if node u is a child of node v.
      node? : (%, %) -> Boolean
        ++ node?(u, v) tests if node u is contained in node v
        ++ (either as a child, a child of a child, etc.).
   if % has shallowlyMutable then
      setchildren! : (%, List %) -> %
        ++ setchildren!(u, v) replaces the current children of node u
        ++ with the members of v in left-to-right order.
      setelt! : (%, "value", S) -> S
        ++ setelt!(u, "value", x) (also written \spad{u.value := x})
        ++ is equivalent to \spad{setvalue!(u, x)}
      setvalue! : (%, S) -> S
        ++ setvalue!(u, x) sets the value of node u to x.
 add

   import from List(%)

   elt(x,"value") == value x

   leaf? x ==
       empty? x => false
       empty? children x

   leaves x ==
       empty? x => empty()$List(S)
       leaf? x => [value x]
       concat [leaves y for y in children x]

   if % has shallowlyMutable then
       setelt!(x, "value", y) == setvalue!(x,y)
   if % has BasicType and S has BasicType then
       child?(x, l) == member?(x, children(l))

   if % has finiteAggregate then
       parts(x) == [value(i) for i in nodes(x)]

