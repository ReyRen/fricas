)abbrev category FPS FloatingPointSystem
++ Author:
++ Basic Operations: approximate, base, bits, digits, exponent, float,
++    mantissa, order, precision
++ Related Constructors:
++ Keywords: float, floating point
++ Description:
++ This category is intended as a model for floating point systems.
++ A floating point system is a model for the real numbers.  In fact,
++ it is an approximation in the sense that not all real numbers are
++ exactly representable by floating point numbers.
++ A floating point system is characterized by the following:
++
++   1: \spadfunFrom{base}{FloatingPointSystem} of the \spadfunFrom{exponent}{FloatingPointSystem}.
++          (actual implemenations are usually binary or decimal)
++   2: \spadfunFrom{precision}{FloatingPointSystem} of the \spadfunFrom{mantissa}{FloatingPointSystem} (arbitrary or fixed)
++   3: rounding error for operations
--++   4:  when, and what happens if exponent overflow/underflow occurs
++
++ Because a Float is an approximation to the real numbers, even though
++ it is defined to be a join of a Field and OrderedRing, some of
++ the attributes do not hold.  In particular associative("+")
++ does not hold.  Algorithms defined over a field need special
++ considerations when the field is a floating point system.
FloatingPointSystem() : Category == Join(RealNumberSystem(), Approximate,
                                         ConvertibleTo String) with
   "/" : (%, Integer) -> %
      ++ x / i computes the division from x by an integer i.
   float : (Integer, Integer) -> %
      ++ float(a, e) returns \spad{a * base() ^ e}.
   float : (Integer, Integer, PositiveInteger) -> %
      ++ float(a, e, b) returns \spad{a * b ^ e}.
   order : % -> Integer
      ++ order x is the order of magnitude of x.
      ++ Note: \spad{base ^ order x <= |x| < base ^ (1 + order x)}.
   base : () -> PositiveInteger
      ++ base() returns the base of the \spadfunFrom{exponent}{FloatingPointSystem}.
   exponent : % -> Integer
      ++ exponent(x) returns the \spadfunFrom{exponent}{FloatingPointSystem} part of x.
   mantissa : % -> Integer
      ++ mantissa(x) returns the mantissa part of x.
  -- round?: () -> B
  --    ++ round?() returns the rounding or chopping.
   toString : % -> String
      ++ \spad{toString(x)} returns the string representation of x.
   toString : (%, NonNegativeInteger) -> String
      ++ \spad{toString(x, n)} returns a string representation of x
      ++ truncated to n decimal digits.
   bits : () -> PositiveInteger
      ++ bits() returns ceiling's precision in bits.
   digits : () -> PositiveInteger
      ++ digits() returns ceiling's precision in decimal digits.
   precision : () -> PositiveInteger
      ++ precision() returns the precision in digits base.

   if % has arbitraryPrecision then
      bits : PositiveInteger -> PositiveInteger
        ++ bits(n) set the \spadfunFrom{precision}{FloatingPointSystem} to n bits.
      digits : PositiveInteger -> PositiveInteger
        ++ digits(d) set the \spadfunFrom{precision}{FloatingPointSystem} to d digits.
      precision : PositiveInteger -> PositiveInteger
        ++ precision(n) set the precision in the base to n decimal digits.
      increasePrecision : Integer -> PositiveInteger
        ++ increasePrecision(n) increases the current
        ++ \spadfunFrom{precision}{FloatingPointSystem} by n decimal digits.
      decreasePrecision : Integer -> PositiveInteger
        ++ decreasePrecision(n) decreases the current
        ++ \spadfunFrom{precision}{FloatingPointSystem} precision by n decimal digits.
   if not (% has arbitraryExponent) then
    --  overflow: (()->Exit) -> Void
    --    ++ overflow() returns the Exponent overflow of float
    --  underflow: (()->Exit) -> Void
    --    ++ underflow() returns the Exponent underflow of float
    --  maxExponent: () -> Integer
    --    ++ maxExponent() returns the max Exponent of float
      if not (% has arbitraryPrecision) then
         min : () -> %
          ++ min() returns the minimum floating point number.
         max : () -> %
          ++ max() returns the maximum floating point number.
 add
   float(ma, ex) == float(ma, ex, base())
   digits() == max(1, 4004 * (bits()-1) quo 13301)::PositiveInteger

   toString x == convert(x)@String
   toString(x : %, n : NonNegativeInteger) : String ==
       x1 := round x
       x0 := abs(x-x1)
       tenn := float(1, n::Integer, 10)
       x2 := round(tenn*x0)
       res:List String := [convert(retract(x1))@String,".",convert(retract(x2))@String]
       concat res

)if false
\section{domain DFLOAT DoubleFloat}
Greg Vanuxem has added some functionality to allow the user to modify
the printed format of floating point numbers. The format of the numbers
follows the common lisp format specification for floats. First we include
Greg's email to show the use of this feature:

\begin{verbatim}
(1) -> a := matrix [ [0.5978, 0.2356], [0.4512, 0.2355] ]

        +0.5978  0.2356+
   (1)  |              |
        +0.4512  0.2355+
                               Type : Matrix DoubleFloat
(2) -> doubleFloatFormat("~,4,,F")

   (2)  "~A"
                               Type : String
(3) -> a

        +0.5978  0.2356+
   (3)  |              |
        +0.4512  0.2355+
                               Type : Matrix DoubleFloat

\end{verbatim}
So it is clear that he has added a new function called
{\tt doubleFloatFormat} which takes a string argument that
specifies the common lisp format control string (\"{}\~{},4,,F\"{}).
For reference we quote from the common lisp manual \cite{1}.
On page 582 we find:

\begin{quote}
A format directive consists of a tilde (\~{}), optional prefix
parameters separated by commas, optional colon (: ) and at-sign (@)
modifiers, and a single character indicating what kind of directive this is.
The alphabetic case of the directive character is ignored. The prefix
parameters are generally integers, notated as optionally signed decimal
numbers.

X3J13 voted in June 1987 (80) to specify that if both colon and at-sign
modifiers are present, they may appear in either order; thus \~{}: @R
and \~{}@: R mean the same thing. However, it is traditional to put the
colon first, and all examples in the book put colon before at-signs.
\end{quote}

\noindent
On page 588 we find:

\begin{quote}
\~{}F

{\sl Fixed-format floating-point}. The next {\sl arg} is printed as a
floating point number.

The full form is {\sl \~{}w, d, k, overfowchar, padchar}F. The parameter
{\sl w} is the width of the filed to be printed; {\sl d} is the number
of digits to print after the decimal point; {\sl k} is a scale factor
that defaults to zero.

Exactly {\sl w} characters will be output. First, leading copies of the
character {\sl padchar} (which defaults to a space) are printed, if
necessary, to pad the field on the left. If the {\sl arg} is negative,
then a minus sign is printed; if the {\sl arg} is not negative, then
a plus signed is printed if and only if the @ modifier was specified.
Then a sequence of digits, containing a single embedded decimal point,
is printed; this represents the magnitude of the value of {\sl arg}
times $10^k$, rounded to {\sl d} fractional digits. (When rounding up
and rounding down would produce printed values equidistant from the
scaled value of {\sl arg}, then the implementation is free to use
either one. For example, printing the argument 6.375 using the format
\~{}4.2F may correctly produce either 6.37 or 6.38.) Leading zeros are
not permitted, except that a single zero digit is output before the
decimal point if the printed value is less than 1, and this single zero
digit is not output after all if $w = d + 1$.

If it is impossible to print the value in the required format in the
field of width {\sl w}, then one of two actions is taken. If the
parameter {\sl overflowchar} is specified, then {\sl w} copies of that
parameter are printed instead of the scaled value of {\sl arg}. If the
{\sl overflowchar} parameter is omitted, then the scaled value is
printed using more than {\sl w} characters, as many more as may be
needed.

If the {\sl w} parameter is omitted, then the field is of variable width.
In effect, a value is chosen for {\sl w} in such a way that no leading pad
characters need to be printed and exactly {\sl d} characters will follow
the decimal point. For example, the directive \~{}, 2F will print exactly
two digits after the decimal point and as many as necessary before the
decimal point.

If the parameter {\sl d} is omitted, then there is no constraint on the
number of digits to appear after the decimal point. A value is chosen
for {\sl d} in such a way that as many digits as possible may be printed
subject to the width constraint imposed by the parameter {\sl w} and the
constraint that no trailing zero digits may appear in the fraction, except
that if the fraction to be printed is zero, then a single zero digit should
appear after the decimal point if permitted by the width constraint.

If both {\sl w} and {\sl d} are omitted, then the effect is to print the
value using ordinary free-format output; {\tt prin1} uses this format
for any number whose magnitude is either zero or between $10^{-3}$
(inclusive) and $10^7$ (exclusive).

If {\sl w} is omitted, then if the magnitude of {\sl arg} is so large
(or, if {\sl d} is also omitted, so small) that more than 100 digits
would have to be printed, then an implementation is free, at its
discretion, to print the number using exponential notation instead,
as if by the directive \~{}E (with all parameters of \~{}E defaulted,
not taking their valued from the \~{}F directive).

If {\sl arg} is a rational number, then it is coerced to be a
{\tt single-float} and then printed. (Alternatively, an implementation
is permitted to process a rational number by any other method that has
essentially the same behavior but avoids such hazards as loss of
precision or overflow because of the coercion. However, note that if
{\sl w} and {\sl d} are unspecified and the number has no exact decimal
representation, for example 1/3, some precision cutoff must be chosen
by the implementation; only a finite number of digits may be printed.)

If {\sl arg} is a complex number or some non-numeric object, then it
is printed using the format directive {\sl \~{}w}D, thereby printing
it in decimal radix and a minimum field width of {\sl w}. (If it is
desired to print each of the real part and imaginary part of a
complex number using a \~{}F directive, then this must be done explicitly
with two \~{}F directives and code to extract the two parts of the
complex number.)

\end{quote}
)endif


