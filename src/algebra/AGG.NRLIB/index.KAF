3688                (MAKEPROP '|Aggregate| 'NILADIC T)
(|Aggregate|)
|category|
(((|Aggregate|) (|Category|)) (T |Aggregate|))
(|Join| (|Type|)
        (CATEGORY |domain| (SIGNATURE |eq?| ((|Boolean|) $ $))
         (SIGNATURE |copy| ($ $)) (SIGNATURE |empty| ($))
         (SIGNATURE |empty?| ((|Boolean|) $))
         (SIGNATURE |less?| ((|Boolean|) $ (|NonNegativeInteger|)))
         (SIGNATURE |more?| ((|Boolean|) $ (|NonNegativeInteger|)))
         (SIGNATURE |size?| ((|Boolean|) $ (|NonNegativeInteger|)))
         (SIGNATURE |sample| ($) |constant|)
         (IF (|has| $ (|finiteAggregate|))
             (SIGNATURE |#| ((|NonNegativeInteger|) $))
             |noBranch|)))
"/git/fricas/src/algebra/AGG.spad"
((|eq?| (*1 *2 *1 *1)
  (AND (|ofCategory| *1 (|Aggregate|)) (|isDomain| *2 (|Boolean|))))
 (|copy| (*1 *1 *1) (|ofCategory| *1 (|Aggregate|)))
 (|empty| (*1 *1) (|ofCategory| *1 (|Aggregate|)))
 (|empty?| (*1 *2 *1)
  (AND (|ofCategory| *1 (|Aggregate|)) (|isDomain| *2 (|Boolean|))))
 (|less?| (*1 *2 *1 *3)
  (AND (|ofCategory| *1 (|Aggregate|)) (|isDomain| *3 (|NonNegativeInteger|))
       (|isDomain| *2 (|Boolean|))))
 (|more?| (*1 *2 *1 *3)
  (AND (|ofCategory| *1 (|Aggregate|)) (|isDomain| *3 (|NonNegativeInteger|))
       (|isDomain| *2 (|Boolean|))))
 (|size?| (*1 *2 *1 *3)
  (AND (|ofCategory| *1 (|Aggregate|)) (|isDomain| *3 (|NonNegativeInteger|))
       (|isDomain| *2 (|Boolean|))))
 (|sample| (*1 *1) (|ofCategory| *1 (|Aggregate|)))
 (|#| (*1 *2 *1)
  (AND (|ofCategory| *1 (|finiteAggregate|)) (|ofCategory| *1 (|Aggregate|))
       (|isDomain| *2 (|NonNegativeInteger|)))))
((|size?| (((|Boolean|) $ (|NonNegativeInteger|)) 6))
 (|sample| (($) 6 T CONST))
 (|more?| (((|Boolean|) $ (|NonNegativeInteger|)) 6))
 (|less?| (((|Boolean|) $ (|NonNegativeInteger|)) 6))
 (|eq?| (((|Boolean|) $ $) 6)) (|empty?| (((|Boolean|) $) 6)) (|empty| (($) 6))
 (|copy| (($ $) 6))
 (|#| (((|NonNegativeInteger|) $) 6 (|has| $ (|finiteAggregate|)))))
AGG
(((|Type|) . T))
(((|Type|) . T))
((|constructor|
  (NIL
   "The notion of aggregate serves to model any data structure aggregate,{} designating any collection of objects,{} with heterogeneous or homogeneous members,{} with a finite or infinite number of members,{} explicitly or implicitly represented. An aggregate can in principle represent everything from a string of characters to abstract sets such as \"the set of \\spad{x} satisfying relation {\\em r(x)}\". An attribute \\spadatt{finiteAggregate} is used to assert that a domain has a finite number of elements."))
 (|#|
  (((|NonNegativeInteger|) $)
   "\\spad{\\#(u)} returns the number of elements in \\spad{u}."))
 (|sample| (($) "\\spad{sample yields} a value of type \\%"))
 (|size?|
  (((|Boolean|) $ (|NonNegativeInteger|))
   "\\spad{size?(u,{} n)} tests if \\spad{u} has exactly \\spad{n} elements."))
 (|more?|
  (((|Boolean|) $ (|NonNegativeInteger|))
   "\\spad{more?(u,{} n)} tests if \\spad{u} has more than \\spad{n} elements."))
 (|less?|
  (((|Boolean|) $ (|NonNegativeInteger|))
   "\\spad{less?(u,{} n)} tests if \\spad{u} has less than \\spad{n} elements."))
 (|empty?|
  (((|Boolean|) $) "\\spad{empty?(u)} tests if \\spad{u} has 0 elements."))
 (|empty|
  (($)
   "\\spad{empty()}\\$\\spad{D} creates an aggregate of type \\spad{D} with 0 elements. Note: The {\\em \\$D} can be dropped if understood by context,{} \\spadignore{e.g.} \\spad{u: D := empty()}."))
 (|copy|
  (($ $)
   "\\spad{copy(u)} returns a top-level (non-recursive) copy of \\spad{u}. Note: for collections,{} \\spad{copy(u) = [x for x in u]}."))
 (|eq?|
  (((|Boolean|) $ $)
   "\\spad{eq?(u,{} v)} tests if \\spad{u} and \\spad{v} are same objects.")))
(("documentation" 0 2016) ("ancestors" 0 1999) ("parents" 0 1982)
 ("abbreviation" 0 1978) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 1619) ("modemaps" 0 721) ("sourceFile" 0 686)
 ("constructorCategory" 0 127) ("constructorModemap" 0 80)
 ("constructorKind" 0 69) ("constructorForm" 0 55) ("NILADIC" 0 20))