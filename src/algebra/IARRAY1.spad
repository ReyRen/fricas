)abbrev domain IARRAY1 IndexedOneDimensionalArray
++ Author Micheal Monagan Aug/87
++ This is the basic one dimensional array data type.

IndexedOneDimensionalArray(S : Type, mn : Integer):
 OneDimensionalArrayAggregate S == add
   Qmax ==> QVMAXINDEX$Lisp
   Qsize ==> QVSIZE$Lisp
   Qelt ==> QAREF1$Lisp
   Qsetelt ==> QSETVELT$Lisp
   Qnew ==> MAKE_-ARRAY$Lisp
   Qnew1 ==> MAKEARR1$Lisp
   I ==> Integer

   #x               == Qsize x
   fill!(x, s)     == (for i in 0..Qmax x repeat Qsetelt(x, i, s); x)
   minIndex x       == mn

   empty()          == Qnew(0$Lisp)
   new(n, s)        == Qnew1(n, s)

   map!(f, s1)  ==
      n : Integer := Qmax(s1)
      n < 0 => s1
      for i in 0..n repeat Qsetelt(s1, i, f(Qelt(s1, i)))
      s1

   map(f, s1)       ==
      n : Integer := Qmax(s1)
      n < 0 => s1
      ss2 : % := Qnew(n+1)
      for i in 0..n repeat Qsetelt(ss2, i, f(Qelt(s1, i)))
      ss2

   map(f, a, b)   ==
      maxind : Integer := min(Qmax a, Qmax b)
      maxind < 0 => empty()
      c : % := Qnew(maxind+1)
      for i in 0..maxind repeat
        Qsetelt(c, i, f(Qelt(a, i), Qelt(b, i)))
      c

   -- logically unnecessary, but we want to take advantage from
   -- fast indexing.
   if S has SetCategory then

       hashUpdate!(s : HashState, x : %) : HashState ==
           for i in 0..Qmax x repeat
               s := hashUpdate!(s, Qelt(x, i))$S
           s

   if zero? mn then
     qelt(x, i)       == Qelt(x, i)
     qsetelt!(x, i, s) == Qsetelt(x, i, s)

     elt(x : %, i : I) ==
       negative? i or i > maxIndex(x) => error "index out of range"
       qelt(x, i)

     setelt!(x : %, i : I, s : S) ==
       negative? i or i > maxIndex(x) => error "index out of range"
       qsetelt!(x, i, s)

   else if (mn = 1) then
     maxIndex x       == Qsize x
     qelt(x, i)       == Qelt(x, i-1)
     qsetelt!(x, i, s) == Qsetelt(x, i-1, s)

     elt(x : %, i : I) ==
       less_SI(i, 1$Lisp)$Lisp or less_SI(Qsize x, i)$Lisp =>
         error "index out of range"
       Qelt(x, i-1)

     setelt!(x : %, i : I, s : S) ==
       less_SI(i, 1$Lisp)$Lisp or less_SI(Qsize x, i)$Lisp =>
         error "index out of range"
       Qsetelt(x, i-1, s)

    else
       qelt(x, i)       == Qelt(x, i - mn)
       qsetelt!(x, i, s) == Qsetelt(x, i - mn, s)

       elt(x : %, i : I) ==
         i < mn or i > maxIndex(x) => error "index out of range"
         qelt(x, i)

       setelt!(x : %, i : I, s : S) ==
         i < mn or i > maxIndex(x) => error "index out of range"
         qsetelt!(x, i, s)

