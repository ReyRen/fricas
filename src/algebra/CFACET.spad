)abbrev domain CFACET CubicalFacet
++ Author: Martin Baker
++ Description:
++   A single vertex, edge, square, cube...
++   for more documentation see:
++   http://www.euclideanspace.com/prog/scratchpad/mycode/topology/cubical/
++ Date Created: April 2016
++ Basic Operations:
++ Related packages:
++ Related categories: FacetCategory
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:

CubicalFacet() : Exports == Impl where
  NNI==> NonNegativeInteger
  x<<y ==> hconcat(x::OutputForm, y::OutputForm)

  Exports ==> FacetCategory with
    cubicalFacet : (mul : Integer, fac : List(Segment(Integer))) -> %
      ++ Constructor for cubical facet
      ++ intervals are always stored in low..high order
      ++ orientation is calculated by the number of intervals that have to be
      ++ flipped to put it in order.
    cubicalFacet : (mul : Integer, fac : List(List(Integer))) -> %
      ++ Constructor for cubical facet
    cubicalFacet : (mul : Integer, fac : CubicalFacet) -> %
      ++ Copy constructor which can change mul
    getIntervals : (orf : %) -> List(Segment(Integer))
      ++ returns intervals in face one for each dimension
    setMult : (orf : %, m : Integer) -> %
      ++ sets multiplier of face
    position : (e : %, lst : List(%)) -> Integer
      ++ return index of e in lst. Index will be negative if e has
      ++ negative multiplier.
    product : (a : %, b : %) -> %
      ++ This function returns the product of two cubical facets.
      ++ Unlike the simplex case, the product is a sinle facet
    boundary : (orf : %) -> List(%)
      ++ construct the boundary. This is like hollowing out
      ++ the facet.
    sameFace? : (a : %, b : %) -> Boolean
      ++ true if this is the same face although the orientation
      ++ may be different.
    allSubsets : (orf : %, minDim : NNI) -> List(%)
      ++ allSubsets of a given facet
      ++ returned in reverse order
      ++ subsets returned are not oriented
    allSubsets : (orf : %, minDim : NNI, maxDim : NNI) -> List(%)
      ++ allSubsets of a given length
      ++ returned in reverse order
      ++ subsets returned are not oriented

  Impl ==> add

   -- A facet is a list of indexes (ordered)
   -- 'mul' encodes the orientation. When we are interpreting this as a
   -- geometric object it is usually 1 or -1 (to reverse direction).
   -- When we are interpreting this as a linear algebra object then we
   -- treat it as an integer.
   Rep := Record(mul : Integer, fac : List(Segment(Integer)))

   -- Constructor for cubical facet
   -- intervals are always stored in low..high order
   -- orientation is calculated by the number of intervals that have
   -- to be flipped to put it in order.
   cubicalFacet(mul1 : Integer, fac1 : List(Segment(Integer))) : % ==
       --print("cubicalFacet(" << mul1 << ", " << fac1)
       mul2 : Integer := mul1
       fac2 := []$List(Segment(Integer))
       invert : Boolean := false
       for x in fac1 repeat
           interv : Segment(Integer) := x
           lo := low(x)
           hi := high(x)
           if lo > hi then
               interv := segment(hi, lo)
               invert := not invert
           fac2 := concat(fac2, interv)
       if invert then mul2 := -mul2
       [mul2, fac2]

   -- Constructor for cubical facet
   cubicalFacet(mul1 : Integer, fac1 : List(List(Integer))) : % ==
       --print("cubicalFacet(" << mul1 << ", " << fac1)
       fac2 := []$List(Segment(Integer))
       for x in fac1 repeat
           if #x ~= 2 then error "inner list should contain low, high"
           interv : Segment(Integer) := segment(first(x), second(x))
           fac2 := concat(fac2, interv)
       [mul1, fac2]

   -- Copy constructor which can change mul
   cubicalFacet(mul1 : Integer, fac1 : CubicalFacet) : % ==
       fac2 : List(Segment(Integer)) := getIntervals(fac1)
       [mul1, fac2]

   -- returns intervals in face one for each dimension
   getIntervals(orf : %) : List(Segment(Integer)) ==
       orf.fac

   -- The number of non-degenerate intervals.
   -- In simplex this would be the number of vertices but here it is
   -- more like the number of degrees of freedom.
   order(f : %) : NNI ==
       value : NNI := 0
       facet : List(Segment(Integer)) := f.fac
       for seg in facet repeat
           lo := low(seg)
           hi := high(seg)
           value := value + abs(hi-lo)::NNI
       value

   -- returns multiplier of face
   getMult(orf : %) : Integer ==
       orf.mul

   -- sets multiplier of face
   setMult(orf : %, m : Integer) : % ==
       fac2 : List(Segment(Integer)) := getIntervals(orf)
       cubicalFacet(m, fac2)

   -- return index of e in lst. Index will be negative if e has
   -- negative multiplier.
   position(e : %, lst : List(%)) : Integer ==
       --print("position(" << e << ", " << lst << ")")
       res : Integer := 1
       for x in lst repeat
           if e.fac = x.fac then
               if e.mul=x.mul then return res
               return -res
           res := res + 1
       return 0

   -- This function returns the product of two cubical facets.
   -- Unlike the simplex case, the product is a sinle facet
   -- For more detailed explanation of cubical product code see:
   -- \url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/cubical/}
   product(a : %, b : %) : % ==
       aint : List(Segment(Integer)) := getIntervals(a)
       bint : List(Segment(Integer)) := getIntervals(b)
       cubicalFacet(1, concat(aint, bint))

   -- local function used by boundary operator.
   boundaryOneDimension(orf : %, dim : NNI, invert : Boolean) : List(%) ==
       facet : List(Segment(Integer)) := orf.fac
       mult : Integer := orf.mul
       subFacet1 := []$List(Segment(Integer))
       subFacet2 := []$List(Segment(Integer))
       for seg in facet for segn in 1..(#facet) repeat
           lo := low(seg)
           hi := high(seg)
           if segn = dim then
               subFacet1 := concat(subFacet1, segment(lo, lo))
               subFacet2 := concat(subFacet2, segment(hi, hi))
           else
               subFacet1 := concat(subFacet1, seg)
               subFacet2 := concat(subFacet2, seg)
       if invert then mult := -mult
       res := []$List(%)
       r1 : % := cubicalFacet(-mult, subFacet1)
       res := concat(res, r1)$List(%)
       r2 : % := cubicalFacet(mult, subFacet2)
       res := concat(res, r2)$List(%)
       res

   -- Boundary operator. This is like hollowing out the facet.
   boundary(orf : %) : List(%) ==
       facet : List(Segment(Integer)) := orf.fac
       mult : Integer := orf.mul
       -- dims will hold array of indexes of non-degenerate intervals
       dims := []$List(NNI)
       for seg in facet for segn in 1..(#facet) repeat
           lo := low(seg)
           hi := high(seg)
           if (lo ~= hi) then dims := concat(dims, segn)
       res := []$List(%)
       invert : Boolean := false
       -- for each non-degenerate interval add boundary
       for dim in dims repeat
           -- print("boundary(" << orf << ", " << dim <<
           --       ")")
           res := concat(res, boundaryOneDimension(orf, dim, invert))
           invert := not invert
       --print("boundary res=" << res)
       res

   -- local function to add if new
   addIfNew(lst : List(%), orf : %) : List(%) ==
       -- print("addIfNew(" << lst << ", " << orf <<
       --       ")")
       if not empty?(orf) and member?(orf, lst)$List(%) then return lst
       concat(lst, orf)

   -- local function to add list if new
   addIfNew2(lst : List(%), orfs : List(%)) : List(%) ==
       -- print("addIfNew2(" << lst << ", " << orfs <<
       --       ")")
       if empty?(orfs) then return lst
       res : List(%) := copy(lst)
       for orf in orfs repeat
           if not empty?(orf) and not member?(orf, res)$List(%) then
               res := concat(res, orf)
       --print("addIfNew2(" << lst << ", " << orfs << _
       --    ") res=" << res)
       res

   -- allSubsets of given facet
   -- returned in reverse order
   -- subsets returned are not oriented
   allSubsets(orf : %, minDim : NNI) : List(%) ==
       -- print("allSubsets in (" << orf << ", " << minDim
       --       << ")")
       facet : List(Segment(Integer)) := orf.fac
       mult : Integer := orf.mul
       res := []$List(%)
       if order(orf) <= minDim then
           -- print("allSubsets out 1 orf=" << orf <<
           --       " order(orf)=" << _
           --         order(orf) << " result=" << res)
           return res
       for x in facet for xn in 1..(#facet) repeat
           -- print("allSubsets 2 x=" << x << " in facet="
           --       << facet)
           lo := low(x)
           hi := high(x)
           if lo ~= hi then
               segLo : Segment(Integer) := segment(lo, lo)
               segHi : Segment(Integer) := segment(hi, hi)
               rLo : List(Segment(Integer)) := copy(facet)
               setelt!(rLo, xn, segLo)
               rLo1 : % := cubicalFacet(1, rLo)
               res := addIfNew(res, rLo1)
               rHi : List(Segment(Integer)) := copy(facet)
               setelt!(rHi, xn, segHi)
               rHi1 : % := cubicalFacet(1, rHi)
               res := addIfNew(res, rHi1)
               -- print("allSubsets 3 order(rLo1)=" << order(rLo1)
               --       << " minDim=" << minDim)
               if order(rLo1) > minDim then
                   sub : List(%) := allSubsets(rLo1, minDim)
                   if not empty?(sub) then res := addIfNew2(res, sub)
               if order(rHi1) > minDim then
                   sub : List(%) := allSubsets(rHi1, minDim)
                   if not empty?(sub) then res := addIfNew2(res, sub)
       -- print("allSubsets out orf=" << orf << " result=" << res)
       res

   -- allSubsets of a given length
   -- returned in reverse order
   -- subsets returned are not oriented
   allSubsets(orf : %, minDim : NNI, maxDim : NNI) : List(%) ==
       --print("allSubsets(" << orf << ", " << _
       --       minDim << ", " << maxDim << ")")
       res : List(%) := allSubsets(orf, minDim)
       --print("allSubsets res=" << res)
       res2 := []$List(%)
       for y in res repeat
           if order(y) <= maxDim then
               res2 := concat(res2, y)$List(%)
       --print("allSubsets result=" << res2)
       res2

   -- true if this is the same face although the orientation
   -- may be different
   sameFace?(a : %, b : %) : Boolean ==
       vertsa : List(Segment(Integer)) := a.fac
       vertsb : List(Segment(Integer)) := b.fac
       not(vertsa ~= vertsb)

   -- less than Local
   ltLocal(a : List(Segment(Integer)), b : List(Segment(Integer))) : Boolean ==
       if a = b then return false
       -- if lists are different lengths then shortest first
       if ((#a) < 1) then return true
       if ((#b) < 1) then return false
       for a1 in a for b1 in b repeat
           loa := low(a1)
           hia := high(a1)
           lob := low(b1)
           hib := high(b1)
           if loa < lob then return true
           if loa > lob then return false
           if hia < hib then return true
           if hia > hib then return false
       false

   -- less than
   -- define an order so we can sort lists
   ((ain : %) < (bin : %)) : Boolean ==
       --"<"(ain : %, bin : %) : Boolean ==
       --print("<(" << ain << ", " << bin << ")")
       a : List(Segment(Integer)) := ain.fac
       b : List(Segment(Integer)) := bin.fac
       ltLocal(a, b)

   -- less than or equal
   -- define an order so we can sort lists
   ((ain : %) <= (bin : %)) : Boolean ==
       --"<="(ain : %, bin : %) : Boolean ==
       --print("<=(" << ain << ", " << bin << ")")
       a : List(Segment(Integer)) := ain.fac
       b : List(Segment(Integer)) := bin.fac
       if a = b then return true
       ltLocal(a, b)

   -- Returns true if x equals y.
   -- Assumes indexes are in order as this is forced by constructor.
   _=(a : %, b : %) : Boolean ==
       if a.mul ~= b.mul then return false
       a.fac = b.fac

   -- output
   coerce(s : %) : OutputForm ==
       prefix := message("")
       m : Integer := s.mul
       if abs(m) ~= 1 then
           prefix := hconcat(m::OutputForm, message("*"))
       if m = -1 then prefix := message("-")
       elements : List(OutputForm) := [x::OutputForm for x in s.fac]
       --print("orientedFacet coerce elements=" << _
       --   elements << " m=" << m)
       body : OutputForm := paren(elements)
       hconcat(prefix, body)

)if false
\section{Chain Complex}

Following from simplicial complexes and delta complexes I now want to
add chain complexes and co-chain complexes which are an algebriation
of these complexes.

The ChainComplex domain would be contain a sequence free abelian groups:
C0, C1, C2 ... 0
Which are defined like this:

C0 = Zero dimensional chain
= free abelian group on vertices.
Elements of C0 are intergral linear combinations of vertices such as: 2x+7y+5z

C1 = One dimensional chain
= free abelian group on directed edges (1-cells).
Elements of C1 are intergral linear combinations of edges such as: 2xy+7xz+5yz
These don't necessarily need to be a cycle or even connected.

C2 = two dimensional chain
= free abelian group on directed triangles (2-cells).

At this stage we are mostly interested in the linear
algebra structure. This comes from the mappings between these free
abelian groups. So we also need (non-free) abelian groups as quotients
of free abelian group. So the chain complex holds a set of free abelian
groups (chains) and a set of group homomorphisms.

\subsection{Creating Chain Complexes}
Here are two ways to construct a chain complex:
\begin{itemize}
\item Usually it is easier to construct a simplicial or delta complex
first and then call chain function.
\item We could alternatively construct from a list of matrices.
\end{itemize}
Here we construct a simplicial complex then call chain function:
\begin{verbatim}
(1) -> b1 := sphereSolid(2)$SimplicialComplexFactory(Integer)

   (1)  points 1..3
          (1,2,3)
                         Type: FiniteSimplicialComplex(Integer)
(2) -> chain(b1)

                  + 1    1    0 + + 1 +
                  |             | |   |
   (2)  [0  0  0],|- 1   0    1 |,|- 1|,[]
                  |             | |   |
                  + 0   - 1  - 1+ + 1 +
                                        Type: ChainComplex
\end{verbatim}
Or we could use constructor from a list of matrices.
\begin{verbatim}
chainComplex : (v : List(Matrix(Integer))) -> %
\end{verbatim}

\subsection{Representation of Chain Complexes}
This is a list of matrices although they represent (abelian) group
homomorphisms.

An alternative representation might be to use functions:
\begin{verbatim}
C0, C1, C2 ... 0
delta1:(C1) -> C0 , delta2:(C2) -> C1 ...
\end{verbatim}

where delta is a group homomorphism which respects the group structure:

\begin{verbatim}
delta(u+v) = delta u + delta v
delta(u^-1) =(delta u)^-1
\end{verbatim}

\subsection{Homology of Chain Complexes}
These group homomorphisms are represented by: Matrix(Integer)
so that we can solve using IntegerSmithNormalForm.

So the types of function that I would like to implement on
ChainComplex are:
\begin{verbatim}
image: (ChainComplex, delta) -> chain
kernel: (ChainComplex, delta) -> chain
\end{verbatim}

and we need to find cycles by finding null space of augmented matrix.

)endif

