23570               (|StreamTaylorSeriesOperations| A)
|package|
(((|StreamTaylorSeriesOperations| |#1|)
  (CATEGORY |package|
   (SIGNATURE + ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE - ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE - ((|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE * ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE * ((|Stream| |#1|) |#1| (|Stream| |#1|)))
   (SIGNATURE * ((|Stream| |#1|) (|Stream| |#1|) |#1|))
   (SIGNATURE |exquo|
    ((|Union| (|Stream| |#1|) "failed") (|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE / ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE |recip| ((|Union| (|Stream| |#1|) "failed") (|Stream| |#1|)))
   (SIGNATURE |monom| ((|Stream| |#1|) |#1| (|Integer|)))
   (SIGNATURE |integers| ((|Stream| (|Integer|)) (|Integer|)))
   (SIGNATURE |oddintegers| ((|Stream| (|Integer|)) (|Integer|)))
   (SIGNATURE |int| ((|Stream| |#1|) |#1|))
   (SIGNATURE |mapmult| ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE |deriv| ((|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE |gderiv|
    ((|Stream| |#1|) (|Mapping| |#1| (|Integer|)) (|Stream| |#1|)))
   (SIGNATURE |coerce| ((|Stream| |#1|) |#1|))
   (SIGNATURE |eval| ((|Stream| |#1|) (|Stream| |#1|) |#1|))
   (SIGNATURE |compose| ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE |lagrange| ((|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE |revert| ((|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE |addiag| ((|Stream| |#1|) (|Stream| (|Stream| |#1|))))
   (SIGNATURE |prodiag| ((|Stream| |#1|) (|Stream| (|Stream| |#1|))))
   (SIGNATURE |lambert| ((|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE |oddlambert| ((|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE |evenlambert| ((|Stream| |#1|) (|Stream| |#1|)))
   (SIGNATURE |generalLambert|
    ((|Stream| |#1|) (|Stream| |#1|) (|Integer|) (|Integer|)))
   (SIGNATURE |general_Lambert_product|
    ((|Stream| |#1|) (|Stream| |#1|) (|Integer|) (|Integer|)))
   (SIGNATURE |multisect|
    ((|Stream| |#1|) (|Integer|) (|Integer|) (|Stream| |#1|)))
   (SIGNATURE |invmultisect|
    ((|Stream| |#1|) (|Integer|) (|Integer|) (|Stream| |#1|)))
   (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|))))
       (PROGN
        (SIGNATURE |integrate| ((|Stream| |#1|) |#1| (|Stream| |#1|)))
        (SIGNATURE |lazyIntegrate|
         ((|Stream| |#1|) |#1| (|Mapping| (|Stream| |#1|))))
        (SIGNATURE |nlde| ((|Stream| |#1|) (|Stream| (|Stream| |#1|))))
        (SIGNATURE |powern|
         ((|Stream| |#1|) (|Fraction| (|Integer|)) (|Stream| |#1|))))
       |noBranch|)
   (IF (|has| |#1| (|Field|))
       (PROGN
        (SIGNATURE |mapdiv| ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
        (SIGNATURE |lazyGintegrate|
         ((|Stream| |#1|) (|Mapping| |#1| (|Integer|)) |#1|
          (|Mapping| (|Stream| |#1|))))
        (SIGNATURE |power| ((|Stream| |#1|) |#1| (|Stream| |#1|))))
       |noBranch|))
  (|Ring|))
 (T |StreamTaylorSeriesOperations|))
(CATEGORY |package|
 (SIGNATURE + ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE - ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE - ((|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE * ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE * ((|Stream| |#1|) |#1| (|Stream| |#1|)))
 (SIGNATURE * ((|Stream| |#1|) (|Stream| |#1|) |#1|))
 (SIGNATURE |exquo|
  ((|Union| (|Stream| |#1|) "failed") (|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE / ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE |recip| ((|Union| (|Stream| |#1|) "failed") (|Stream| |#1|)))
 (SIGNATURE |monom| ((|Stream| |#1|) |#1| (|Integer|)))
 (SIGNATURE |integers| ((|Stream| (|Integer|)) (|Integer|)))
 (SIGNATURE |oddintegers| ((|Stream| (|Integer|)) (|Integer|)))
 (SIGNATURE |int| ((|Stream| |#1|) |#1|))
 (SIGNATURE |mapmult| ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE |deriv| ((|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE |gderiv|
  ((|Stream| |#1|) (|Mapping| |#1| (|Integer|)) (|Stream| |#1|)))
 (SIGNATURE |coerce| ((|Stream| |#1|) |#1|))
 (SIGNATURE |eval| ((|Stream| |#1|) (|Stream| |#1|) |#1|))
 (SIGNATURE |compose| ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE |lagrange| ((|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE |revert| ((|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE |addiag| ((|Stream| |#1|) (|Stream| (|Stream| |#1|))))
 (SIGNATURE |prodiag| ((|Stream| |#1|) (|Stream| (|Stream| |#1|))))
 (SIGNATURE |lambert| ((|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE |oddlambert| ((|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE |evenlambert| ((|Stream| |#1|) (|Stream| |#1|)))
 (SIGNATURE |generalLambert|
  ((|Stream| |#1|) (|Stream| |#1|) (|Integer|) (|Integer|)))
 (SIGNATURE |general_Lambert_product|
  ((|Stream| |#1|) (|Stream| |#1|) (|Integer|) (|Integer|)))
 (SIGNATURE |multisect|
  ((|Stream| |#1|) (|Integer|) (|Integer|) (|Stream| |#1|)))
 (SIGNATURE |invmultisect|
  ((|Stream| |#1|) (|Integer|) (|Integer|) (|Stream| |#1|)))
 (IF (|has| |#1| (|Algebra| (|Fraction| (|Integer|))))
     (PROGN
      (SIGNATURE |integrate| ((|Stream| |#1|) |#1| (|Stream| |#1|)))
      (SIGNATURE |lazyIntegrate|
       ((|Stream| |#1|) |#1| (|Mapping| (|Stream| |#1|))))
      (SIGNATURE |nlde| ((|Stream| |#1|) (|Stream| (|Stream| |#1|))))
      (SIGNATURE |powern|
       ((|Stream| |#1|) (|Fraction| (|Integer|)) (|Stream| |#1|))))
     |noBranch|)
 (IF (|has| |#1| (|Field|))
     (PROGN
      (SIGNATURE |mapdiv| ((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)))
      (SIGNATURE |lazyGintegrate|
       ((|Stream| |#1|) (|Mapping| |#1| (|Integer|)) |#1|
        (|Mapping| (|Stream| |#1|))))
      (SIGNATURE |power| ((|Stream| |#1|) |#1| (|Stream| |#1|))))
     |noBranch|))
"/git/fricas/src/algebra/STTAYLOR.spad"
((|power| (*1 *2 *3 *2)
  (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Field|))
       (|ofCategory| *3 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (|lazyGintegrate| (*1 *2 *3 *4 *5)
  (AND (|isDomain| *3 (|Mapping| *4 (|Integer|)))
       (|isDomain| *5 (|Mapping| (|Stream| *4))) (|ofCategory| *4 (|Field|))
       (|ofCategory| *4 (|Ring|)) (|isDomain| *2 (|Stream| *4))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *4))))
 (|mapdiv| (*1 *2 *2 *2)
  (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Field|))
       (|ofCategory| *3 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (|powern| (*1 *2 *3 *2)
  (AND (|isDomain| *2 (|Stream| *4)) (|ofCategory| *4 (|Algebra| *3))
       (|ofCategory| *4 (|Ring|)) (|isDomain| *3 (|Fraction| (|Integer|)))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *4))))
 (|nlde| (*1 *2 *3)
  (AND (|isDomain| *3 (|Stream| (|Stream| *4))) (|isDomain| *2 (|Stream| *4))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *4))
       (|ofCategory| *4 (|Algebra| (|Fraction| (|Integer|))))
       (|ofCategory| *4 (|Ring|))))
 (|lazyIntegrate| (*1 *2 *3 *4)
  (AND (|isDomain| *4 (|Mapping| (|Stream| *3))) (|isDomain| *2 (|Stream| *3))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))
       (|ofCategory| *3 (|Algebra| (|Fraction| (|Integer|))))
       (|ofCategory| *3 (|Ring|))))
 (|integrate| (*1 *2 *3 *2)
  (AND (|isDomain| *2 (|Stream| *3))
       (|ofCategory| *3 (|Algebra| (|Fraction| (|Integer|))))
       (|ofCategory| *3 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (|invmultisect| (*1 *2 *3 *3 *2)
  (AND (|isDomain| *2 (|Stream| *4)) (|isDomain| *3 (|Integer|))
       (|ofCategory| *4 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *4))))
 (|multisect| (*1 *2 *3 *3 *2)
  (AND (|isDomain| *2 (|Stream| *4)) (|isDomain| *3 (|Integer|))
       (|ofCategory| *4 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *4))))
 (|general_Lambert_product| (*1 *2 *2 *3 *3)
  (AND (|isDomain| *2 (|Stream| *4)) (|isDomain| *3 (|Integer|))
       (|ofCategory| *4 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *4))))
 (|generalLambert| (*1 *2 *2 *3 *3)
  (AND (|isDomain| *2 (|Stream| *4)) (|isDomain| *3 (|Integer|))
       (|ofCategory| *4 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *4))))
 (|evenlambert| (*1 *2 *2)
  (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (|oddlambert| (*1 *2 *2)
  (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (|lambert| (*1 *2 *2)
  (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (|prodiag| (*1 *2 *3)
  (AND (|isDomain| *3 (|Stream| (|Stream| *4))) (|isDomain| *2 (|Stream| *4))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *4))
       (|ofCategory| *4 (|Ring|))))
 (|addiag| (*1 *2 *3)
  (AND (|isDomain| *3 (|Stream| (|Stream| *4))) (|isDomain| *2 (|Stream| *4))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *4))
       (|ofCategory| *4 (|Ring|))))
 (|revert| (*1 *2 *2)
  (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (|lagrange| (*1 *2 *2)
  (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (|compose| (*1 *2 *2 *2)
  (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (|eval| (*1 *2 *2 *3)
         (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
              (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (|coerce| (*1 *2 *3)
           (AND (|isDomain| *2 (|Stream| *3))
                (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))
                (|ofCategory| *3 (|Ring|))))
 (|gderiv| (*1 *2 *3 *2)
  (AND (|isDomain| *2 (|Stream| *4)) (|isDomain| *3 (|Mapping| *4 (|Integer|)))
       (|ofCategory| *4 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *4))))
 (|deriv| (*1 *2 *2)
  (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (|mapmult| (*1 *2 *2 *2)
  (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (|int| (*1 *2 *3)
  (AND (|isDomain| *2 (|Stream| *3))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))
       (|ofCategory| *3 (|Ring|))))
 (|oddintegers| (*1 *2 *3)
  (AND (|isDomain| *3 (|Integer|)) (|isDomain| *2 (|Stream| (|Integer|)))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *4))
       (|ofCategory| *4 (|Ring|))))
 (|integers| (*1 *2 *3)
  (AND (|isDomain| *3 (|Integer|)) (|isDomain| *2 (|Stream| (|Integer|)))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *4))
       (|ofCategory| *4 (|Ring|))))
 (|monom| (*1 *2 *3 *4)
  (AND (|isDomain| *4 (|Integer|)) (|isDomain| *2 (|Stream| *3))
       (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))
       (|ofCategory| *3 (|Ring|))))
 (|recip| (*1 *2 *2)
  (|partial| AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
   (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (/ (*1 *2 *2 *2)
    (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
         (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (|exquo| (*1 *2 *2 *2)
  (|partial| AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
   (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (* (*1 *2 *2 *3)
    (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
         (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (* (*1 *2 *3 *2)
    (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
         (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (* (*1 *2 *2 *2)
    (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
         (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (- (*1 *2 *2)
    (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
         (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (- (*1 *2 *2 *2)
    (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
         (|isDomain| *1 (|StreamTaylorSeriesOperations| *3))))
 (+ (*1 *2 *2 *2)
    (AND (|isDomain| *2 (|Stream| *3)) (|ofCategory| *3 (|Ring|))
         (|isDomain| *1 (|StreamTaylorSeriesOperations| *3)))))
((|revert| (((|Stream| |#1|) (|Stream| |#1|)) 90))
 (|recip| (((|Union| (|Stream| |#1|) "failed") (|Stream| |#1|)) 38))
 (|prodiag| (((|Stream| |#1|) (|Stream| (|Stream| |#1|))) 97))
 (|powern|
  (((|Stream| |#1|) (|Fraction| (|Integer|)) (|Stream| |#1|)) 141
   (|has| |#1| (|Algebra| (|Fraction| (|Integer|))))))
 (|power| (((|Stream| |#1|) |#1| (|Stream| |#1|)) 145 (|has| |#1| (|Field|))))
 (|oddlambert| (((|Stream| |#1|) (|Stream| |#1|)) 105))
 (|oddintegers| (((|Stream| (|Integer|)) (|Integer|)) 57))
 (|nlde|
  (((|Stream| |#1|) (|Stream| (|Stream| |#1|))) 129
   (|has| |#1| (|Algebra| (|Fraction| (|Integer|))))))
 (|multisect| (((|Stream| |#1|) (|Integer|) (|Integer|) (|Stream| |#1|)) 116))
 (|monom| (((|Stream| |#1|) |#1| (|Integer|)) 46))
 (|mapmult| (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) 73))
 (|mapdiv|
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) 143
   (|has| |#1| (|Field|))))
 (|lazyIntegrate|
  (((|Stream| |#1|) |#1| (|Mapping| (|Stream| |#1|))) 128
   (|has| |#1| (|Algebra| (|Fraction| (|Integer|))))))
 (|lazyGintegrate|
  (((|Stream| |#1|) (|Mapping| |#1| (|Integer|)) |#1|
    (|Mapping| (|Stream| |#1|)))
   144 (|has| |#1| (|Field|))))
 (|lambert| (((|Stream| |#1|) (|Stream| |#1|)) 104))
 (|lagrange| (((|Stream| |#1|) (|Stream| |#1|)) 89))
 (|invmultisect|
  (((|Stream| |#1|) (|Integer|) (|Integer|) (|Stream| |#1|)) 117))
 (|integrate|
  (((|Stream| |#1|) |#1| (|Stream| |#1|)) 126
   (|has| |#1| (|Algebra| (|Fraction| (|Integer|))))))
 (|integers| (((|Stream| (|Integer|)) (|Integer|)) 56))
 (|int| (((|Stream| |#1|) |#1|) 59))
 (|general_Lambert_product|
  (((|Stream| |#1|) (|Stream| |#1|) (|Integer|) (|Integer|)) 113))
 (|generalLambert|
  (((|Stream| |#1|) (|Stream| |#1|) (|Integer|) (|Integer|)) 107))
 (|gderiv| (((|Stream| |#1|) (|Mapping| |#1| (|Integer|)) (|Stream| |#1|)) 79))
 (|exquo|
  (((|Union| (|Stream| |#1|) "failed") (|Stream| |#1|) (|Stream| |#1|)) 36))
 (|evenlambert| (((|Stream| |#1|) (|Stream| |#1|)) 106))
 (|eval| (((|Stream| |#1|) (|Stream| |#1|) |#1|) 84))
 (|deriv| (((|Stream| |#1|) (|Stream| |#1|)) 75))
 (|compose| (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) 85))
 (|coerce| (((|Stream| |#1|) |#1|) 80))
 (|addiag| (((|Stream| |#1|) (|Stream| (|Stream| |#1|))) 98))
 (/ (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) 37))
 (- (((|Stream| |#1|) (|Stream| |#1|)) 21)
    (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) 23))
 (+ (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) 17))
 (* (((|Stream| |#1|) (|Stream| |#1|) |#1|) 28)
    (((|Stream| |#1|) |#1| (|Stream| |#1|)) 27)
    (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|)) 72)))
((|HasCategory| |#1| '(|Field|))
 (|HasCategory| |#1| (LIST '|Algebra| (LIST '|Fraction| '(|Integer|)))))
STTAYLOR
((|constructor|
  (NIL
   "StreamTaylorSeriesOperations implements Taylor series arithmetic,{} where a Taylor series is represented by a stream of its coefficients."))
 (|power|
  (((|Stream| |#1|) |#1| (|Stream| |#1|))
   "\\spad{power(a,{} f)} returns the power series \\spad{f} raised to the power \\spad{a}."))
 (|lazyGintegrate|
  (((|Stream| |#1|) (|Mapping| |#1| (|Integer|)) |#1|
    (|Mapping| (|Stream| |#1|)))
   "\\spad{lazyGintegrate(f,{} r,{} g)} is used for fixed point computations."))
 (|mapdiv|
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{mapdiv([a0,{} a1,{} ..],{} [b0,{} b1,{} ..])} returns \\spad{[a0/b0,{} a1/b1,{} ..]}."))
 (|powern|
  (((|Stream| |#1|) (|Fraction| (|Integer|)) (|Stream| |#1|))
   "\\spad{powern(r,{} f)} raises power series \\spad{f} to the power \\spad{r}."))
 (|nlde|
  (((|Stream| |#1|) (|Stream| (|Stream| |#1|)))
   "\\spad{nlde(u)} solves a first order non-linear differential equation described by \\spad{u} of the form \\spad{[[b<0,{} 0>,{} b<0,{} 1>,{} ...],{} [b<1,{} 0>,{} b<1,{} 1>,{} .],{} ...]}. the differential equation has the form \\spad{y' = sum(i=0 to infinity,{} j=0 to infinity,{} b<i,{} j>*(x^i)*(y^j))}."))
 (|lazyIntegrate|
  (((|Stream| |#1|) |#1| (|Mapping| (|Stream| |#1|)))
   "\\spad{lazyIntegrate(r,{} f)} is a version of integrate used for fixed point computations."))
 (|integrate|
  (((|Stream| |#1|) |#1| (|Stream| |#1|))
   "\\spad{integrate(r,{} a)} returns the integral of the power series \\spad{a} with respect to the power series variable where \\spad{r} denotes the constant of integration. Thus \\spad{integrate(a,{} [a0,{} a1,{} a2,{} ...]) = [a,{} a0,{} a1/2,{} a2/3,{} ...]}."))
 (|invmultisect|
  (((|Stream| |#1|) (|Integer|) (|Integer|) (|Stream| |#1|))
   "\\spad{invmultisect(a,{} b,{} st)} substitutes \\spad{x^((a+b)*n)} for \\spad{x^n} and multiplies by \\spad{x^b}."))
 (|multisect|
  (((|Stream| |#1|) (|Integer|) (|Integer|) (|Stream| |#1|))
   "\\spad{multisect(a,{} b,{} st)} selects the coefficients of \\spad{x^((a+b)*n+a)},{} and changes them to \\spad{x^n}."))
 (|general_Lambert_product|
  (((|Stream| |#1|) (|Stream| |#1|) (|Integer|) (|Integer|))
   "\\spad{general_Lambert_product(f(x),{} a,{} d)} returns \\spad{f(x^a)*f(x^(a + d))*f(x^(a + 2 d))* ...}. \\spad{f(x)} should have constant coefficient equal to one and \\spad{a} and \\spad{d} should be positive."))
 (|generalLambert|
  (((|Stream| |#1|) (|Stream| |#1|) (|Integer|) (|Integer|))
   "\\spad{generalLambert(f(x),{} a,{} d)} returns \\spad{f(x^a) + f(x^(a + d)) + f(x^(a + 2 d)) + ...}. \\spad{f(x)} should have zero constant coefficient and \\spad{a} and \\spad{d} should be positive."))
 (|evenlambert|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{evenlambert(st)} computes \\spad{f(x^2) + f(x^4) + f(x^6) + ...} if \\spad{st} is a stream representing \\spad{f(x)}. This function is used for computing infinite products. If \\spad{f(x)} is a power series with constant coefficient 1,{} then \\spad{prod(f(x^(2*n)),{} n=1..infinity) = exp(evenlambert(log(f(x))))}."))
 (|oddlambert|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{oddlambert(st)} computes \\spad{f(x) + f(x^3) + f(x^5) + ...} if \\spad{st} is a stream representing \\spad{f(x)}. This function is used for computing infinite products. If \\spad{f}(\\spad{x}) is a power series with constant coefficient 1 then \\spad{prod(f(x^(2*n-1)),{} n=1..infinity) = exp(oddlambert(log(f(x))))}."))
 (|lambert|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{lambert(st)} computes \\spad{f(x) + f(x^2) + f(x^3) + ...} if \\spad{st} is a stream representing \\spad{f(x)}. This function is used for computing infinite products. If \\spad{f(x)} is a power series with constant coefficient 1 then \\spad{prod(f(x^n),{} n = 1..infinity) = exp(lambert(log(f(x))))}."))
 (|prodiag|
  (((|Stream| |#1|) (|Stream| (|Stream| |#1|)))
   "\\spad{prodiag(x)} performs \"diagonal\" infinite product of a stream of streams. When \\spad{x(i)} is interpreted as stream of coefficients of series \\spad{f_i(z),{} i=1,{}...},{} then \\spad{prodiag(x) = (1 + z*f_1(z))*(1 + z^2*f_2(x))*...}"))
 (|addiag|
  (((|Stream| |#1|) (|Stream| (|Stream| |#1|)))
   "\\spad{addiag(x)} performs diagonal addition of a stream of streams. if \\spad{x} = \\spad{[[a<0,{} 0>,{} a<0,{} 1>,{} ..],{} [a<1,{} 0>,{} a<1,{} 1>,{} ..],{} [a<2,{} 0>,{} a<2,{} 1>,{} ..],{} ..]} and \\spad{addiag(x) = [b<0,{} b<1>,{} ...],{} then b<k> = sum(i+j=k,{} a<i,{} j>)}."))
 (|revert|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{revert(a)} computes the inverse of a power series \\spad{a} with respect to composition. the series should have constant coefficient 0 and invertible first order coefficient."))
 (|lagrange|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{lagrange(g)} produces the power series for \\spad{f} where \\spad{f} is implicitly defined as \\spad{f(z) = z*g(f(z))}."))
 (|compose|
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{compose(a,{} b)} composes the power series \\spad{a} with the power series \\spad{b}."))
 (|eval|
  (((|Stream| |#1|) (|Stream| |#1|) |#1|)
   "\\spad{eval(a,{} r)} returns a stream of partial sums of the power series \\spad{a} evaluated at the power series variable equal to \\spad{r}."))
 (|coerce|
  (((|Stream| |#1|) |#1|)
   "\\spad{coerce(r)} converts a ring element \\spad{r} to a stream with one element."))
 (|gderiv|
  (((|Stream| |#1|) (|Mapping| |#1| (|Integer|)) (|Stream| |#1|))
   "\\spad{gderiv(f,{} [a0,{} a1,{} a2,{} ..])} returns \\spad{[f(0)*a0,{} f(1)*a1,{} f(2)*a2,{} ..]}."))
 (|deriv|
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{deriv(a)} returns the derivative of the power series with respect to the power series variable. Thus \\spad{deriv([a0,{} a1,{} a2,{} ...])} returns \\spad{[a1,{} 2 a2,{} 3 a3,{} ...]}."))
 (|mapmult|
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{mapmult([a0,{} a1,{} ..],{} [b0,{} b1,{} ..])} returns \\spad{[a0*b0,{} a1*b1,{} ..]}."))
 (|int|
  (((|Stream| |#1|) |#1|)
   "\\spad{int(r)} returns [\\spad{r},{} \\spad{r+1},{} \\spad{r+2},{} ...],{} where \\spad{r} is a ring element."))
 (|oddintegers|
  (((|Stream| (|Integer|)) (|Integer|))
   "\\spad{oddintegers(n)} returns \\spad{[n,{} n+2,{} n+4,{} ...]}."))
 (|integers|
  (((|Stream| (|Integer|)) (|Integer|))
   "\\spad{integers(n)} returns \\spad{[n,{} n+1,{} n+2,{} ...]}."))
 (|monom|
  (((|Stream| |#1|) |#1| (|Integer|))
   "\\spad{monom(deg,{} coef)} is a monomial of degree \\spad{deg} with coefficient coef."))
 (|recip|
  (((|Union| (|Stream| |#1|) "failed") (|Stream| |#1|))
   "\\spad{recip(a)} returns the power series reciprocal of \\spad{a},{} or \"failed\" if not possible."))
 (/
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{a / b} returns the power series quotient of \\spad{a} by \\spad{b}. An error message is returned if \\spad{b} is not invertible. This function is used in fixed point computations."))
 (|exquo|
  (((|Union| (|Stream| |#1|) "failed") (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{exquo(a,{} b)} returns the power series quotient of \\spad{a} by \\spad{b},{} if the quotient exists,{} and \"failed\" otherwise"))
 (*
  (((|Stream| |#1|) (|Stream| |#1|) |#1|)
   "\\spad{a * r} returns the power series scalar multiplication of \\spad{a} by \\spad{r:} \\spad{[a0,{} a1,{} ...] * r = [a0 * r,{} a1 * r,{} ...]}")
  (((|Stream| |#1|) |#1| (|Stream| |#1|))
   "\\spad{r * a} returns the power series scalar multiplication of \\spad{r} by \\spad{a}: \\spad{r * [a0,{} a1,{} ...] = [r * a0,{} r * a1,{} ...]}")
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{a * b} returns the power series (Cauchy) product of \\spad{a} and \\spad{b:} \\spad{[a0,{} a1,{} ...] * [b0,{} b1,{} ...] = [c0,{} c1,{} ...]} where \\spad{ck = sum(i + j = k,{} \\spad{ai} * bk)}."))
 (-
  (((|Stream| |#1|) (|Stream| |#1|))
   "\\spad{- a} returns the power series negative of \\spad{a}: \\spad{- [a0,{} a1,{} ...] = [- a0,{} - a1,{} ...]}")
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{a - b} returns the power series difference of \\spad{a} and \\spad{b}: \\spad{[a0,{} a1,{} ..] - [b0,{} b1,{} ..] = [a0 - b0,{} a1 - b1,{} ..]}"))
 (+
  (((|Stream| |#1|) (|Stream| |#1|) (|Stream| |#1|))
   "\\spad{a + b} returns the power series sum of \\spad{a} and \\spad{b}: \\spad{[a0,{} a1,{} ..] + [b0,{} b1,{} ..] = [a0 + b0,{} a1 + b1,{} ..]}")))
(("documentation" 0 15162) ("ancestors" 0 NIL) ("parents" 0 NIL)
 ("abbreviation" 0 15153) ("predicates" 0 15047) ("superDomain" 0 NIL)
 ("operationAlist" 0 12402) ("modemaps" 0 5796) ("sourceFile" 0 5756)
 ("constructorCategory" 0 3009) ("constructorModemap" 0 65)
 ("constructorKind" 0 55) ("constructorForm" 0 20))