)abbrev domain IBITS IndexedBits
++ Author: Stephen Watt and Michael Monagan
++ Date Created: July 86
++ Basic Operations: range
++ Related Constructors:
++ Keywords: indexed bits
++ Description: \spadtype{IndexedBits} is a domain to compactly represent
++ large quantities of Boolean data.

IndexedBits(mn : Integer) : BitAggregate() with
        -- temporaries until parser gets better
        Not : % -> %
            ++ Not(n) returns the bit-by-bit logical {\em Not} of n.
        Or : (%, %) -> %
            ++ Or(n, m)  returns the bit-by-bit logical {\em Or} of
            ++ n and m.
        And : (%, %) -> %
            ++ And(n, m)  returns the bit-by-bit logical {\em And} of
            ++ n and m.
    == add

        range : (%, Integer) -> Integer
          --++ range(j, i) returns the range i of the boolean j.

        minIndex u  == mn

        range(v, i) ==
          i >= 0 and i < #v => i
          error "Index out of range"

        coerce(v) : OutputForm ==
            t:Character := char "1"
            f:Character := char "0"
            s := new(#v, space()$Character)$String
            for i in minIndex(s)..maxIndex(s) for j in mn.. repeat
              s.i := if v.j then t else f
            s::OutputForm

        new(n, b)    == make_BVEC(n, bool_to_bit(b)$Lisp)$Lisp
        empty()      == make_BVEC(0, 0)$Lisp
        copy v       == copy_BVEC(v)$Lisp
        #v           == size_BVEC(v)$Lisp
        v = u        == equal_BVEC(v, u)$Lisp
        v < u        == greater_BVEC(u, v)$Lisp
        _and(u, v)   == (#v = #u => and_BVEC(v, u)$Lisp; map("and", v, u))
        _or(u, v)    == (#v = #u => or_BVEC(v, u)$Lisp; map("or", v, u))
        xor(v, u)    == (#v = #u => xor_BVEC(v, u)$Lisp; map("xor", v, u))
        setelt!(v : %, i : Integer, f : Boolean) ==
            SETELT_BVEC(v, range(v, i - mn), bool_to_bit(f)$Lisp)$Lisp
        elt(v : %, i : Integer) ==
            bit_to_bool(ELT_BVEC(v, range(v, i - mn))$Lisp)$Lisp

        Not v        == not_BVEC(v)$Lisp
        And(u, v)    == (#v = #u => and_BVEC(v, u)$Lisp; map("and", v, u))
        Or(u, v)     == (#v = #u => or_BVEC(v, u)$Lisp; map("or", v, u))

