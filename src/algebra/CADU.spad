)abbrev package CADU CylindricalAlgebraicDecompositionUtilities

CylindricalAlgebraicDecompositionUtilities(R, P) : PUB == PRIV where

-- These are some standard tools which are needed to compute with univariate
-- polynomials.
--
-- A gcd basis for a set of polynomials S is a set of pairwise relatively
-- prime polynomials B such that
-- i) each polynomial p in S is a product of q^{\alpha_q} for q in B
--    where \alpha is a multiindex
-- ii) length of each multiindex \alpha in i) is minimal among all
--    B satisfying i)
--

  R : GcdDomain
  P : UnivariatePolynomialCategory(R)

  PUB == with
      squareFreeBasis : List(P) -> List(P)
        ++ squareFreeBasis(lp) computes gcd basis of square-free
        ++ parts of elements of lp
      gcdBasis : List(P) -> List(P)
        ++ gcdBasis(lp) computes gcd basis of lp

  PRIV == add

     gcdBasisAdd : (P, List(P)) -> List(P)
       -- add one polynomial to list of pairwise relatively prime polynomials

     squareFreeBasis(lpols) ==
         lpols = [] => []
         pol := first(lpols)
         sqpol := unitCanonical(squareFreePart(pol))
         gcdBasis(cons(sqpol, squareFreeBasis(rest(lpols))))

     gcdBasisAdd(p, lpols) ==
         (degree(p) = 0) => lpols
         empty?(lpols) => [unitCanonical p]
         p1 := first(lpols)
         g := gcd(p, p1)
         (degree(g) = 0) => cons(p1, gcdBasisAdd(p, rest lpols))
         p := (p exquo g)::P
         p1 := (p1 exquo g)::P
         basis := gcdBasisAdd(p, rest(lpols))
         if degree(p1) > 0 then basis := cons(p1, basis)
         gcdBasisAdd(g, basis)

     gcdBasis(lpols) ==
         (#lpols <= 1) => lpols
         basis := gcdBasis(rest lpols)
         gcdBasisAdd(first(lpols), basis)


