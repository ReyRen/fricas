)abbrev domain ICARD IndexCard
++ This domain implements a container of information
++ about the FriCAS library
IndexCard() : Exports == Implementation where
  Exports == OrderedSet with
    elt : (%, Symbol) -> String
      ++ elt(ic, s) selects a particular field from \spad{ic}.  Valid fields
      ++ are \spad{name, nargs, exposed, type, abbreviation, kind, origin,
      ++ params, condition, doc}.
    display : % -> Void
      ++ display(ic) prints a summary of the information contained in \spad{ic}.
    fullDisplay : % -> Void
      ++ fullDisplay(ic) prints all of the information contained in \spad{ic}.
    coerce : String -> %
      ++ coerce(s) converts \spad{s} into an \spad{IndexCard}.  Warning: if
      ++ \spad{s} is not of the right format then an error will occur when using
      ++ it.
  Implementation == add

    import from OutputForm

    x < y == (x pretend String) < (y pretend String)
    x = y == (x pretend String) = (y pretend String)

    db_name ==> dbName$Lisp

    db_part(x : %, n : Integer, k : Integer) : String ==
        dbPart(x, n, k)$Lisp

    alql_get_kind(x : %) : String ==
        xs := x pretend String
        xs(1) = char("a") or xs(1) = char("o") =>
            db_part(x, 5, 1)(1..1)
        xs(1..1)

    alql_get_origin(x : %) : String ==
        field := db_part(x, 5, 1)
        k := position(char("("), field, 3)
        k < 1 => field(2..)
        field(2..(k - 1))

    alql_get_params(x : %) : String ==
        field := db_part(x, 5, 1)
        k := position(char("("), field)
        k < 1 => ""
        field(k..)

    display(x) ==
        name : OutputForm := db_name(x)
        type : OutputForm := message(db_part(x, 4, 1))
        output(hconcat(name, hconcat(message(" : "), type)))$OutputPackage

    fullDisplay(x) ==
        name : OutputForm := db_name(x)
        type : OutputForm := message(db_part(x, 4, 1))
        origin : OutputForm := hconcat(message(alql_get_origin(x)),
                                       message(alql_get_params(x)))
        fromPart : OutputForm := hconcat(message(" from "), origin)
        condition : String := db_part(x, 6, 1)
        ifPart : OutputForm :=
            condition = "" => empty()
            hconcat(message(" if "), message(condition))
        exposed? : String := db_part(x, 3, 1)(1..1)
        exposedPart : OutputForm :=
            exposed? = "n" => message(" (unexposed)")
            empty()
        firstPart := hconcat(name, hconcat(message(" : "), type))
        secondPart := hconcat(fromPart, hconcat(ifPart, exposedPart))
        output(hconcat(firstPart, secondPart))$OutputPackage

    coerce(s : String) : % == (s pretend %)

    coerce(x) : OutputForm == (x pretend String)::OutputForm

    elt(x, s) ==
        s = 'name => db_name(x)
        s = 'nargs => db_part(x, 2, 1)
        s = 'exposed => db_part(x, 3, 1)(1..1)
        s = 'type => db_part(x, 4, 1)
        s = 'abbreviation => db_part(x, 5, 1)
        s = 'kind => alql_get_kind(x)
        s = 'origin => alql_get_origin(x)
        s = 'params => alql_get_params(x)
        s = 'condition => db_part(x, 6, 1)
        s = 'doc => dbComments(x)$Lisp
        error "unknown selector"

