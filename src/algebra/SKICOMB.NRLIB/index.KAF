7162                (|SKICombinators| UT)
|domain|
(((|SKICombinators| |#1|)
  (|Join| (|SetCategory|)
          (CATEGORY |domain| (SIGNATURE |ski| ($ $ $))
           (SIGNATURE |ski| ($ |#1|)) (SIGNATURE I ($)) (SIGNATURE K ($))
           (SIGNATURE S ($)) (SIGNATURE |parseSki| ($ (|String|)))
           (SIGNATURE |parseTerm|
            ((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|)))
             (|String|) (|NonNegativeInteger|)))
           (SIGNATURE |getChildren| ((|List| $) $))
           (SIGNATURE |atom?| ((|Boolean|) $))
           (SIGNATURE |variable?| ((|Boolean|) $))
           (SIGNATURE |isI?| ((|Boolean|) $))
           (SIGNATURE |isK?| ((|Boolean|) $))
           (SIGNATURE |isS?| ((|Boolean|) $))
           (SIGNATURE |getVariable| (|#1| $))
           (SIGNATURE |freeVariable?| ((|Boolean|) $ |#1|))
           (SIGNATURE |redux| ($ $)) (SIGNATURE = ((|Boolean|) $ $))
           (SIGNATURE |toString| ((|String|) $))))
  (|VarCat|))
 (T |SKICombinators|))
(|Join| (|SetCategory|)
        (CATEGORY |domain| (SIGNATURE |ski| ($ $ $)) (SIGNATURE |ski| ($ |#1|))
         (SIGNATURE I ($)) (SIGNATURE K ($)) (SIGNATURE S ($))
         (SIGNATURE |parseSki| ($ (|String|)))
         (SIGNATURE |parseTerm|
          ((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|)))
           (|String|) (|NonNegativeInteger|)))
         (SIGNATURE |getChildren| ((|List| $) $))
         (SIGNATURE |atom?| ((|Boolean|) $))
         (SIGNATURE |variable?| ((|Boolean|) $))
         (SIGNATURE |isI?| ((|Boolean|) $)) (SIGNATURE |isK?| ((|Boolean|) $))
         (SIGNATURE |isS?| ((|Boolean|) $)) (SIGNATURE |getVariable| (|#1| $))
         (SIGNATURE |freeVariable?| ((|Boolean|) $ |#1|))
         (SIGNATURE |redux| ($ $)) (SIGNATURE = ((|Boolean|) $ $))
         (SIGNATURE |toString| ((|String|) $))))
"/git/fricas/src/algebra/SKICOMB.spad"
((= (*1 *2 *1 *1)
    (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SKICombinators| *3))
         (|ofCategory| *3 (|VarCat|))))
 (|ski| (*1 *1 *1 *1)
  (AND (|isDomain| *1 (|SKICombinators| *2)) (|ofCategory| *2 (|VarCat|))))
 (|ski| (*1 *1 *2)
  (AND (|isDomain| *1 (|SKICombinators| *2)) (|ofCategory| *2 (|VarCat|))))
 (I (*1 *1)
  (AND (|isDomain| *1 (|SKICombinators| *2)) (|ofCategory| *2 (|VarCat|))))
 (K (*1 *1)
  (AND (|isDomain| *1 (|SKICombinators| *2)) (|ofCategory| *2 (|VarCat|))))
 (S (*1 *1)
  (AND (|isDomain| *1 (|SKICombinators| *2)) (|ofCategory| *2 (|VarCat|))))
 (|parseSki| (*1 *1 *2)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *1 (|SKICombinators| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|parseTerm| (*1 *2 *3 *4)
  (AND (|isDomain| *3 (|String|)) (|isDomain| *4 (|NonNegativeInteger|))
       (|isDomain| *2
                   (|Record| (|:| |rft| (|SKICombinators| *5))
                             (|:| |pout| (|NonNegativeInteger|))))
       (|isDomain| *1 (|SKICombinators| *5)) (|ofCategory| *5 (|VarCat|))))
 (|getChildren| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|SKICombinators| *3)))
       (|isDomain| *1 (|SKICombinators| *3)) (|ofCategory| *3 (|VarCat|))))
 (|atom?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SKICombinators| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|variable?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SKICombinators| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|isI?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SKICombinators| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|isK?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SKICombinators| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|isS?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SKICombinators| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|getVariable| (*1 *2 *1)
  (AND (|isDomain| *1 (|SKICombinators| *2)) (|ofCategory| *2 (|VarCat|))))
 (|freeVariable?| (*1 *2 *1 *3)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SKICombinators| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|redux| (*1 *1 *1)
  (AND (|isDomain| *1 (|SKICombinators| *2)) (|ofCategory| *2 (|VarCat|))))
 (|toString| (*1 *2 *1)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *1 (|SKICombinators| *3))
       (|ofCategory| *3 (|VarCat|)))))
((~= (((|Boolean|) $ $) 46)) (|variable?| (((|Boolean|) $) 35))
 (|toString| (((|String|) $) 43)) (|ski| (($ $ $) 8) (($ |#1|) 9))
 (|redux| (($ $) 52))
 (|parseTerm|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   20))
 (|parseSki| (($ (|String|)) 31)) (|latex| (((|String|) $) NIL))
 (|isS?| (((|Boolean|) $) 38)) (|isK?| (((|Boolean|) $) 37))
 (|isI?| (((|Boolean|) $) 36))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) NIL))
 (|hash| (((|SingleInteger|) $) NIL)) (|getVariable| ((|#1| $) 40))
 (|getChildren| (((|List| $) $) 34))
 (|freeVariable?| (((|Boolean|) $ |#1|) 42)) (|coerce| (((|OutputForm|) $) 49))
 (|atom?| (((|Boolean|) $) 32)) (S (($) 12)) (K (($) 11)) (I (($) 10))
 (= (((|Boolean|) $ $) 53)))
SKICOMB
(((|SetCategory|) . T))
(((|BasicType|) . T) ((|CoercibleTo| (|OutputForm|)) . T) ((|SetCategory|) . T))
((|constructor| (NIL "parse result includes term returned and new index"))
 (|toString| (((|String|) $) "output"))
 (=
  (((|Boolean|) $ $)
   "return \\spad{true} if equal (deep search) that is: all terms at all levels in tree must be equal to return \\spad{true} all terms must be exactly equal,{} not just equivalent,{} that is SKK=I will return \\spad{false} even though 'SKK' and 'I' have the same effect"))
 (|redux|
  (($ $)
   "weak reduction - apply this combinator to rearrange its subnodes then apply recursively to its subnodes."))
 (|freeVariable?|
  (((|Boolean|) $ |#1|)
   "the variable indicated by \\spad{'s'} is free if it does not appear in node \\spad{'n'} or any of its subnodes."))
 (|getVariable|
  ((|#1| $)
   "returns the variable,{} if this is not a variable then return \\spad{I}"))
 (|isS?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is a \\spad{S} combinator node"))
 (|isK?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is a \\spad{K} combinator node"))
 (|isI?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is an \\spad{I} combinator node"))
 (|variable?| (((|Boolean|) $) "returns \\spad{true} if this is an variable"))
 (|atom?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is an atom,{} that is a leaf node otherwise return \\spad{false} if this is a compound term"))
 (|getChildren|
  (((|List| $) $)
   "returns child nodes if this is a compound term otherwise returns []"))
 (|parseTerm|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   "parseTerm is used by parseSki. It would rarely be called externally but it is here to allow it to call parseSki that is to allow circular calls"))
 (|parseSki| (($ (|String|)) "Constructs combinators from a string"))
 (S (($) "Constructs a \\spad{S} combinator"))
 (K (($) "Constructs a \\spad{K} combinator"))
 (I (($) "Constructs a \\spad{I} combinator"))
 (|ski| (($ |#1|) "Constructs variable combinator")
  (($ $ $) "Constructs a node combinator over combinators")))
(("documentation" 0 5125) ("ancestors" 0 5044) ("parents" 0 5020)
 ("abbreviation" 0 5012) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 4236) ("modemaps" 0 1887) ("sourceFile" 0 1848)
 ("constructorCategory" 0 1007) ("constructorModemap" 0 51)
 ("constructorKind" 0 42) ("constructorForm" 0 20))