)abbrev domain ANY Any
++ Author: Robert S. Sutor
++ Basic Functions: any, domainOf, objectOf, dom, obj, showTypeInOutput
++ Related Constructors: AnyFunctions1
++ Also See: None
++ AMS Classification:
++ Keywords:
++ Description:
++   \spadtype{Any} implements a type that packages up objects and their
++   types in objects of \spadtype{Any}. Roughly speaking that means
++   that if \spad{s : S} then when converted to \spadtype{Any}, the new
++   object will include both the original object and its type. This is
++   a way of converting arbitrary objects into a single type without
++   losing any of the original information. Any object can be converted
++   to one of \spadtype{Any}.

Any() : SetCategory with
        any             : (SExpression, None) -> %
          ++ any(type, object) is a technical function for creating
          ++ an object of \spadtype{Any}. Argument \spad{type} is
          ++ a \spadgloss{LISP} form for the type of \spad{object}.
        domainOf        : % -> OutputForm
          ++ domainOf(a) returns a printable form of the type of the
          ++ original object that was converted to \spadtype{Any}.
        objectOf        : % -> OutputForm
          ++ objectOf(a) returns a printable form of the
          ++ original object that was converted to \spadtype{Any}.
        dom             : % -> SExpression
          ++ dom(a) returns a \spadgloss{LISP} form of the type of the
          ++ original object that was converted to \spadtype{Any}.
        obj             : % -> None
          ++ obj(a) essentially returns the original object that was
          ++ converted to \spadtype{Any} except that the type is forced
          ++ to be \spadtype{None}.
        showTypeInOutput : Boolean -> String
          ++ showTypeInOutput(bool) affects the way objects of
          ++ \spadtype{Any} are displayed. If \spad{bool} is true
          ++ then the type of the original object that was converted
          ++ to \spadtype{Any} will be printed. If \spad{bool} is
          ++ false, it will not be printed.

 == add
     Rep := Record(dm : SExpression, ob : None)

     printTypeInOutputP : Reference(Boolean) := ref false

     obj x      == x.ob
     dom x      == x.dm
     domainOf(x) == typeToOutputForm(x.dm)$Lisp
     x = y      ==
         dx := dom x
         dy := dom y
         dx ~= dy => false
         Dx : Type := evalType(dx)$Lisp
         Dx has BasicType =>
             (obj x) pretend Dx = (obj y) pretend Dx
         -- FIXME: we want
         -- error "Comparison in domain which is not a BasicType"
         -- but currently pattern matching needs
         EQ(obj x, obj y)$Lisp

     objectOf(x : %) : OutputForm ==
       spad2BootCoerce(x.ob, x.dm,
          list('OutputForm)$List(Symbol))$Lisp

     showTypeInOutput(b : Boolean) : String ==
      printTypeInOutputP := ref b
      b=> "Type of object will be displayed in output of a member of Any"
      "Type of object will not be displayed in output of a member of Any"

     coerce(x) : OutputForm ==
         obj1 : OutputForm := objectOf x
         not deref printTypeInOutputP => obj1
         dom1 :=
             p : SExpression := prefix2String(devaluate(x.dm)$Lisp)$Lisp
             atom?(p) => list(p pretend OutputForm)$List(OutputForm)
             p pretend List(OutputForm)
         hconcat cons(obj1, cons(message(":"), dom1))

     any(domain, object) ==
       (isValidType(domain)$Lisp)@Boolean => [domain, object]
       domain := devaluate(domain)$Lisp
       (isValidType(domain)$Lisp)@Boolean => [domain, object]
       error "function any must have a domain as first argument"

