10915               (|LinearAggregate&| A S)
|domain|
(((|LinearAggregate&| |#1| |#2|)
  (CATEGORY |domain|
   (SIGNATURE |hashUpdate!| ((|HashState|) (|HashState|) |#1|))
   (SIGNATURE |sort!| (|#1| |#1|))
   (SIGNATURE |sort!| (|#1| (|Mapping| (|Boolean|) |#2| |#2|) |#1|))
   (SIGNATURE |sorted?| ((|Boolean|) |#1|)) (SIGNATURE |sort| (|#1| |#1|))
   (SIGNATURE |merge| (|#1| |#1| |#1|)) (SIGNATURE |trim| (|#1| |#1| |#2|))
   (SIGNATURE |rightTrim| (|#1| |#1| |#2|))
   (SIGNATURE |leftTrim| (|#1| |#1| |#2|))
   (SIGNATURE |position| ((|Integer|) |#2| |#1| (|Integer|)))
   (SIGNATURE |position| ((|Integer|) |#2| |#1|))
   (SIGNATURE |position| ((|Integer|) (|Mapping| (|Boolean|) |#2|) |#1|))
   (SIGNATURE |sorted?| ((|Boolean|) (|Mapping| (|Boolean|) |#2| |#2|) |#1|))
   (SIGNATURE |sort| (|#1| (|Mapping| (|Boolean|) |#2| |#2|) |#1|))
   (SIGNATURE |reverse| (|#1| |#1|))
   (SIGNATURE |merge| (|#1| (|Mapping| (|Boolean|) |#2| |#2|) |#1| |#1|))
   (SIGNATURE |insert| (|#1| |#1| |#1| (|Integer|)))
   (SIGNATURE |insert| (|#1| |#2| |#1| (|Integer|)))
   (SIGNATURE |first| (|#1| |#1| (|NonNegativeInteger|)))
   (SIGNATURE |concat| (|#1| (|List| |#1|)))
   (SIGNATURE |concat| (|#1| |#1| |#1|)) (SIGNATURE |concat| (|#1| |#2| |#1|))
   (SIGNATURE |concat| (|#1| |#1| |#2|)) (SIGNATURE |first| (|#2| |#1|))
   (SIGNATURE |maxIndex| ((|Integer|) |#1|))
   (SIGNATURE |indices| ((|List| (|Integer|)) |#1|))
   (SIGNATURE |index?| ((|Boolean|) (|Integer|) |#1|)))
  (|LinearAggregate| |#2|) (|Type|))
 (T |LinearAggregate&|))
(CATEGORY |domain| (SIGNATURE |hashUpdate!| ((|HashState|) (|HashState|) |#1|))
 (SIGNATURE |sort!| (|#1| |#1|))
 (SIGNATURE |sort!| (|#1| (|Mapping| (|Boolean|) |#2| |#2|) |#1|))
 (SIGNATURE |sorted?| ((|Boolean|) |#1|)) (SIGNATURE |sort| (|#1| |#1|))
 (SIGNATURE |merge| (|#1| |#1| |#1|)) (SIGNATURE |trim| (|#1| |#1| |#2|))
 (SIGNATURE |rightTrim| (|#1| |#1| |#2|))
 (SIGNATURE |leftTrim| (|#1| |#1| |#2|))
 (SIGNATURE |position| ((|Integer|) |#2| |#1| (|Integer|)))
 (SIGNATURE |position| ((|Integer|) |#2| |#1|))
 (SIGNATURE |position| ((|Integer|) (|Mapping| (|Boolean|) |#2|) |#1|))
 (SIGNATURE |sorted?| ((|Boolean|) (|Mapping| (|Boolean|) |#2| |#2|) |#1|))
 (SIGNATURE |sort| (|#1| (|Mapping| (|Boolean|) |#2| |#2|) |#1|))
 (SIGNATURE |reverse| (|#1| |#1|))
 (SIGNATURE |merge| (|#1| (|Mapping| (|Boolean|) |#2| |#2|) |#1| |#1|))
 (SIGNATURE |insert| (|#1| |#1| |#1| (|Integer|)))
 (SIGNATURE |insert| (|#1| |#2| |#1| (|Integer|)))
 (SIGNATURE |first| (|#1| |#1| (|NonNegativeInteger|)))
 (SIGNATURE |concat| (|#1| (|List| |#1|)))
 (SIGNATURE |concat| (|#1| |#1| |#1|)) (SIGNATURE |concat| (|#1| |#2| |#1|))
 (SIGNATURE |concat| (|#1| |#1| |#2|)) (SIGNATURE |first| (|#2| |#1|))
 (SIGNATURE |maxIndex| ((|Integer|) |#1|))
 (SIGNATURE |indices| ((|List| (|Integer|)) |#1|))
 (SIGNATURE |index?| ((|Boolean|) (|Integer|) |#1|)))
"/git/fricas/src/algebra/LNAGG.spad"
((|trim| (($ $ |#2|) 36))
 (|sorted?| (((|Boolean|) (|Mapping| (|Boolean|) |#2| |#2|) $) NIL)
  (((|Boolean|) $) 44))
 (|sort!| (($ (|Mapping| (|Boolean|) |#2| |#2|) $) NIL) (($ $) 55))
 (|sort| (($ (|Mapping| (|Boolean|) |#2| |#2|) $) 54) (($ $) 49))
 (|rightTrim| (($ $ |#2|) 35)) (|reverse| (($ $) 52))
 (|position| (((|Integer|) (|Mapping| (|Boolean|) |#2|) $) NIL)
             (((|Integer|) |#2| $) 31) (((|Integer|) |#2| $ (|Integer|)) NIL))
 (|merge| (($ (|Mapping| (|Boolean|) |#2| |#2|) $ $) NIL) (($ $ $) 47))
 (|maxIndex| (((|Integer|) $) 29)) (|leftTrim| (($ $ |#2|) 34))
 (|insert| (($ |#2| $ (|Integer|)) 22) (($ $ $ (|Integer|)) NIL))
 (|indices| (((|List| (|Integer|)) $) 12))
 (|index?| (((|Boolean|) (|Integer|) $) 15))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) 40))
 (|first| ((|#2| $) NIL) (($ $ (|NonNegativeInteger|)) 27))
 (|concat| (($ $ |#2|) 19) (($ |#2| $) 20) (($ $ $) NIL) (($ (|List| $)) NIL)))
((|HasCategory| |#2| '(|OrderedSet|)) (|HasCategory| |#2| '(|Comparable|))
 (|HasCategory| |#2| '(|BasicType|)) (|HasCategory| |#1| '(|finiteAggregate|))
 (|HasCategory| |#1| '(|shallowlyMutable|)))
LNAGG-
((|constructor|
  (NIL
   "A linear aggregate is an aggregate whose elements are indexed by integers. Examples of linear aggregates are strings,{} lists,{} and arrays. Most of the exported operations for linear aggregates are non-destructive but are not always efficient for a particular aggregate. For example,{} \\spadfun{concat} of two lists needs only to copy its first argument,{} whereas \\spadfun{concat} of two arrays needs to copy both arguments. Most of the operations exported here apply to infinite objects (\\spadignore{e.g.} streams) as well to finite ones. If the aggregate is a finite aggregate then it has several additional exports such as \\spadfun{reverse},{} \\spadfun{sort},{} and so on."))
 (|sort!|
  (($ $)
   "\\spad{sort!(u)} returns \\spad{u} with its elements in ascending order.")
  (($ (|Mapping| (|Boolean|) |#2| |#2|) $)
   "\\spad{sort!(p,{} u)} returns \\spad{u} with its elements ordered by \\spad{p}."))
 (|reverse!|
  (($ $)
   "\\spad{reverse!(u)} returns \\spad{u} with its elements in reverse order."))
 (|copyInto!|
  (($ $ $ (|Integer|))
   "\\spad{copyInto!(u,{} v,{} i)} returns aggregate \\spad{u} containing a copy of \\spad{v} inserted at element \\spad{i}."))
 (|trim|
  (($ $ |#2|)
   "\\spad{trim(u,{} x)} returns a copy of \\spad{u} with all occurrences of \\spad{x} deleted from right and left ends. For example,{} \\spad{trim(\" abc \",{} char \" \")} returns \\spad{\"abc\"}."))
 (|rightTrim|
  (($ $ |#2|)
   "\\spad{rightTrim(u,{} x)} returns a copy of \\spad{u} with all trailing occurrences of \\spad{x} deleted. For example,{} \\spad{rightTrim(\" abc \",{} char \" \")} returns \\spad{\" abc\"}."))
 (|leftTrim|
  (($ $ |#2|)
   "\\spad{leftTrim(u,{} x)} returns a copy of \\spad{u} with all leading \\spad{x} deleted. For example,{} \\spad{leftTrim(\" abc \",{} char \" \")} returns \\spad{\"abc \"}."))
 (|position|
  (((|Integer|) |#2| $ (|Integer|))
   "\\spad{position(x,{} a,{} n)} returns the index \\spad{i} of the first occurrence of \\spad{x} in \\spad{a} where \\spad{i >= n},{} and \\spad{minIndex(a) - 1} if no such \\spad{x} is found.")
  (((|Integer|) |#2| $)
   "\\spad{position(x,{} a)} returns the index \\spad{i} of the first occurrence of \\spad{x} in a,{} and \\spad{minIndex(a) - 1} if there is no such \\spad{x}.")
  (((|Integer|) (|Mapping| (|Boolean|) |#2|) $)
   "\\spad{position(p,{} a)} returns the index \\spad{i} of the first \\spad{x} in \\spad{a} such that \\spad{p(x)} is \\spad{true},{} and \\spad{minIndex(a) - 1} if there is no such \\spad{x}."))
 (|sorted?|
  (((|Boolean|) $)
   "\\spad{sorted?(u)} tests if the elements of \\spad{u} are in ascending order.")
  (((|Boolean|) (|Mapping| (|Boolean|) |#2| |#2|) $)
   "\\spad{sorted?(p,{} a)} tests if \\spad{a} is sorted according to predicate \\spad{p}."))
 (|sort|
  (($ $)
   "\\spad{sort(u)} returns an \\spad{u} with elements in ascending order. Note: \\spad{sort(u) = sort(<=,{} u)}.")
  (($ (|Mapping| (|Boolean|) |#2| |#2|) $)
   "\\spad{sort(p,{} a)} returns a copy of \\spad{a} sorted using total ordering predicate \\spad{p}."))
 (|reverse|
  (($ $)
   "\\spad{reverse(a)} returns a copy of \\spad{a} with elements in reverse order."))
 (|merge|
  (($ $ $)
   "\\spad{merge(u,{} v)} merges \\spad{u} and \\spad{v} in ascending order. Note: \\spad{merge(u,{} v) = merge(<=,{} u,{} v)}.")
  (($ (|Mapping| (|Boolean|) |#2| |#2|) $ $)
   "\\spad{merge(p,{} a,{} b)} returns an aggregate \\spad{c} which merges \\spad{a} and \\spad{b}. The result is produced by examining each element \\spad{x} of \\spad{a} and \\spad{y} of \\spad{b} successively. If \\spad{p(x,{} y)} is \\spad{true},{} then \\spad{x} is inserted into the result; otherwise \\spad{y} is inserted. If \\spad{x} is chosen,{} the next element of \\spad{a} is examined,{} and so on. When all the elements of one aggregate are examined,{} the remaining elements of the other are appended. For example,{} \\spad{merge(<,{} [1,{} 3],{} [2,{} 7,{} 5])} returns \\spad{[1,{} 2,{} 3,{} 7,{} 5]}."))
 (|setelt!|
  ((|#2| $ (|UniversalSegment| (|Integer|)) |#2|)
   "\\spad{setelt!(u,{} i..j,{} x)} (also written: \\spad{u(i..j) := x}) destructively replaces each element in the segment \\spad{u(i..j)} by \\spad{x}. The value \\spad{x} is returned. Note: \\spad{u} is destructively changed so that \\spad{u.k := x for k in i..j}; its length remains unchanged."))
 (|insert|
  (($ $ $ (|Integer|))
   "\\spad{insert(v,{} u,{} i)} returns a copy of \\spad{u} having \\spad{v} inserted beginning at the \\spad{i}th element. Note: \\spad{insert(v,{} u,{} i) = concat(u(minIndex(u)..i-1),{} concat(v,{} u(i..)))}.")
  (($ |#2| $ (|Integer|))
   "\\spad{insert(x,{} u,{} i)} returns a copy of \\spad{u} having \\spad{x} as its \\spad{i}th element. Note: \\spad{insert(x,{} u,{} i) = concat(u(minIndex(u)..i-1),{} concat(x,{} u(i..)))}."))
 (|first|
  (($ $ (|NonNegativeInteger|))
   "\\spad{first(u,{} n)} returns a copy of the first \\spad{n} elements of \\spad{u}. Error: if \\spad{u} has less than \\spad{n} elements."))
 (|delete|
  (($ $ (|UniversalSegment| (|Integer|)))
   "\\spad{delete(u,{} i..j)} returns a copy of \\spad{u} with the \\spad{i}th through \\spad{j}th element deleted. Note: \\spad{delete(u,{} i..j) = concat(u(minIndex(u)..i-1),{} u(j+1..))}.")
  (($ $ (|Integer|))
   "\\spad{delete(u,{} i)} returns a copy of \\spad{u} with the \\spad{i}th element deleted. Note: \\spad{delete(u,{} i) = concat(u(minIndex(u)..i - 1),{} u(i + 1..))}."))
 (|map|
  (($ (|Mapping| |#2| |#2| |#2|) $ $)
   "\\spad{map(f,{} u,{} v)} returns a new aggregate \\spad{w} with elements \\spad{z = f(x,{} y)} for corresponding elements \\spad{x} and \\spad{y} from \\spad{u} and \\spad{v}. Note: \\spad{w.i = f(u.i,{} v.i)}."))
 (|concat|
  (($ (|List| $))
   "\\spad{concat(u)},{} where \\spad{u} is a list of aggregates \\spad{[a,{} b,{} ...,{} c]},{} returns a single aggregate consisting of the elements of \\spad{a} followed by those of \\spad{b} followed ... by the elements of \\spad{c}. Note: \\spad{concat([a,{} b,{} ...,{} c]) = concat(a,{} concat([b,{} ...,{} c]))}.")
  (($ $ $)
   "\\spad{concat(u,{} v)} returns an aggregate consisting of the elements of \\spad{u} followed by the elements of \\spad{v}. Note: if \\spad{w = concat(u,{} v)} then \\spad{w.i = u.i for i in indices u} and \\spad{w.(j + maxIndex u) = v.j for j in indices v}.")
  (($ |#2| $)
   "\\spad{concat(x,{} u)} returns aggregate \\spad{u} with additional element \\spad{x} at the front. Note: for lists: \\spad{concat(x,{} u) = concat([x],{} u)}.")
  (($ $ |#2|)
   "\\spad{concat(u,{} x)} returns aggregate \\spad{u} with additional element \\spad{x} at the end. Note: for lists,{} \\spad{concat(u,{} x) = concat(u,{} [x])}."))
 (|new|
  (($ (|NonNegativeInteger|) |#2|)
   "\\spad{new(n,{} x)} returns a new aggregate of size \\spad{n} all of whose entries are \\spad{x}.")))
(("documentation" 0 4046) ("ancestors" 0 NIL) ("parents" 0 NIL)
 ("abbreviation" 0 4039) ("predicates" 0 3840) ("superDomain" 0 NIL)
 ("operationAlist" 0 2907) ("modemaps" 0 NIL) ("sourceFile" 0 2870)
 ("constructorCategory" 0 1534) ("constructorModemap" 0 54)
 ("constructorKind" 0 45) ("constructorForm" 0 20))