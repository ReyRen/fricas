)abbrev package GUESSEB GuessExpBin
)boot $tryRecompileArguments := nil
++ Author: Martin Rubey
++ Description: This package implements guessing GuessExpRat and
++ GuessBinRat functions of guessing package.
GuessExpBin(F, S, EXPRR, retract, coerce) : Exports == Implementation where
  -- for example : FRAC POLY PF 5
  F : Join(Field, PolynomialFactorizationExplicit)
  -- in F we interpolate and check

  S : GcdDomain

-- in guessExpRat I would like to determine the roots of polynomials in F. When
-- F is a quotient field, I can get rid of the denominator.  In this case F is
-- roughly QFCAT S

  -- results are given as elements of EXPRR
  EXPRR : Join(FunctionSpace Integer, IntegralDomain,
                RetractableTo Symbol,
                RetractableTo Integer, CombinatorialOpsCategory,
                PartialDifferentialRing Symbol) with
              _* : (%, %) -> %
              _/ : (%, %) -> %
              _^ : (%, %) -> %
              numerator : % -> %
              denominator : % -> %
              ground? : % -> Boolean

  -- EXPRR exists, in case at some point there is support for EXPR PF 5.

  -- the following I really would like to get rid of

  retract : EXPRR -> F                      -- eg.: i+->i
  coerce : F -> EXPRR                       -- eg.: i+->i

  LGOPT ==> List GuessOption
  GOPT0 ==> GuessOptionFunctions0

  NNI ==> NonNegativeInteger
  PI ==> PositiveInteger
  GUESSRESULT ==> List EXPRR

  SUP ==> SparseUnivariatePolynomial

  FFFG ==> FractionFreeFastGaussian

  DIFFSPECN ==> EXPRR -> EXPRR             -- eg.: i+->q^i

  GUESSER ==> (List F, LGOPT) -> GUESSRESULT

  FSUPF ==> Fraction SUP F

  V ==> OrderedVariableList(['a1, 'A])
  POLYF ==> SparseMultivariatePolynomial(F, V)
  FPOLYF ==> Fraction POLYF
  FSUPFPOLYF ==> Fraction SUP FPOLYF
  POLYS ==> SparseMultivariatePolynomial(S, V)
  FPOLYS ==> Fraction POLYS
  FSUPFPOLYS ==> Fraction SUP FPOLYS

  Exports == with

    guessExpRat : (List F, LGOPT) -> GUESSRESULT
      ++ \spad{guessExpRat(l, options)} tries to find a function of the
      ++ form n+->(a+b n)^n r(n), where r(n) is a rational function, that
      ++ fits l.

    guessBinRat : (List F, LGOPT) -> GUESSRESULT
      ++ \spad{guessBinRat(l, options)} tries to find a function of the
      ++ form n+->binomial(a+b n, n) r(n), where r(n) is a rational
      ++ function, that fits l.

    if F has RetractableTo Symbol and S has RetractableTo Symbol then

        guessExpRat : Symbol -> GUESSER
          ++ \spad{guessExpRat q} returns a guesser that tries to find a
          ++ function of the form n+->(a+b q^n)^n r(q^n), where r(q^n) is a
          ++ q-rational function, that fits l.

        guessBinRat : Symbol -> GUESSER
          ++ \spad{guessBinRat q} returns a guesser that tries to find a
          ++ function of the form n+->qbinomial(a+b n, n) r(n), where r(q^n)
          ++ is a q-rational function, that fits l.

  Implementation == add

    -- The following expressions for order and degree of the resultants
    -- [[res1]] and [[res2]] in [[guessExpRatAux]] were first guessed,
    -- partially with the aid of [[guessRat]], and then proven to be correct.

    ord1(x : List Integer, i : Integer) : Integer ==
        n := #x - 3 - i
        x.(n+1)*reduce(_+, [x.j for j in 1..n], 0) + _
            2*reduce(_+, [reduce(_+, [x.k*x.j for k in 1..j-1], 0) _
                          for j in 1..n], 0)

    ord2(x : List Integer, i : Integer) : Integer ==
        if zero? i then
            n := #x - 3 - i
            ord1(x, i) + reduce(_+, [x.j for j in 1..n], 0)*(x.(n+2)-x.(n+1))
        else
            ord1(x, i)

    deg1(x : List Integer, i : Integer) : Integer ==
        m := #x - 3
        (x.(m+3)+x.(m+1)+x.(1+i))*reduce(_+, [x.j for j in 2+i..m], 0) + _
            x.(m+3)*x.(m+1) + _
            2*reduce(_+, [reduce(_+, [x.k*x.j for k in 2+i..j-1], 0) _
                          for j in 2+i..m], 0)

    deg2(x : List Integer, i : Integer) : Integer ==
        m := #x - 3
        deg1(x, i) + _
            (x.(m+3) + reduce(_+, [x.j for j in 2+i..m], 0)) * _
            (x.(m+2)-x.(m+1))

    checkResult(res : EXPRR, n : Symbol, l : Integer, list : List F) : NNI ==
        for i in l..1 by -1 repeat
            den := eval(denominator res, n::EXPRR, (i-1)::EXPRR)
            if den = 0 then return i::NNI
            num := eval(numerator res, n::EXPRR, (i-1)::EXPRR)
            if list.i ~= retract(num/den)@F
            then return i::NNI
        0$NNI

    SUPS2SUPF(p : SUP S) : SUP F ==
      if F is S then
        p pretend SUP(F)
      else if F is Fraction S then
        map((z1 : S) : F +-> coerce(z1)$Fraction(S), p)
          $SparseUnivariatePolynomialFunctions2(S, F)
      else error "Guess: type parameter F should be either equal to S or"
                 " equal to Fraction S"

    -- convertion routines

    F2FPOLYS(p : F) : FPOLYS ==
      if F is S then
        p::POLYF::FPOLYF pretend FPOLYS
      else if F is Fraction S then
        numer(p)$Fraction(S)::POLYS/denom(p)$Fraction(S)::POLYS
      else error "Guess: type parameter F should be either equal to S or"
                 " equal to Fraction S"

    MPCSF ==> MPolyCatFunctions2(V, IndexedExponents V,
                                    IndexedExponents V, S, F,
                                    POLYS, POLYF)

    SUPF2EXPRR(xx : Symbol, p : SUP F) : EXPRR ==
      zero? p => 0
      (coerce(leadingCoefficient p))::EXPRR * (xx::EXPRR)^degree p
         + SUPF2EXPRR(xx, reductum p)

    FSUPF2EXPRR(xx : Symbol, p : FSUPF) : EXPRR ==
      (SUPF2EXPRR(xx, numer p)) / (SUPF2EXPRR(xx, denom p))


    POLYS2POLYF(p : POLYS) : POLYF ==
      if F is S then
        p pretend POLYF
      else if F is Fraction S then
        map((z1 : S) : F +-> coerce(z1)$Fraction(S), p)$MPCSF
      else error "Guess: type parameter F should be either equal to S or"
                 " equal to Fraction S"

    SUPPOLYS2SUPF(p : SUP POLYS, a1v : F, Av : F) : SUP F ==
      zero? p => 0
      lc : POLYF := POLYS2POLYF leadingCoefficient(p)
      monomial(retract(eval(lc, [index(1)$V, index(2)$V]::List V,
                                [a1v, Av])),
               degree p)
        + SUPPOLYS2SUPF(reductum p, a1v, Av)


    SUPFPOLYS2FSUPPOLYS(p : SUP FPOLYS) : Fraction SUP POLYS  ==
      cden := splitDenominator(p)
             $UnivariatePolynomialCommonDenominator(POLYS, FPOLYS, SUP FPOLYS)

      pnum : SUP POLYS
           := map((z1 : FPOLYS) : POLYS +-> retract(z1 * cden.den)$FPOLYS, p)
                 $SparseUnivariatePolynomialFunctions2(FPOLYS, POLYS)
      pden : SUP POLYS := (cden.den)::SUP POLYS

      pnum/pden


    -- this needs documentation. In particular, why is V appearing here?
    GF ==> GeneralizedMultivariateFactorize(SingletonAsOrderedSet,
                                            NonNegativeInteger, F, F,
                                            SUP F)

    -- mimicking $q$-analoga

    defaultD : DIFFSPECN
    defaultD(expr : EXPRR) : EXPRR == expr

    -- applies n+->q^n or whatever DN is to i
    DN2DL : (DIFFSPECN, Integer) -> F
    DN2DL(DN, i) == retract(DN(i::EXPRR))@F

    evalResultant(p1 : POLYS, p2 : POLYS, o : Integer, d : Integer,
                  va1 : V, vA : V) : List S ==
        res : List S := []
        d1 := degree(p1, va1)
        d2 := degree(p2, va1)
        lead : S
        -- Since we also have an lower bound for the order of the resultant,
        -- we need to evaluate it only at $d-o+1$ points. Furthermore,
        -- we can divide by $k^o$ and still obtain a polynomial.
        for k in 1..d-o+1 repeat
            p1atk := univariate eval(p1, vA, k::S)
            p2atk := univariate eval(p2, vA, k::S)

        -- It may happen, that the leading coefficients of one or both of
        -- the polynomials changes, when we evaluate it at $k$. In this
        -- case, we need to correct this by multiplying with the
        -- corresponding power of the leading coefficient of the other
        -- polynomial.

        -- Consider the Sylvester matrix of the original polynomials. We
        -- want to evaluate it at $A = k$. If the first few leading
        -- coefficients of $p2$ vanish, the first few columns of the
        -- Sylvester matrix have triangular shape, with the leading
        -- coefficient of $p1$ on the diagonal. The same thing happens, if
        -- we exchange the roles of $p1$ and $p2$, only that we have to
        -- take care of the sign, too.

            d1atk := degree p1atk
            d2atk := degree p2atk

    --      output("k: " string(k))$OutputPackage
    --      output("d1: " string(d1) " d1atk: " string(d1atk))$OutputPackage
    --      output("d2: " string(d2) " d2atk: " string(d2atk))$OutputPackage


            if d2atk < d2 then
                if  d1atk < d1
                then lead := 0$S
                else lead := (leadingCoefficient p1atk)^((d2-d2atk)::NNI)
            else
                if  d1atk < d1
                then lead := (-1$S)^d2 *
                       (leadingCoefficient p2atk)^((d1-d1atk)::NNI)
                else lead := 1$S

            if zero? lead
            then res := cons(0, res)
            else res := cons(lead * (resultant(p1atk, p2atk)$SUP(S) exquo
                                    (k::S)^(o::NNI))::S,
                             res)
        reverse res

    -- The degree of [[poly3]] is governed by $(a_0+x_m a_1)^{x_m}$.
    -- Therefore, we substitute $A-x_m a1$ for $a_0$, which reduces
    -- the degree in $a_1$ by $x_m-x_{i+1}$.

    p_subst(xm : Integer, i : Integer, va1 : V, vA : V, basis : DIFFSPECN
           ) : FPOLYS ==
        vA::POLYS::FPOLYS + va1::POLYS::FPOLYS _
                           * F2FPOLYS(DN2DL(basis, i) - DN2DL(basis, xm))

    p2_subst(xm : Integer, i : Symbol, a1v : F, Av : F, basis : DIFFSPECN
            ) : EXPRR ==
        coerce(Av) + coerce(a1v)*(basis(i::EXPRR) - basis(xm::EXPRR))

    guessExpRatAux(xx : Symbol, list : List F, basis : DIFFSPECN,
                   xValues : List Integer, options : LGOPT) : List EXPRR ==
        import from Factored(SUP F)

        a1 : V := index(1)$V
        A : V := index(2)$V

        len : NNI := #list
        if len < 4 then return []
                   else len := (len-3)::NNI

        xlist := [F2FPOLYS DN2DL(basis, xValues.i) for i in 1..len]
        x1 := F2FPOLYS DN2DL(basis, xValues.(len+1))
        x2 := F2FPOLYS DN2DL(basis, xValues.(len+2))
        x3 := F2FPOLYS DN2DL(basis, xValues.(len+3))

        -- We try to fit the data $(s1, s2, \dots)$ to the model
        -- $(a+b n)^n y(n)$, $r$ being a rational function. To obtain
        -- $y$, we compute $y(n)=s_n*(a+b n)^{-n}$.

        y : NNI -> FPOLYS :=
            (z1 : NNI) : FPOLYS +-> F2FPOLYS(list.z1) * _
            p_subst(last xValues, (xValues.z1)::Integer, a1, A, basis)^_
                (-(xValues.z1)::Integer)

        ylist : List FPOLYS := [y i for i in 1..len]

        y1 := y(len+1)
        y2 := y(len+2)
        y3 := y(len+3)

        res := []::List EXPRR
        if (maxD := maxDegree(options)$GOPT0) case NNI
        then maxDeg := min(maxD, len-1)
        else maxDeg := len-1

        for i in 0..maxDeg repeat
            if debug(options)$GOPT0 then
                output("Guess: degree ExpRat ", i::OutputForm)$OutputPackage

            if debug(options)$GOPT0 then
                output("Guess: interpolating...")$OutputPackage

            ri : FSUPFPOLYS
               := interpolate(xlist, ylist, (len-1-i)::NNI) _
                             $FFFG(FPOLYS, SUP FPOLYS)

    -- for experimental fraction free interpolation
    --        ri: Fraction SUP POLYS
    --           := interpolate(xlist, ylist, (len-1-i)::NNI) _
    --                         $FFFG(POLYS, SUP POLYS)

            if debug(options)$GOPT0 then
    --            output(hconcat("xlist: ", xlist::OutputForm))$OutputPackage
    --            output(hconcat("ylist: ", ylist::OutputForm))$OutputPackage
    --            output(hconcat("ri: ", ri::OutputForm))$OutputPackage
                output("Guess: polynomials...")$OutputPackage

            poly1 : POLYS := numer(elt(ri, x1)$SUP(FPOLYS) - y1)
            poly2 : POLYS := numer(elt(ri, x2)$SUP(FPOLYS) - y2)
            poly3 : POLYS := numer(elt(ri, x3)$SUP(FPOLYS) - y3)

    -- for experimental fraction free interpolation
    --        ri2: FSUPFPOLYS := map(#1::FPOLYS, numer ri)                 _
    --                $SparseUnivariatePolynomialFunctions2(POLYS, FPOLYS) _
    --                         /map(#1::FPOLYS, denom ri)                  _
    --                $SparseUnivariatePolynomialFunctions2(POLYS, FPOLYS)
    --
    --        poly1: POLYS := numer(elt(ri2, x1)$SUP(FPOLYS) - y1)
    --        poly2: POLYS := numer(elt(ri2, x2)$SUP(FPOLYS) - y2)
    --        poly3: POLYS := numer(elt(ri2, x3)$SUP(FPOLYS) - y3)

            n : Integer := len - i
            o1 : Integer := ord1(xValues, i)
            d1 : Integer := deg1(xValues, i)
            o2 : Integer := ord2(xValues, i)
            d2 : Integer := deg2(xValues, i)

    -- another compiler bug: using i as iterator here makes the loop break

            if debug(options)$GOPT0 then
                output("Guess: interpolating resultants...")$OutputPackage

            res1 : SUP S
                 := newton(evalResultant(poly1, poly3, o1, d1, a1, A))
                          $NewtonInterpolation(S)

            res2 : SUP S
                 := newton(evalResultant(poly2, poly3, o2, d2, a1, A))
                          $NewtonInterpolation(S)

    --        if debug(options)$GOPT0 then
    --            res1: SUP S := univariate(resultant(poly1, poly3, a1))
    --            res2: SUP S := univariate(resultant(poly2, poly3, a1))
    --            if res1 ~= res1res or res2 ~= res2res then
    --            output(hconcat("poly1 ", poly1::OutputForm))$OutputPackage
    --                output(hconcat("poly2 ", poly2::OutputForm))$OutputPackage
    --            output(hconcat("poly3 ", poly3::OutputForm))$OutputPackage
    --                output(hconcat("res1 ", res1::OutputForm))$OutputPackage
    --                output(hconcat("res2 ", res2::OutputForm))$OutputPackage
    --            output("n/i: " string(n) " " string(i))$OutputPackage
    --            output("res1 ord: " string(o1) " " string(minimumDegree res1))
    --                  $OutputPackage
    --            output("res1 deg: " string(d1) " " string(degree res1))
    --                  $OutputPackage
    --            output("res2 ord: " string(o2) " " string(minimumDegree res2))
    --                  $OutputPackage
    --            output("res2 deg: " string(d2) " " string(degree res2))
    --                  $OutputPackage

            if debug(options)$GOPT0 then
                output("Guess: computing gcd...")$OutputPackage

    -- we want to solve over F
    -- for polynomial domains S this seems to be very costly!
            res3 : SUP F := SUPS2SUPF(primitivePart(gcd(res1, res2)))

            if debug(options)$GOPT0 then
                output("Guess: solving...")$OutputPackage

    -- res3 is a polynomial in A=a0+(len+3)*a1
    -- now we have to find the roots of res3

            for f in factorList factor(res3)$GF | degree f.factor = 1 repeat
    -- we are only interested in the linear factors
    --             if debug(options)$GOPT0 then
    --                 output(hconcat("f: ", f::OutputForm))$OutputPackage

                Av : F := -coefficient(f.factor, 0)
                         / leadingCoefficient f.factor

    -- FIXME: in an earlier version, we disregarded vanishing Av
    --    maybe we intended to disregard vanishing a1v? Either doesn't really
    --    make sense to me right now.

                evalPoly := eval(POLYS2POLYF poly3, A, Av)
                if zero? evalPoly
                then evalPoly := eval(POLYS2POLYF poly1, A, Av)
    -- Note that it really may happen that poly3 vanishes when specializing
    -- A. Consider for example guessExpRat([1, 1, 1, 1]).

    -- FIXME: We check poly1 below, too. I should work out in what cases poly3
    -- vanishes.

                for g in factorList factor(univariate evalPoly)$GF
                          | degree g.factor = 1 repeat
    --                 if debug(options)$GOPT0 then
    --                     output("g: ", g::OutputForm)$OutputPackage

                    a1v : F := -coefficient(g.factor, 0)
                              / leadingCoefficient g.factor

    -- check whether poly1 and poly2 really vanish. Note that we could have
    -- found an extraneous solution, since we only computed the gcd of the
    -- two resultants.

                    t1 := eval(POLYS2POLYF poly1, [a1, A]::List V,
                                                   [a1v, Av]::List F)
                    not(zero? t1) => "iterate"
                    t2 := eval(POLYS2POLYF poly2, [a1, A]::List V,
                                                   [a1v, Av]::List F)
                    if zero? t2 then

                        ri1 : Fraction SUP POLYS
                          := SUPFPOLYS2FSUPPOLYS(numer ri)
                            / SUPFPOLYS2FSUPPOLYS(denom ri)

    -- for experimental fraction free interpolation
    --                         ri1: Fraction SUP POLYS := ri

                        numr : SUP F := SUPPOLYS2SUPF(numer ri1, a1v, Av)
                        denr : SUP F := SUPPOLYS2SUPF(denom ri1, a1v, Av)

                        if not zero? denr then
                            res4 : EXPRR := eval(FSUPF2EXPRR(xx, numr/denr),
                                                 kernel(xx), basis(xx::EXPRR))
                                       *p2_subst(last xValues, xx, a1v,
                                                  Av, basis)^xx::EXPRR
                            res := cons(res4, res)
                        else if zero? numr and debug(options)$GOPT0 then
                            output("Guess: numerator and denominator vanish!"
                                  )$OutputPackage

    -- If we are only interested in one solution, we do not try other
    -- degrees if we have found already some solutions. I.e., the
    -- indentation here is correct.

            if not(empty?(res)) and one(options)$GOPT0 then return res

        res

    guessExpRatAux0(list : List F, basis : DIFFSPECN, options : LGOPT
                   ) : GUESSRESULT ==
        if zero? safety(options)$GOPT0 then
            error "Guess: guessExpRat does not support zero safety"
    -- guesses Functions of the Form (a1*n+a0)^n*rat(n)
        xx := indexName(options)$GOPT0

    -- restrict to safety

        len : Integer := #list
        if len-safety(options)$GOPT0+1 < 0 then return []

        shortlist : List F := first(list, (len-safety(options)$GOPT0+1)::NNI)

    -- remove zeros from list

        zeros : EXPRR := 1
        newlist : List F
        xValues : List Integer

        i : Integer := -1
        for x in shortlist repeat
            i := i+1
            if x = 0 then
                zeros := zeros * (basis(xx::EXPRR) - basis(i::EXPRR))

        i := -1
        for x in shortlist repeat
            i := i+1
            if x ~= 0 then
                newlist := cons(x/retract(eval(zeros, xx::EXPRR, i::EXPRR))@F,
                                newlist)
                xValues := cons(i, xValues)

        newlist := reverse newlist
        xValues := reverse xValues

        res : List EXPRR
            := [eval(zeros * f, xx::EXPRR, xx::EXPRR) _
                for f in guessExpRatAux(xx, newlist, basis, xValues, options)]

        select(z1 +-> checkResult(z1, xx, len, list) <
                         len-safety(options)$GOPT0, res)

    guessExpRat(list : List F, options : LGOPT) : GUESSRESULT ==
        guessExpRatAux0(list, defaultD, options)

    if F has RetractableTo Symbol and S has RetractableTo Symbol then

        guessExpRat(q : Symbol) : GUESSER ==
            (z1 : List F, z2 : LGOPT) : GUESSRESULT +->
                guessExpRatAux0(z1, (i1 : EXPRR) : EXPRR +-> q::EXPRR^i1, z2)


    EXT ==> (Integer, V, V) -> FPOLYS
    EXTEXPR ==> (Symbol, F, F) -> EXPRR

    binExt : EXT
    binExt(i : Integer, va1 : V, vA : V) : FPOLYS ==
        numl : List POLYS := [(vA::POLYS) + i * (va1::POLYS) - (l::POLYS) _
                             for l in 0..i-1]
        num : POLYS := reduce(_*, numl, 1)

        num/(factorial(i)::POLYS)

    binExtEXPR : EXTEXPR
    binExtEXPR(i : Symbol, a1v : F, Av : F) : EXPRR ==
        binomial(coerce Av + coerce a1v * (i::EXPRR), i::EXPRR)


    guessBinRatAux(xx : Symbol, list : List F,
                   basis : DIFFSPECN, ext : EXT, extEXPR : EXTEXPR,
                   xValues : List Integer, options : LGOPT) : List EXPRR ==
        import from Factored(SUP F)

        a1 : V := index(1)$V
        A : V := index(2)$V

        len : NNI := #list
        if len < 4 then return []
                   else len := (len-3)::NNI

        xlist := [F2FPOLYS DN2DL(basis, xValues.i) for i in 1..len]
        x1 := F2FPOLYS DN2DL(basis, xValues.(len+1))
        x2 := F2FPOLYS DN2DL(basis, xValues.(len+2))
        x3 := F2FPOLYS DN2DL(basis, xValues.(len+3))

        -- We try to fit the data $(s1, s2, \dots)$ to the model
        -- $\binom{a+b n}{n} y(n)$, $r$ being a rational function.
        -- To obtain $y$, we compute $y(n)=s_n*\binom{a+bn}{n}^-1$.

        y : NNI -> FPOLYS :=
            (z1 : NNI) : FPOLYS +-> F2FPOLYS(list.z1) / _
            ext((xValues.z1)::Integer, a1, A)

        ylist : List FPOLYS := [y i for i in 1..len]

        y1 := y(len+1)
        y2 := y(len+2)
        y3 := y(len+3)

        res := []::List EXPRR
        if (maxD := maxDegree(options)$GOPT0) case NNI
        then maxDeg := min(maxD, len-1)
        else maxDeg := len-1

        for i in 0..maxDeg repeat
    --        if debug(options)$GOPT0 then
    --            output(hconcat("degree BinRat "::OutputForm, i::OutputForm))
    --                $OutputPackage

    --        if debug(options)$GOPT0 then
    --            output("interpolating..."::OutputForm)$OutputPackage

            ri : FSUPFPOLYS
               := interpolate(xlist, ylist, (len-1-i)::NNI) _
                             $FFFG(FPOLYS, SUP FPOLYS)

    --        if debug(options)$GOPT0 then
    --            output(hconcat("ri ", ri::OutputForm))$OutputPackage

            poly1 : POLYS := numer(elt(ri, x1)$SUP(FPOLYS) - y1)
            poly2 : POLYS := numer(elt(ri, x2)$SUP(FPOLYS) - y2)
            poly3 : POLYS := numer(elt(ri, x3)$SUP(FPOLYS) - y3)

    --        if debug(options)$GOPT0 then
    --            output(hconcat("poly1 ", poly1::OutputForm))$OutputPackage
    --            output(hconcat("poly2 ", poly2::OutputForm))$OutputPackage
    --            output(hconcat("poly3 ", poly3::OutputForm))$OutputPackage


            n : Integer := len - i
            res1 : SUP S := univariate(resultant(poly1, poly3, a1))
            res2 : SUP S := univariate(resultant(poly2, poly3, a1))
    --        if debug(options)$GOPT0 then
    --            output(hconcat("res1 ", res1::OutputForm))$OutputPackage
    --            output(hconcat("res2 ", res2::OutputForm))$OutputPackage

    --            if res1 ~= res1res or res2 ~= res2res then
    --            output(hconcat("poly1 ", poly1::OutputForm))$OutputPackage
    --                output(hconcat("poly2 ", poly2::OutputForm))$OutputPackage
    --            output(hconcat("poly3 ", poly3::OutputForm))$OutputPackage
    --                output(hconcat("res1 ", res1::OutputForm))$OutputPackage
    --                output(hconcat("res2 ", res2::OutputForm))$OutputPackage
    --            output("n/i: " string(n) " " string(i))$OutputPackage
    --            output("res1 ord: " string(minimumDegree res1))
    --                  $OutputPackage
    --            output("res1 deg: " string(degree res1))
    --                  $OutputPackage
    --            output("res2 ord: " string(minimumDegree res2))
    --                  $OutputPackage
    --            output("res2 deg: " string(degree res2))
    --                  $OutputPackage

            if debug(options)$GOPT0 then
                output("Guess: computing gcd...")$OutputPackage

    -- we want to solve over F
            res3 : SUP F := SUPS2SUPF(primitivePart(gcd(res1, res2)))

    --        if debug(options)$GOPT0 then
    --            output(hconcat("res3 ", res3::OutputForm))$OutputPackage

    -- res3 is a polynomial in A=a0+(len+3)*a1
    -- now we have to find the roots of res3

            for f in factorList factor(res3)$GF | degree f.factor = 1 repeat
    -- we are only interested in the linear factors
    --             if debug(options)$GOPT0 then
    --                 output(hconcat("f: ", f::OutputForm))$OutputPackage

                Av : F := -coefficient(f.factor, 0)
                         / leadingCoefficient f.factor

    --             if debug(options)$GOPT0 then
    --                 output(hconcat("Av: ", Av::OutputForm))$OutputPackage

    -- FIXME: in an earlier version, we disregarded vanishing Av
    --        maybe we intended to disregard vanishing a1v? Either doesn't really
    --        make sense to me right now.

                evalPoly := eval(POLYS2POLYF poly3, A, Av)
                if zero? evalPoly
                then evalPoly := eval(POLYS2POLYF poly1, A, Av)
    -- Note that it really may happen that poly3 vanishes when specializing
    -- A. Consider for example guessExpRat([1, 1, 1, 1]).

    -- FIXME: We check poly1 below, too. I should work out in what cases poly3
    -- vanishes.

                for g in factorList factor(univariate evalPoly)$GF
                          | degree g.factor = 1 repeat
    --                 if debug(options)$GOPT0 then
    --                     output(hconcat("g: ", g::OutputForm))$OutputPackage

                    a1v : F := -coefficient(g.factor, 0)
                              / leadingCoefficient g.factor

    --                 if debug(options)$GOPT0 then
    --                     output(hconcat("a1v: ", a1v::OutputForm))$OutputPackage

    -- check whether poly1 and poly2 really vanish. Note that we could have found
    -- an extraneous solution, since we only computed the gcd of the two
    -- resultants.

                    t1 := eval(POLYS2POLYF poly1, [a1, A]::List V,
                                                   [a1v, Av]::List F)

    --                 if debug(options)$GOPT0 then
    --                     output(hconcat("t1: ", t1::OutputForm))$OutputPackage

                    not(zero? t1) => "iterate"
                    t2 := eval(POLYS2POLYF poly2, [a1, A]::List V,
                                                  [a1v, Av]::List F)

    --                     if debug(options)$GOPT0 then
    --                         output(hconcat("t2: ", t2::OutputForm))$OutputPackage

                    if zero? t2 then

                        ri1 : Fraction SUP POLYS
                                 := SUPFPOLYS2FSUPPOLYS(numer ri)
                                  / SUPFPOLYS2FSUPPOLYS(denom ri)

    --                         if debug(options)$GOPT0 then
    --                             output(hconcat("ri1: ", ri1::OutputForm))$OutputPackage

                        numr : SUP F := SUPPOLYS2SUPF(numer ri1, a1v, Av)
                        denr : SUP F := SUPPOLYS2SUPF(denom ri1, a1v, Av)

    --                  if debug(options)$GOPT0 then
    --                      output(hconcat("numr: ", numr::OutputForm)
    --                            )$OutputPackage
    --                      output(hconcat("denr: ", denr::OutputForm)
    --                            )$OutputPackage

                        if not zero? denr then
                            res4 : EXPRR := eval(FSUPF2EXPRR(xx, numr/denr),
                                                 kernel(xx), basis(xx::EXPRR))
                                             * extEXPR(xx, a1v, Av)

    --                             if debug(options)$GOPT0 then
    --                                 output(hconcat("res4: ", res4::OutputForm))$OutputPackage

                            res := cons(res4, res)
                        else if zero? numr and debug(options)$GOPT0 then
                            output("Guess: numerator and denominator vanish!"
                                  )$OutputPackage

    -- If we are only interested in one solution, we do not try other degrees if we
    -- have found already some solutions. I.e., the indentation here is correct.

            if not(empty?(res)) and one(options)$GOPT0 then return res

        res

    guessBinRatAux0(list : List F,
                    basis : DIFFSPECN, ext : EXT, extEXPR : EXTEXPR,
                    options : LGOPT) : GUESSRESULT ==

        if zero? safety(options)$GOPT0 then
            error "Guess: guessBinRat does not support zero safety"
    -- guesses Functions of the form binomial(a+b*n, n)*rat(n)
        xx := indexName(options)$GOPT0

    -- restrict to safety

        len : Integer := #list
        if len-safety(options)$GOPT0+1 < 0 then return []

        shortlist : List F := first(list, (len-safety(options)$GOPT0+1)::NNI)

    -- remove zeros from list

        zeros : EXPRR := 1
        newlist : List F
        xValues : List Integer

        i : Integer := -1
        for x in shortlist repeat
            i := i+1
            if x = 0 then
                zeros := zeros * (basis(xx::EXPRR) - basis(i::EXPRR))

        i := -1
        for x in shortlist repeat
            i := i+1
            if x ~= 0 then
                newlist := cons(x/retract(eval(zeros, xx::EXPRR, i::EXPRR))@F,
                                newlist)
                xValues := cons(i, xValues)

        newlist := reverse newlist
        xValues := reverse xValues

        res : List EXPRR
            := [eval(zeros * f, xx::EXPRR, xx::EXPRR) _
                for f in guessBinRatAux(xx, newlist, basis, ext,
                                        extEXPR, xValues, options)]

        select(z1 +-> checkResult(z1, xx, len, list) <
                           len-safety(options)$GOPT0, res)

    guessBinRat(list : List F, options : LGOPT) : GUESSRESULT ==
        guessBinRatAux0(list, defaultD, binExt, binExtEXPR, options)


    if F has RetractableTo Symbol and S has RetractableTo Symbol then

        qD : Symbol -> DIFFSPECN
        qD q == (z1 : EXPRR) : EXPRR +-> (q::EXPRR)^z1

        qBinExtAux(q : Symbol, i : Integer, va1 : V, vA : V) : FPOLYS ==
            fl : List FPOLYS
                 := [(1$FPOLYS - _
                      va1::POLYS::FPOLYS * (vA::POLYS::FPOLYS)^(i-1) * _
                      F2FPOLYS(q::F)^l) / (1-F2FPOLYS(q::F)^l) _
                     for l in 1..i]
            reduce(_*, fl, 1)

        qBinExt : Symbol -> EXT
        qBinExt q == (z1 : Integer, z2 : V, z3 : V) : FPOLYS +->
                        qBinExtAux(q, z1, z2, z3)

        qBinExtEXPRaux(q : Symbol, i : Symbol, a1v : F, Av : F) : EXPRR ==
            l : Symbol := 'l
            product((1$EXPRR - _
                     coerce a1v * (coerce Av) ^ (coerce i - 1$EXPRR) * _
                     (q::EXPRR) ^ coerce(l)) / _
                    (1$EXPRR - (q::EXPRR) ^ coerce(l)), _
                    equation(l, 1$EXPRR..i::EXPRR))

        qBinExtEXPR : Symbol -> EXTEXPR
        qBinExtEXPR q == (z1 : Symbol, z2 : F, z3 : F) : EXPRR +->
                            qBinExtEXPRaux(q, z1, z2, z3)

        guessBinRat(q : Symbol) : GUESSER ==
             (z1 : List F, z2 : LGOPT) : GUESSRESULT +->
                guessBinRatAux0(z1, qD q, qBinExt q, qBinExtEXPR q, z2)
)boot $tryRecompileArguments := true

)if false
\section{package GUESS Guess}
)endif

