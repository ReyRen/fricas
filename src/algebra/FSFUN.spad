)abbrev package FSFUN FloatSpecialFunctions

FloatSpecialFunctions() : Exports == Implementation where

  Exports ==> with
    logGamma : Float -> Float
      ++ logGamma(x) is the natural log of \spad{Gamma(x)}.
    logGamma : (Complex Float) -> (Complex Float)
      ++ logGamma(x) is the natural log of \spad{Gamma(x)}.
    Gamma : Float -> Float
      ++ Gamma(x) is the Euler Gamma function.
    Gamma : (Complex Float) -> (Complex Float)
      ++ Gamma(x) is the Euler Gamma function.
    digamma : Float -> Float
      ++ digamma(z) is the logarithmic derivative of \spad{Gamma(x)}.
    digamma : (Complex Float) -> (Complex Float)
      ++ digamma(z) is the logarithmic derivative of \spad{Gamma(x)}.
    Beta : (Float, Float) -> Float
      ++ Beta(x, y) is the Euler Beta function.
    Beta : (Complex Float, Complex Float) -> Complex Float
      ++ Beta(x, y) is the Euler Beta function.
    lambertW : Float -> Float
      ++ lambertW(x) is the Lambert W function.
    lambertW : DoubleFloat -> DoubleFloat
      ++ lambertW(x) is the Lambert W function.
    lambertW : Complex(Float) -> Complex(Float)
      ++ lambertW(x) is the Lambert W function.
    lambertW : Complex(DoubleFloat) -> Complex(DoubleFloat)
      ++ lambertW(x) is the Lambert W function.
    dilog : Complex(Float) -> Complex(Float)
      ++ dilog(z) is the dilogaritm
    li2 : Complex(Float) -> Complex(Float)
      ++ li2(z) is polylog(2, z)
    -- Functions below should be local, but conditional
    rabs :  Float -> Float
      ++ Undocumented
    rabs : Complex(Float) -> Float
      ++ Undocumented
    rabs : DoubleFloat -> DoubleFloat
      ++ Undocumented
    rabs : Complex(DoubleFloat) -> DoubleFloat
      ++ Undocumented
    lambert_via_newton1 : (Float, Float, Float) -> Float
      ++ Undocumented
    lambert_via_newton1 : (DoubleFloat, DoubleFloat, DoubleFloat
                          ) -> DoubleFloat
      ++ Undocumented
    lambert_via_newton1 : (Complex(Float), Complex(Float), Float
                          ) -> Complex(Float)
      ++ Undocumented
    lambert_via_newton1 : (Complex(DoubleFloat), Complex(DoubleFloat),
                           DoubleFloat) -> Complex(DoubleFloat)
      ++ Undocumented
    lambert_via_newton2 : (Float, Float, Float) -> Float
      ++ Undocumented
    lambert_via_newton2 : (DoubleFloat, DoubleFloat, DoubleFloat
                          ) -> DoubleFloat
      ++ Undocumented
    lambert_via_newton2 : (Complex(Float), Complex(Float), Float
                          ) -> Complex(Float)
      ++ Undocumented
    lambert_via_newton2 : (Complex(DoubleFloat), Complex(DoubleFloat),
                           DoubleFloat) -> Complex(DoubleFloat)
      ++ Undocumented
    lambert_inverse_series : (Float, Float) -> Float
      ++ Undocumented
    lambert_inverse_series : (DoubleFloat, DoubleFloat) -> DoubleFloat
      ++ Undocumented
    lambert_inverse_series : (Complex(Float), Complex(Float)
                             ) -> Complex(Float)
      ++ Undocumented
    lambert_inverse_series : (Complex(DoubleFloat), Complex(DoubleFloat)
                             ) -> Complex(DoubleFloat)
      ++ Undocumented

  Implementation ==> add

    bernoulli_gamma_series(z : Complex Float, n : Integer) : Complex Float ==
       zinv := 1/z
       zk := zinv
       z2inv := zinv*zinv
       s := zk*((1/12)::(Complex Float))
       for k in 1..n repeat
           zk := zk*z2inv
           kinv := (1::Float)/(((2*k +2)*(2*k+1))::Float)
           bk := (bernoulli(2*k+2)$IntegerNumberTheoryFunctions)::Float
           s := s + ((bk*kinv)::(Complex Float))*zk
       s

    logGamma_a1(z : Complex Float) : Complex Float ==
       (z - ((1/2)::(Complex Float)))*log(z) - z _
           + ((1/2)::(Complex Float))_
             *((log((2 :: Float)*pi()))::(Complex Float))

    logGamma_asymptotic(z : Complex Float, n : Integer) : Complex Float ==
       lg1 := logGamma_a1(z)
       lg1 + bernoulli_gamma_series(z, n)

    gamma_series(z : Complex Float, l : Float, n : Integer) : Complex Float ==
       tk := exp(z*(log(l)::(Complex Float)))/z
       s := tk
       for k in 1..n repeat
          tk := tk*(l::(Complex Float))/(z + (k::(Complex Float)))
          s := s + tk
       s*(exp(-l)::(Complex Float))

    Gamma(z : Complex Float) : Complex Float ==
        not(base()$Float =$Integer 2) =>
            error "Gamma can only handle base 2 Float-s"
        l0 := bits()
        l := max(l0 + 5, 20)
        re_z := real(z)
        re_z < (1/2)::Float =>
            bits (l + 5)
            re_zint := round(re_z)
            z1 := z - re_zint::Complex Float
            sign : Float :=
                odd?(retract(re_zint)@Integer) => -1
                1
            z1 = 0 =>
                bits(l0)
                error "Pole of Gamma"
            c_pi := (pi())::(Complex Float)
            one := 1::(Complex Float)
            result := (sign::Float)*c_pi/(Gamma(one - z)*sin(c_pi * z1))
            bits(l0)
            result
        abs_z := real(abs(z))
        l :: Float > 6*abs_z =>
            oz := max(order(abs_z), 5) :: PositiveInteger
            lz := length(oz) :: PositiveInteger
            bits(oz+lz+30)
            loss := real(logGamma_a1(real(z)::(Complex Float))) - _
                    real(logGamma_a1(z))
            len : Float := 2*real(z) + 2*(loss + log2() * (l :: Float)) + 3::Float
            l1a := (l + order(len) + wholePart(loss/log2()) + 12)
            l1 := max(l1a, wholePart(abs_z*log(len)/log2()) +
                           10)::PositiveInteger
            bits(l1)
            result := gamma_series(z, len, 3*wholePart(len) + 6)
            bits(l0)
            result
        llog := max(order(real(abs(logGamma_a1(z)))), 5) :: PositiveInteger
        -- we sum l term, so need length(l) extra bits to
        -- compensate roundoff error
        -- we need llog extra bits in logGamma to avoid loss of
        -- accuracy due to exponential
        -- 12 extra bits to compensate for constant factor
        -- and inaccuracy in computing number of bits
        l1 := l + llog + (length(l)::PositiveInteger) + 12
        bits(l1)
        result := exp(logGamma_asymptotic(z, l quo 6 + 1 ))
        bits(l0)
        result

    -- in exact arithmetic |imag(logGamma_a1(z) - logGamma(z))| < pi/2
    logGamma_lift(z : Complex Float, lg2 : Complex Float) : Complex Float ==
        lg2i := imag(lg2)
        k := round((imag(logGamma_a1(z)) - lg2i)/(2*pi()))
        lg2 + (imaginary()$(Complex Float))*((k*(2::Float)*pi())::(Complex Float))


    logGamma(z : Complex Float) : Complex Float ==
        not(base()$Float =$Integer 2) =>
            error "Gamma can only handle base 2 Float-s"
        l0 := bits()
        l := max(l0 + 5, 20)
        re_z := real(z)
        one := 1::(Complex Float)
        re_z < (1/2)::Float =>
            bits (l + 5)
            re_zint := round(re_z)
            z1 := z - re_zint::Complex Float
            lsign : Float :=
                odd?(retract(re_zint)@Integer) => 1
                0
            z1 = 0 =>
                bits(l0)
                error "Pole of Gamma"
            bits (l + 5)
            c_pi := (pi())::(Complex Float)
            result := log(c_pi) + complex(0, lsign)*c_pi
                       - logGamma(one - z) - log(sin(c_pi * z1))
            result := logGamma_lift(z, result)
            bits(l0)
            result
        abs_z := real(abs(z))
        l :: Float > 6*abs_z =>
            l := l + 5
            if real(abs(z - one)) < ((1/4)::Float) or _
               real(abs(z - one - one)) < ((1/4)::Float) then
                l := 2*l
            bits(l)
            result := logGamma_lift(z, log(Gamma(z)))
            bits(l0)
            result
        -- we sum l term, so need length(l) extra bits to
        -- compensate roundoff error
        -- 12 extra bits to compensate for inaccuracy in computing
        -- number of bits and constant factor
        l1 := l + length(l)::PositiveInteger + 12
        bits(l1)
        result := logGamma_asymptotic(z, l quo 6 + 1 )
        bits(l0)
        result

    Gamma(x : Float) : Float ==
        real(Gamma(x :: (Complex Float)))

    logGamma(x : Float) : Float ==
        x <= 0 =>
            error "Argument to logGamma <= 0"
        real(logGamma(x :: (Complex Float)))

    Beta(x : Complex Float, y : Complex Float) : Complex Float ==
        not(base()$Float =$Integer 2) =>
            error "Beta can only handle base 2 Float-s"
        l0 := bits()
        l1 := max(30, l0 + 10)
        bits(l1)
        -- FIXME : compensate for error in Gamma(x + y)
        res := Gamma(x)*Gamma(y)/Gamma(x + y)
        bits(l0)
        res

    Beta(x : Float, y : Float) : Float ==
        real(Beta(x::(Complex Float), y::(Complex Float)))

    rabs(r : Float) : Float == abs(r)

    rabs(r : Complex(Float)) : Float == real(abs(r))

    rabs(r : DoubleFloat) : DoubleFloat == abs(r)

    rabs(r : Complex(DoubleFloat)) : DoubleFloat == real(abs(r))

    I ==> Integer
    PI ==> PositiveInteger
    RF ==> Float
    CF ==> Complex(Float)
    DF ==> DoubleFloat
    RN ==> Fraction(Integer)

    digamma_euler_maclaurin(a : CF, n : I, m : I) : CF ==
        res : CF := 0
        for k in 0..n repeat
            ck := 1/(k::CF + a)
            res := res + ck
        n1 := n + 1
        na := n1::CF + a
        ns := 1/na
        ns1 : CF := 1
        res := res + (1/2)::RF*ns - log(na)
        n2_inv := 1/(na*na)
        for k in 1..m repeat
            kfac := (2*k)::RF
            ns1 := n2_inv*ns1
            bk := (bernoulli(2*k)$IntegerNumberTheoryFunctions)::RF
            res := res + (bk/kfac)*ns1
        -res

    digamma_aux(a : CF, l : I) : CF ==
        abs_a := sqrt(norm(a))
        l::Float > 6*abs_a =>
            digamma_euler_maclaurin(a, l quo 6 + 1, l quo 6 + 1)
        digamma_euler_maclaurin(a, -1, l quo 6 + 1)

    digamma(a : CF) : CF ==
        l0 := bits()$RF
        l := max(l0 + 10, 61)
        try
            re_a := real(a)
            re_a < (1/2)::Float =>
                l := l + 5
                bits(qcoerce(l + 3*length(l)$I + 10)@PI)$RF
                re_aint := round(re_a)
                a1 := a - complex(re_aint, 0)
                a1 = 0 => error "Pole of Gamma"
                r_pi := pi()$Float
                ap := r_pi*a1
                -r_pi*cos(ap)/sin(ap) + digamma_aux(1 - a, l)
            bits(qcoerce(l + 3*length(l)$I + 10)@PI)$RF
            digamma_aux(a, l)
        finally
            bits(l0)$RF

    digamma(z : RF) : RF == real(digamma(complex(z, 0)))

    li2_series(z : CF, prec : I) : CF ==
        nz := norm(z)
        oz := order(nz)
        n : I :=
            oz < -200 => (2*prec quo (-oz - 1)) + 1
            retract(round((2*prec)::DF*(-log(2::DF)/log(convert(nz)@DF))))@I + 1
        res : CF := 0
        for i in 1..n repeat
            k : I := n + 2 - i
            k2 := k*k
            ck := 1/(k2::RF)
            res := z*(res + complex(ck, 0))
        z*(1 + res)

    li2_aux(z : CF, prec : I) : CF ==
        rz := real(z)
        iz := imag(z)
        siz : RF :=
            iz > 0 => 1
            -1
        -- Transformations do not work when z is a qubic root of -1
        -- We check for this and use formula:
        --   Li(2, z^2) = 2*(Li(2, z) + Li(2, -z))
        w := complex((1/2)::RF, siz*(1/2)::RF*sqrt(3::RF))
        dd := norm(z - w)
        dd < (1/8)::RF =>
            (1/2)::RF*li2_aux(z*z, prec+2) - li2_aux(-z, prec+2)
        nz := norm(z)
        z1 := 1 - z
        rpi := pi()$RF
        pi_fac := (1/6)::RF*rpi*rpi
        rz > (1/2)::RF =>
            nz1 := norm(z1)
            nz1 >= 1 =>
                lmz := log(-z)
                -pi_fac::CF -(1/2)::RF*lmz*lmz - li2_series(1/z, prec)
            lz := log(z)
            z1 = 0 => pi_fac::CF
            lz1 := log(z1)
            nz >= 1 =>
                pi_fac::CF + lz*((1/2)::RF*lz - lz1) +
                  li2_series(-z1/z, prec)
            pi_fac::CF - lz*lz1 - li2_series(z1, prec)
        nz >= 1 =>
            -pi_fac::CF + (1/2)::RF*log(z1)*log(z1/(z*z)) + li2_series(1/z1, prec)
        nz1 := norm(z1)
        nz1 >=1 =>
            lz1 := log(z1)
            -(1/2)::RF*lz1*lz1 - li2_series(-z/z1, prec)
        li2_series(z, prec)

    li2(z : CF) : CF ==
        obits := bits()$RF
        prec := obits + 5
        try
            bits(obits+20)
            li2_aux(z, prec)
        finally
            bits(obits)

    dilog_aux(z : CF, prec : I) : CF ==
        nz := norm(z)
        res : CF
        nz < (1/4)::RF =>
            rpi := pi()$RF
            pi_fac := (1/6)::RF*rpi*rpi
            z = 0 => pi_fac::CF
            lz := log(z)
            lz1 := log(1 - z)
            res := pi_fac::CF - lz*lz1 - li2_series(z, prec)
        li2_aux(1 - z, prec)

    dilog(z : CF) : CF ==
        obits := bits()$RF
        prec := obits + 5
        try
            bits(obits+20)
            dilog_aux(z, prec)
        finally
            bits(obits)

    Funs ==>
        lambert_via_newton1(x : NT, w : NT, eps : RNT) : NT ==
            odw := 1$RNT
            repeat
                ew := exp(w)
                dw := (w - x/ew)/(w + 1)
                w := w - dw
                odw < eps => return w
                odw := rabs(dw)

        lambert_via_newton2(lz : NT, w : NT, eps : RNT) : NT ==
            odw := 1$RNT
            repeat
                lw := log(w)
                dw := (w + lw - lz)/(1 + 1/w)
                w := w - dw
                odw < eps => return w
                odw := rabs(dw)

        lambert_inverse_series(h : NT, h2 : NT) : NT ==
            res := h - (1/$RN 3)::NT *h2
            h3 := h*h2
            res := res + (11/$RN 72)::NT*h3
            h4 := h2*h2
            res := res - (43/$RN 540)::NT*h4
            res := res + (769/$RN 17280)::NT*h3*h2
            res - (221/$RN 8505)::NT*h4*h2

    Funs where
        NT ==> Float
        RNT ==> Float

    Funs where
        NT ==> Complex(Float)
        RNT ==> Float

    Funs where
        NT ==> DoubleFloat
        RNT ==> DoubleFloat

    Funs where
        NT ==> Complex(DoubleFloat)
        RNT ==> DoubleFloat

    lambertW(x : DoubleFloat) : DoubleFloat ==
        x = 0 => x
        eps := float(1, -35)$DoubleFloat
        ox := order(x)
        ox < -70 => x
        ox > 200 and x > 0 =>
            lx := log(x)
            lambert_via_newton2(lx, lx, eps)
        w : DoubleFloat :=
            x > 2::DoubleFloat =>
                y := log(x)
                y - log(y)
            (1/2)::DoubleFloat*x
        x < (-190436/$RN 517656)::DoubleFloat => error "x < -exp(-1)"
        x < (-231087/$RN 628160)::DoubleFloat =>
            e1 := exp(-1::DoubleFloat)
            h2 := x + e1
            h2 < 0 => error "x < -exp(-1)"
            h2 := 2*h2/e1
            h := sqrt(h2)
            lambert_inverse_series(h, h2) - 1
        if (ax := abs(x)) < (1/2)::DoubleFloat then
            eps := ax*eps
        lambert_via_newton1(x, w, eps)

    lambertW(x :  Complex(DoubleFloat)) : Complex(DoubleFloat) ==
        x = 0 => x
        rx := real(x)
        ix := imag(x)
        ax : DoubleFloat := abs(rx) + abs(ix)
        eps := float(1, -35)$DoubleFloat
        ox := order(ax)
        ox < -70 => x
        ox > 200 =>
            -- sbcl log has trouble when |z| > 2^997
            -- Clozure CL and gcl log has trouble when |z| > 2^511
            -- so we scale x to avoid troubles
            lz := complex(log(ax), 0) + log(complex(rx/ax, ix/ax))
            lambert_via_newton2(lz, lz, eps)
        abs(ix) < (1/$RN 4194304)::DoubleFloat
           and rx < (-231087/$RN 628160)::DoubleFloat
              and (-56258/$RN 152925)::DoubleFloat < rx =>
            e1 := exp(-1::DoubleFloat)
            h2 := 2*(1/e1)*(x + complex(e1, 0))
            h := sqrt(h2)
            lambert_inverse_series(h, h2) - 1
        w :=
            ax > 2::DoubleFloat =>
                y := log(x)
                y - log(y)
            (1/2)::DoubleFloat*x
        if ax < (1/2)::DoubleFloat then
            eps := ax*eps
        lambert_via_newton1(x, w, eps)

    lambertW(x : Float) : Float ==
        x = 0 => x
        cbit := bits()
        eps := float(1, -2*cbit quo 3)
        ax := abs(x)
        ox := order(ax)
        ox < -cbit - 10 => x
        ox > 200 and x > 0 =>
            lx := log(x)
            lambert_via_newton2(lx, lx, eps)
        x < (-190436/$RN 517656)::Float => error "x < -exp(-1)"
        x < (-190434/$RN 517656)::Float =>
            cbit2 := cbit quo 2
            bits(qcoerce(cbit + cbit2)@PositiveInteger)$Float
            e1 := exp(-1::Float)
            h2 := x + e1
            h := sqrt(h2)
            bits(cbit)
            h2 < 0 => error "x < -exp(-1)"
            w1 := lambert_inverse_series(h, h2)
            order(w1) < -cbit2 => w1 - 1
            lambert_via_newton1(x, w1 - 1, eps)
        w : Float :=
             x > 2::Float =>
                 y := log(x)
                 y - log(y)
             0.5*x
        if abs(x) < (1/$RN 2)::Float then
            eps := ax*eps
        lambert_via_newton1(x, w, eps)

    lambertW(z : Complex(Float)) : Complex(Float) ==
        z = 0 => z
        cbit := bits()$Float
        eps := float(1, -2*cbit quo 3)
        abs_z := rabs(z)
        oz := order(abs_z)
        oz < -cbit - 10 => z
        oz > 200 =>
            lz := log(z)
            lambert_via_newton2(lz, lz, eps)
        rzd := real(z)::DoubleFloat
        imag(z) > (1/1000000) or (rzd < (-190436 /$RN 517656)::DoubleFloat)
          or (rzd > (-190434 /$RN 517656)::DoubleFloat) =>
            izd := imag(z)::DoubleFloat
            wd : Complex(DoubleFloat) := lambertW(complex(rzd, izd))
            w : Complex(Float) := complex(convert(real(wd))@Float,
                                          convert(imag(wd))@Float)
            if abs_z < (1/2)::Float then
                eps := abs_z*eps
            lambert_via_newton1(z, w, eps)
        cbit2 := cbit quo 2
        bits(qcoerce(cbit + cbit2)@PositiveInteger)
        e1 := exp(-1$Float)
        h2 := z + complex(e1, 0)
        h := sqrt(h2)
        bits(cbit)
        w1 := lambert_inverse_series(h, h2)
        order(rabs(h2)) < -cbit2 => w1 - 1
        lambert_via_newton1(z, w1 - 1, eps)



