)abbrev domain MFGRPH MultifunctionGraph
++ Author: Martin Baker
++ Date Created: January 2012
++ Basic Operations:
++ Related Constructors:
++ Keywords: graph theory
++ Description: allows us to model graph theory
++
++ References:
++ http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/graph/

MultifunctionGraph(S) : Exports == Implementation where

 S : SetCategory
 NNI==> NonNegativeInteger
 -- the following represent the graph in FiniteGraph
 OBJT ==> Record(value : S, posX : NNI, posY : NNI)
 ARROW ==> Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)
 -- represent the graph in this domain
 MFOBJT ==> Record(value : S, posX : NNI, posY : NNI, next : List NNI, _
                                      map : List List NNI)
 SPROD ==> Product(S, S)
 GRPHPROD ==> MultifunctionGraph SPROD
 OBJTPROD ==> Record(value : SPROD, posX : NNI, posY : NNI, next : List NNI, _
                                      map : List List NNI)
 AJMAP ==> Union(List NNI,"failed")
 DF ==> DoubleFloat
 PT ==> SCartesian(2)
 x<<y ==> hconcat(x::OutputForm,y::OutputForm)

 Exports ==> FiniteGraph(S) with

  multifunctionGraph : (ob : List S) -> %
    ++ constructor for graph with given list of
    ++ object names. Use this version of the constructor
    ++ if you don't intend to create diagrams and therefore don't
    ++ care about x, y coordinates.
    ++ more objects and arrows can be added later if required.
  multifunctionGraph : (ob : List MFOBJT) -> %
    ++ constructor for graph with given objects
    ++ more objects and arrows can be added later if required.
  multifunctionGraph : (ob : List OBJT, ar : List ARROW) -> %
    ++ constructor for graph with given objects and arrows
    ++ more objects and arrows can be added later if required.
  multifunctionGraph : (objs : List S, am : List List NNI) -> %
    ++ constructor for graph with given objects and adjacency
    ++ matrix.
  multifunctionGraph : (perms : List Permutation S) -> %
    ++ construct graph from a list of permutations.
  "*":(%,%) -> GRPHPROD
    ++ tensor product : the tensor product G*H of graphs G and H is
    ++ a graph such that the vertex set of G*H is the Cartesian
    ++ product V(G) \times V(H); and any two vertices (u, u') and (v, v')
    ++ are adjacent in G \times H if and only if u' is adjacent with
    ++ v' and u is adjacent with v.
  cartesian : (%, %) -> GRPHPROD
    ++ Cartesian product doubles the size of next list in each
    ++ object, that is it produces two arrows out of every node
  closedTensor : (a : %, b : %, f : (S, S)->S) -> %
    ++ as tensor product but returns %.
  closedCartesian : (a : %, b : %, f : (S, S)->S) -> %
    ++ Cartesian product doubles the size of next list in each
    ++ object, that is it produces two arrows out of every node
  coAdjoint : (s : %, m : List NNI) -> AJMAP
    ++ given a mapping from this graph this function tries to
    ++ calculate a unique reverse mapping back to this graph
  contraAdjoint : (s : %, m : List NNI) -> AJMAP
    ++ given a mapping from this graph this function tries to
    ++ calculate a unique reverse mapping back to this graph
  apply : (s : %, a : NNI, m : NNI) -> NNI
    ++ apply 'function' represented by this graph to vertex
    ++ index 'a'
  limit : (s : %, a : NNI, m : NNI) -> Loop
    ++ apply 'function' represented by this graph to 'a'
    ++ repeatedly until we reach a loop which is returned
    ++ as a sequence of vertex indexes.
  _~: % -> %
    ++ The complement or inverse of a graph is a graph on the same
    ++ vertices such that there is an arrow if and only if there
    ++ is not an arrow in its compliment. That is, it is the
    ++ compliment of the arrows but is not the set complement.
    ++ for more information see:
    ++ http://en.wikipedia.org/wiki/Complement_graph
  coerce : (pg : PermutationGroup S) -> %
    ++ coerce PermutationGroup to graph which
    ++ represents the generators of the group
  toCayleyGraph : (permList : List Permutation S, _
                permutationNames : Boolean) -> _
                MultifunctionGraph(String)
    ++ convert permutation generators to a Cayley graph
    ++ permList should contain generator permutations and should
    ++ not contain identity permutation.
    ++ if permutationNames then names generated represent permutation
  toCayleyGraph : (pg : PermutationGroup S) -> _
                MultifunctionGraph(String)
    ++ convert PermutationGroup to a Cayley graph
  toPermutation : (s : %) -> PermutationGroup(NNI)
    ++ generates a permutation group from this graph
    ++ assumes this graph represents a valid group

 Implementation ==> add

  -- This representation has an entry for each vertex:
  -- Record(value: S, posX: NNI, posY: NNI, next: List NNI)
  -- posX and posY are not part of the mathematical structure but
  -- are useful so that it can be drawn in a useful way.
  -- Although this is thought of as a set (no duplication or ordering)
  -- it is implemented as a list because entries in this table are
  -- indexed by the following part so the order of the objects can't
  -- be changed unless the index numbers in the following tables are
  -- changed. The arrows are encoded here in the 'next' entry, each
  -- NNI in this list is an outgoing arrow, this helps to enforce the
  -- rule that there can only be 'n' outgoing arrows for each vertex.
  Rep := Record(objects : List MFOBJT)

  math_to_string ==> mathObject2String$Lisp

  -- constructor for graph with given list of
  -- object names. Use this version of the constructor
  -- if you don't intend to create diagrams and therefore don't
  -- care about x, y coordinates.
  -- more objects and arrows can be added later if required.
  multifunctionGraph(ob : List S) : % ==
    objs : List MFOBJT := [[x, 0::NNI, 0::NNI, [1::NNI], []] for x in ob]
    [objs]

  -- constructor for graph with given objects
  -- more objects and arrows can be added later if required.
  multifunctionGraph(ob : List MFOBJT) : % ==
    [ob]

  -- constructor for graph with given objects and arrows
  -- more objects and arrows can be added later if required.
  multifunctionGraph(ob : List OBJT, ar : List ARROW) : % ==
    arrs : List NNI := [x::NNI for x in 1..#ob]
    for a in ar repeat
      fromo : NNI := a.fromOb
      too : NNI := a.toOb
      arrs.fromo := too
    fobs : List MFOBJT := []
    for f in ob for fn in 1..#ob repeat
      fo : MFOBJT := [f.value, f.posX, f.posY, [arrs.fn], []]
      fobs := concat(fobs, fo)
    [fobs]

  -- constructor for graph with given objects and adjacency
  -- matrix.
  multifunctionGraph(objs : List S, am : List List NNI) : % ==
    obs : List OBJT := []
    for obn in 1..#(objs) repeat
      -- build objects
      ob := objs.obn
      o : OBJT := [ob, createX(#objs, obn), createY(#objs, obn)]
      obs := concat(obs, o)
    fobs : List MFOBJT := []
    for f in obs for fn in 1..#obs repeat
      fo : MFOBJT := [f.value, f.posX, f.posY, [am.fn], []]
      fobs := concat(fobs, fo)
    [fobs]

  -- construct graph from a list of permutations.
  multifunctionGraph(perms : List Permutation S) : % ==
    -- first create list of objects
    obs : List S := []
    for perm in perms for px in 1..#perms repeat
      lr := listRepresentation(perm) -- get list of image-preimage pairs
      im : List S := lr.image
      preim : List S := lr.preimage
      -- make sure every object in every image list is included in obs
      -- once only. preim should contain the same objects so there
      -- is no need to check that.
      if px = 1 then
          obs := im
        else
          for v in im repeat
            if position(v, obs)<1 then obs := concat(obs, v)
    -- then create table for arrows
    tab : List List NNI := [[b for a in 1..#perms] for b in 1..#obs]
    for perm in perms for pi in 1..#perms repeat
      lr := listRepresentation(perm) -- get list of image-preimage pairs
      im : List S := lr.image
      preim : List S := lr.preimage
      for pt in 1..#im repeat
        pin : Integer := position(im.pt, obs)$List(S)
        pout : Integer := position(preim.pt, obs)$List(S)
        (tab.(pin::NNI)).pi := pout::NNI
    -- then create vertex list
    verts : List MFOBJT := []
    for vert in obs for i in 1..#obs repeat
      --x := tab.i
      o : MFOBJT := [vert, createX(#obs, i), createY(#obs, i), tab.i, []]
      verts := concat(verts, o)
    [verts]

  -- adds an object to this graph
  -- The added object loops back to itself
  addObject!(s : %, n : S) : % ==
    obs : List MFOBJT := s.objects
    obj : MFOBJT := [n, 0::NNI, 0::NNI, [#obs], []]
    if obs = []
      then s.objects := [obj]
      else s.objects := concat(obs, obj)
    s

  -- this form of addObject! not supported in multifunctionGraph but
  -- it is in FiniteGraph category and it is included here to trap errors
  addObject!(s : %, n : OBJT) : % ==
    error "this form of addObject! not supported in multifunctionGraph"
    [[]]

  -- Don't use.
  -- This should really be replaceFirst Arrow! in multifunctionGraph
  -- we put hare for compatibility with directedGraph only
  -- where:
  -- s is the graph where the arrow is to be replaced
  -- nm is the name of the arrow (not used)
  -- n1 is the index of the start object
  -- n2 is the index of the end object
  addArrow!(s : %, nm : String, n1 : NNI, n2 : NNI) : % ==
    ((s.objects).n1).next.1 := n2
    s

  -- returns a list of all the vertices (or objects)
  getVertices(s : %) : List OBJT ==
    res : List OBJT := []
    for soj in s.objects repeat
      o : OBJT := [soj.value, soj.posX, soj.posY]
      res := concat(res, o)
    res

  -- returns a list of all the arrows (or edges)
  getArrows(s : %) : List ARROW ==
    res : List ARROW := []
    for sojn in 1..#(s.objects) repeat
      soj : MFOBJT := (s.objects).sojn
      for ar in soj.next for ai in 1..#(soj.next) repeat
        a : ARROW := [concat(string(sojn), string(ai)), 0::NNI, sojn, ar, 0, 0, []]
        res := concat(res, a)
    res

  -- constructs a graph without vertices or edges
  initial() : % ==
    [[]]

  -- constructs a graph with a single vertex and a single loop
  terminal(a : S) : % ==
    o : MFOBJT := [a, 0::NNI, 0::NNI, [1::NNI], []]
    [[o]]

  -- constructs a graph with objects given connected in a
  -- sequence with the last one looping to itself.
  cycleOpen(objs : List S, arrowName : String) : % ==
    obs : List MFOBJT := []
    for obn in 1..#(objs) repeat
      -- build objects
      ob := objs.obn
      n : NNI := obn+1
      if obn = #(objs) then n := #(objs)
      o : MFOBJT := [ob, createX(#objs, obn), createY(#objs, obn), [n], []]
      obs := concat(obs, o)
    [obs]

  -- constructs a graph with objects given connected in a
  -- cycle.
  cycleClosed(objs : List S, arrowName : String) : % ==
    obs : List MFOBJT := []
    for obn in 1..#(objs) repeat
      -- build objects
      ob := objs.obn
      n : NNI := obn+1
      if obn = #(objs) then n := 1::NNI
      o : MFOBJT := [ob, createX(#objs, obn), createY(#objs, obn), [n], []]
      obs := concat(obs, o)
    [obs]

  -- constructs a graph with objects given and arrows from
  -- each object only to itself.
  unit(objs : List S, arrowName : String) : % ==
    objs : List MFOBJT := [[objs.x, 0::NNI, 0::NNI, [x::NNI], []] for x in 1..#objs]
    [objs]

  -- constructs a graph with objects given and fully connected
  -- arrows, that is, each object has an arrow to every other
  -- object except itself.
  kgraph(objs : List S, arrowName : String) : % ==
    error "kgraph not valid in function graph"
    [[]]

  -- sum : disjoint union of vertices with arrows from appropriate
  -- input
  _+(a, b) : % ==
    objs : List MFOBJT := b.objects
    c : List MFOBJT := [[(objs.x).value, _
         (objs.x).posX, (objs.x).posY, _
         [(x::NNI)+#(a.objects)], []] for x in 1..#objs]
    [concat(a.objects, c)]

  -- sum : union (not necessarily disjoint) of vertices with arrows
  -- merged in from appropriate input, if arrow exists from both
  -- inputs then it will be duplicated.
  merge(a : %, b : %) : % ==
    error "merge not valid in function graph"
    [[]]

  -- this is a local function used by both tensorNext and
  -- cartesianNext and so ultimately by tensor and Cartesian
  -- product to calculate the new index.
  indexProd(aObj : %, a : NNI, b : NNI) : NNI ==
    a + ((b::Integer-1)::NNI * #aObj.objects)

  -- this is a local function used by tensor product to calculate
  -- the new next index list.
  tensorNext(aObj : %, a : List NNI, b : List NNI) : List NNI ==
    if #a ~= #b then error concat([_
      "tensor product with different degree a=",math_to_string  a,_
      " b=",math_to_string  b])$String
    res : List NNI := []
    for i in 1..#a repeat
      for j in 1..#b repeat
        x := indexProd(aObj, a.i, b.j)
        res := concat(res, x)$List(NNI)
    res

  -- this is a local function used by Cartesian product to calculate
  -- the new next index list.
  -- a is list of outgoing adjacent nodes in first operand
  -- b is list of outgoing adjacent nodes in second operand
  cartesianNext(aObj : %, a : List NNI, b : List NNI, an : NNI, bn : NNI) : List NNI ==
    if #a ~= #b then error concat([_
      "Cartesian product with different degree a=",math_to_string  a,_
      " b=",math_to_string  b])$String
    res : List NNI := []
    for i in 1..#a repeat
      x := indexProd(aObj, a.i, bn)
      res := concat(res, x)$List(NNI)
      y := indexProd(aObj, an, b.i)
      res := concat(res, y)$List(NNI)
    res

  -- tensor product : the tensor product A*B of graphs A and B is
  -- a graph such that the vertex set of A*B is the Cartesian
  -- product V(A) \times V(B)
  -- any two vertices <au, bu> and <av, bv> are adjacent in A \times B
  -- if and only if bu is adjacent with bv
  -- and au is adjacent with av.
  --
  -- So this is defined over S^2 (that is Product(S, S))
  _*(a : %, b : %) : GRPHPROD ==
    newObjs : List OBJTPROD := []
    for aoi in a.objects repeat
      ai : S := aoi.value
      axi : NNI := aoi.posX
      ayi : NNI := aoi.posY
      ani : List NNI := aoi.next
      for boi in b.objects repeat
        bi : S := boi.value
        bxi : NNI := boi.posX
        byi : NNI := boi.posY
        bni : List NNI := boi.next
        x : NNI := bxi*diagramWidth(a)+axi
        y : NNI := byi*diagramHeight(a)+ayi
        nextA := tensorNext(b, bni, ani)
        sp : SPROD := construct(ai, bi)$SPROD
        ob : OBJTPROD := [sp, x, y, nextA, []]
        newObjs := concat(newObjs, ob)
    multifunctionGraph(newObjs)$GRPHPROD

  -- Cartesian product: the vertex set of A o B is the Cartesian
  -- product V(A) \times V(B) and any two vertices <au, bu> and <av, bv>
  --  are adjacent in A o B if and only if either
  -- au = av and bu is adjacent with bv or
  -- bu = bv and au is adjacent with av.
  -- Cartesian product doubles the size of next list in each
  -- object, that is it produces two arrows out of every node
  cartesian(a : %, b : %) : GRPHPROD ==
    newObjs : List OBJTPROD := []
    for aptr in 1..#a.objects for aoi in a.objects repeat
      ai : S := aoi.value
      axi : NNI := aoi.posX
      ayi : NNI := aoi.posY
      ani : List NNI := aoi.next
      for bptr in 1..#a.objects for boi in b.objects repeat
        bi : S := boi.value
        bxi : NNI := boi.posX
        byi : NNI := boi.posY
        bni : List NNI := boi.next
        x : NNI := bxi*diagramWidth(a)+axi
        y : NNI := byi*diagramHeight(a)+ayi
        nextA := cartesianNext(b, bni, ani, bptr, aptr)
        sp : SPROD := construct(ai, bi)$SPROD
        ob : OBJTPROD := [sp, x, y, nextA, []]
        newObjs := concat(newObjs, ob)
    multifunctionGraph(newObjs)$GRPHPROD

  -- as tensor product but returns %.
  closedTensor(a : %, b : %, f : (S, S)->S) : % ==
    -- new objects are calculated by local closedObjProd function
    -- calculate new arrows:
    newObjs : List MFOBJT := []
    for aoi in a.objects repeat
      ai : S := aoi.value
      axi : NNI := aoi.posX
      ayi : NNI := aoi.posY
      ani : List NNI := aoi.next
      for boi in b.objects repeat
        bi : S := boi.value
        bxi : NNI := boi.posX
        byi : NNI := boi.posY
        bni : List NNI := boi.next
        x : NNI := bxi*diagramWidth(a)+axi
        y : NNI := byi*diagramHeight(a)+ayi
        nextA := tensorNext(b, bni, ani)
        sp : S := f(ai, bi)
        ob : MFOBJT := [sp, x, y, nextA, []]
        newObjs := concat(newObjs, ob)
    multifunctionGraph(newObjs)

  -- as tensor product but returns %.
  closedCartesian(a : %, b : %, f : (S, S)->S) : % ==
    -- new objects are calculated by local closedObjProd function
    -- calculate new arrows:
    newObjs : List MFOBJT := []
    for aptr in 1..#a.objects for aoi in a.objects repeat
      ai : S := aoi.value
      axi : NNI := aoi.posX
      ayi : NNI := aoi.posY
      ani : List NNI := aoi.next
      for bptr in 1..#a.objects for boi in b.objects repeat
        bi : S := boi.value
        bxi : NNI := boi.posX
        byi : NNI := boi.posY
        bni : List NNI := boi.next
        x : NNI := bxi*diagramWidth(a)+axi
        y : NNI := byi*diagramHeight(a)+ayi
        nextA := cartesianNext(b, bni, ani, bptr, aptr)
        sp : S := f(ai, bi)
        ob : MFOBJT := [sp, x, y, nextA, []]
        newObjs := concat(newObjs, ob)
    multifunctionGraph(newObjs)

  -- The complement or inverse of a graph is a graph on the same
  -- vertices such that there is an arrow if and only if there
  -- is not an arrow in its compliment. That is, it is the
  -- compliment of the arrows but is not the set complement.
  -- for more information see:
  -- http://en.wikipedia.org/wiki/Complement_graph
  ~ s ==
    newObjs : List MFOBJT := []
    for aoi in s.objects repeat
      nextA : List NNI := []
      for x in 1..#(s.objects) repeat
        if position(x, aoi.next) = 0 then nextA := concat(nextA, x)
      ob : MFOBJT := [aoi.value, aoi.posX, aoi.posY, nextA, []]
      newObjs := concat(newObjs, ob)
    [newObjs]

  -- create a new graph by mapping from this one
  -- newOb should contain the new list of vertices.
  -- m should contain a NNI value for each vertex, this is the
  -- new index into newOb. It is allowed that newOb may contain
  -- less objects than s (for surjective mapping) or
  -- more objects than s (for injective mapping)
  map(s : %, m : List NNI, newOb : List S, offsetX : Integer, offsetY : Integer) : % ==
    newObjs : List MFOBJT := [[o, 0::NNI, 0::NNI, [], []] for o in newOb]
    oldObjs : List MFOBJT := s.objects
    for oi in 1..#oldObjs repeat
      oldObj := oldObjs.oi
      i : NNI := m.oi
      newObj := newOb.i
      newX := ((oldObj.posX)+offsetX)::NNI
      newY := ((oldObj.posY)+offsetY)::NNI
      newNext : List NNI := []
      for n in oldObj.next repeat
        newNext := concat(newNext, m.n)
      nv : MFOBJT := [newObj, newX, newY, newNext, []] -- assemble new vertex
      newObjs.i := nv -- replace holding value
    [newObjs]

  -- similar to map function but reverses the directions of
  -- the arrows
  mapContra(s : %, m : List NNI, newOb : List S, offsetX : Integer, offsetY : Integer) : % ==
    newObjs : List MFOBJT := [[o, 0::NNI, 0::NNI, [], []] for o in newOb]
    oldObjs : List MFOBJT := s.objects
    for oi in 1..#oldObjs repeat
      oldObj := oldObjs.oi
      i : NNI := m.oi
      newObj := newOb.i
      newX := ((oldObj.posX)+offsetX)::NNI
      newY := ((oldObj.posY)+offsetY)::NNI
      newNext : List NNI := []
      for n in oldObj.next repeat
        incoming : List NNI := nodeToNode(s, m.n)
        newNext := concat(newNext, incoming)
      nv : MFOBJT := [newObj, newX, newY, newNext, []] -- assemble new vertex
      newObjs.i := nv -- replace holding value
    [newObjs]

  -- given a mapping from this graph this function tries to
  -- calculate a unique reverse mapping back to this graph
  coAdjoint(s : %, m : List NNI) : AJMAP ==
    domainSize : NNI := #(s.objects)
    codomainSize : NNI := 0
    for mi in m repeat if mi > codomainSize then codomainSize := mi
    ret : List NNI := [0::NNI for x in 1..codomainSize]
    retOpt : List List NNI := [[] for x in 1..codomainSize]
    for mi in 1..#m repeat
      retOpt.(m.mi) := concat(retOpt.(m.mi), mi)
    entry : NNI := 1
    for ri in retOpt repeat
      x := max(s, ri)
      if x = 0 then return "failed"
      ret.entry := x
      entry := entry + 1
    ret

  -- given a mapping from this graph this function tries to
  -- calculate a unique reverse mapping back to this graph
  contraAdjoint(s : %, m : List NNI) : AJMAP ==
    domainSize : NNI := #(s.objects)
    codomainSize : NNI := 0
    for mi in m repeat if mi > codomainSize then codomainSize := mi
    ret : List NNI := [0::NNI for x in 1..codomainSize]
    retOpt : List List NNI := [[] for x in 1..codomainSize]
    for mi in 1..#m repeat
      retOpt.(m.mi) := concat(retOpt.(m.mi), mi)
    entry : NNI := 1
    for ri in retOpt repeat
      x := min(s, ri)
      if x = 0 then return "failed"
      ret.entry := x
      entry := entry + 1
    ret

  -- apply 'function' represented by this graph to vertex
  -- index 'a'
  apply(s : %, a : NNI, m : NNI) : NNI ==
    (((s.objects).a).next).m

  -- apply 'function' represented by this graph to 'a'
  -- repeatedly until we reach a loop which is returned
  -- as a sequence of vertex indexes.
  limit(s : %, a : NNI, m : NNI) : Loop ==
    ptr := a
    for s1 in s.objects repeat
      lp : List Loop := loopsAtNode(s, ptr)
      if #lp > 1 then error "limit: cant have >1 loop through node"
      if #lp = 1 then return first lp
      -- no loop so step to next node
      ptr := apply(s, ptr, m)
    -- should never get here as we should reach a loop by
    -- a number of steps equal to the degree of the graph
    loop([])

  -- coerce PermutationGroup to graph which
  -- represents the generators of the group
  coerce(pg : PermutationGroup S) : % ==
    multifunctionGraph(pg::(List Permutation S))

  -- local function used by toCayleyGraph
  -- find position of entry in list
  -- if not found returns 0
  permIndex(entry : Permutation S, lps2 : List Permutation S) : NNI ==
    dimen : NNI := # lps2
    resu : NNI := 0
    for i in 1..dimen repeat
      e2 : Permutation S := lps2.i
      if entry = e2 then resu := i::NNI
    resu

  -- local function used by toCayleyGraph
  -- apply * of permutations to the permutation generators to get a
  -- list of any new permutations found, this does not include the original
  -- generators.
  -- generateNewPerms returns a record containing:
  --   prm: List Permutation S -- a permutation for each entry
  --   nam: List String        -- a name for each entry
  generateNewPerms(gens2 : List Permutation S, stngs : List String, _
                         permutationNames : Boolean) : _
                         Record(prm : List Permutation S, nam : List String) ==
    dimen : NNI := # gens2
    resu : List Permutation S := [] -- list of new permutations found
    resstr : List String := []      -- names of new permutations found
    for i in 1..dimen repeat
      for j in 1..dimen repeat
        p : Permutation S := (gens2.i)*(gens2.j)
        foundNew : Boolean := (not member?(p, gens2)) and (not member?(p, resu))
        if foundNew then
          resu := concat(resu, p)
          if permutationNames
           then
            resstr := concat(resstr, (math_to_string p)@String)
           else
            resstr := concat(resstr, concat(stngs.i, stngs.j))
    [resu, resstr]

  -- local function used by toCayleyGraph
  -- generate string name for identity or nth generator in sequence:
  -- a, b, c, d, e, f...
  generateName(n : NNI) : String ==
    ascii : NNI := 96
    -- miss out "i" since that is reserved for identity
    if n>8 then ascii := 97
    (char(ascii+n)$Character)::String

  -- local function used by toCayleyGraph
  -- generate string names for identity and generators
  generateNames(n : NNI) : List String ==
    n = 0 => ["0"]
    [generateName(ptr2) for ptr2 in 1..n]

  -- local function used by toCayleyGraph
  -- generate cycle names for identity and generators
  generateNamesCycle(g : List Permutation S) : List String ==
    -- set s1 to name of identity
    s1 : String := (math_to_string 1$(Permutation S))@String
    -- set s2 to names of remaining generators
    s2 : List String := [(math_to_string ptr2)@String for ptr2 in g]
    concat(s1, s2)

  -- convert permutation generators to a Cayley graph
  -- permList should contain generator permutations and should
  -- not contain identity permutation.
  -- if permutationNames then names generated represent permutation
  toCayleyGraph(permList : List Permutation S, permutationNames : Boolean) : _
                MultifunctionGraph(String) ==
    -- first generate complete list of permutations from generators
    -- assume generators don't contain identity so add it to start
    elements : List Permutation S := permList
    numGenerators : NNI := #permList
    -- now multiply all permutations to get closed group
    strngs : List String := generateNames(# elements)
    if permutationNames then strngs := generateNamesCycle(permList)
    --print("toCayley strngs="::Symbol << strngs)
    -- we now generate a full list of permutations from the generators
    -- we do this by repeatedly applying generateNewPerms until it
    -- can't find any more.
    contin : Boolean := true
    while contin repeat
      resu := generateNewPerms(elements, strngs, permutationNames)
      contin := not empty?(resu.prm)
      if contin then
        elements := append(elements, resu.prm)
        strngs := append(strngs, resu.nam)
    -- now we need to move the identity permutation to first in list
    idPos : Integer := position(one?, elements)
    --print("toCayley idPos="::Symbol << idPos)
    if idPos > 1 then
      idPerm := elements.idPos
      elements := concat(idPerm, delete(elements, idPos))
      strngs := concat("i",delete(strngs,idPos))
    --print("toCayley strngs="::Symbol << strngs)
    -- now calculate Cayley table
    dimen : NNI := # elements
    ct : List List NNI := [[_
      permIndex((elements.i)*(elements.j), elements)
        for j in 1..dimen] for i in 1..dimen]
    --print("toCayley ct="::Symbol << ct)
    -- now take out all but generator columns in table
    gens : List List NNI := [_
      first(rest(ct.i), numGenerators) for i in 1..dimen]
    --print("toCayley gens="::Symbol << gens)
    multifunctionGraph(strngs, gens)

  -- convert PermutationGroup to Cayley graph
  --
  toCayleyGraph(pg : PermutationGroup S) : MultifunctionGraph(String) ==
    perms : (List Permutation S) := generators(pg)
    toCayleyGraph(perms, false)

  -- generates a permutation group from this graph
  -- assumes this graph represents a valid group
  toPermutation(s : %) : PermutationGroup(NNI) ==
    lp : List Permutation NNI := []
    preTable : List List NNI
    objs : List MFOBJT := s.objects
    for obj in objs for oi in 1..#objs repeat
      newNext : List NNI := obj.next
      preTable := concat(preTable, newNext)
    -- transpose preTable to give cayleyTable
    numRows := #preTable
    numCols := #(first preTable)
    cayleyTable : List List NNI := [[preTable.j.i for j in 1..numRows] for i in 1..numCols]
    --print("toPermutation cayleyTable="::Symbol << cayleyTable)
    preImgs := [p for p in 1..numRows]
    for i in 1..(# cayleyTable) repeat
      imgs := cayleyTable.i
      --print("toPermutation preImgs="::Symbol << preImgs)
      --print("toPermutation imgs="::Symbol << imgs)
      p : (Permutation NNI) := coercePreimagesImages([preImgs, imgs])
      lp := concat(lp, p)
    permutationGroup(lp)


)if false

\section{domain WGRPH WeightedGraph}

WeightedGraph is an implementation of FiniteGraph.

This domain is the same as directed graph except that each vertex
and each arrow has additional information (of category
OrderedAbelianMonoid) to represent its 'weight'. This is used for
route finding and related operations. Instead of choosing the route
with the lowest number of hops, this domain chooses the route with
the lowest overall weight. That is, the weight for a given route is
the sum of the weights associated with each vertex and each arrow
that the route passes through.

Currently, only the weights for the arrows and not the weights for
the vertices are used, I plan to correct this in the future.

)endif

