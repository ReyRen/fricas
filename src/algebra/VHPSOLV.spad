)abbrev package VHPSOLV VectorHermitePadeSolver
VectorHermitePadeSolver : Exports == Implementation where
  F ==> Expression(Integer)
  SUP ==> SparseUnivariatePolynomial(F)
  Exports ==> with
      hp_solve : (List Vector(SUP), List(NonNegativeInteger),
                  NonNegativeInteger) -> Matrix SUP
        ++ hp_solve(lv, eta, K) solves Hermite-Pade problem with degree
        ++ bound eta up to order K.
  Implementation ==> add

    FFFG ==> FractionFreeFastGaussian(F, SUP)

    power_action(m : NonNegativeInteger
                ) : ((NonNegativeInteger, NonNegativeInteger, SUP) -> F) ==
        (k, l, g) +-> DiffAction(k, m*l, g)$FFFG

    hp_solve(lv, eta, K) ==
        m := #first(lv)
        lpp : List(SUP) := []
        for v in lv repeat
            #v ~= m =>
                error "hp_solve: vectors must be of the same length"
            pp : SUP := 0
            for i in 1..m repeat
                pp1 := multiplyExponents(v(i), m)
                pp := pp + monomial(1, (i-1)::NonNegativeInteger)$SUP*pp1
            lpp := cons(pp, lpp)
        lpp := reverse!(lpp)
        vd : Vector Integer := vector([ei::Integer for ei in eta])
        C : List(F) := [0 for i in 1..K]
        res1 := generalInterpolation(C, power_action(m), vector(lpp),
                                     vd, K)$FFFG
        n := #vd
        n1 : NonNegativeInteger := 0
        for i in 1..n | vd(i) >= 0 repeat
            n1 := n1 + 1
        res := new(n, n1, 0)$Matrix(SUP)
        i1 : NonNegativeInteger := 0
        for i in 1..n | vd(i) >= 0 repeat
            i1 := i1 + 1
            for j in 1..n repeat
                res(j, i1) := res1(j, i)
        res

