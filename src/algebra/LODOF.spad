)abbrev package LODOF LinearOrdinaryDifferentialOperatorFactorizer
++ Author: Fritz Schwarz, Manuel Bronstein
++ Date Created: 1988
++ Description:
++ \spadtype{LinearOrdinaryDifferentialOperatorFactorizer} provides a
++ factorizer for linear ordinary differential operators whose coefficients
++ are rational functions.
++ Keywords: differential equation, ODE, LODO, factoring
LinearOrdinaryDifferentialOperatorFactorizer(F, UP) : Exports == Impl where
  F : Join(Field, CharacteristicZero,
           RetractableTo Integer, RetractableTo Fraction Integer)
  UP : UnivariatePolynomialCategory F

  RF ==> Fraction UP
  L  ==> LinearOrdinaryDifferentialOperator1 RF

  Exports ==> with
    factor : (L, UP -> List F) -> List L
      ++ factor(a, zeros) returns the factorisation of a.
      ++ \spad{zeros} is a zero finder in \spad{UP}.
    if F has AlgebraicallyClosedField then
      factor : L -> List L
        ++ factor(a) returns the factorisation of a.
      factor1 : L -> List L
        ++ factor1(a) returns the factorisation of a,
        ++ assuming that a has no first-order right factor.

  Impl ==> add
    import from RationalLODE(F, UP)
    import from RationalRicDE(F, UP)
--  import from AssociatedEquations RF

    dd := D()$L

    expsol     : (L, UP -> List F, UP -> Factored UP) -> Union(RF, "failed")
    expsols    : (L, UP -> List F, UP -> Factored UP, Boolean) -> List RF
    opeval     : (L, L) -> L
    recurfactor : (L, L, UP -> List F, UP -> Factored UP, Boolean) -> List L
    rfactor    : (L, L, UP -> List F, UP -> Factored UP, Boolean) -> List L
    rightFactor : (L, NonNegativeInteger, UP -> List F, UP -> Factored UP)
                                                          -> Union(L, "failed")
    innerFactor : (L, UP -> List F, UP -> Factored UP, Boolean) -> List L

    factor(l, zeros) == innerFactor(l, zeros, squareFree, true)

    expsol(l, zeros, ezfactor) ==
      empty?(sol := expsols(l, zeros, ezfactor, false)) => "failed"
      first sol

    expsols(l, zeros, ezfactor, all?) ==
      sol := [differentiate(f)/f for f in ratDsolve(l, 0).basis | f ~= 0]
      not(all? or empty? sol) => sol
      concat(sol, ricDsolve(l, zeros, ezfactor))

-- opeval(l1, l2) returns l1(l2)
    opeval(l1, l2) ==
      ans : L := 0
      l2n : L := 1
      for i in 0..degree l1 repeat
        ans := ans + coefficient(l1, i) * l2n
        l2n := l2 * l2n
      ans

    recurfactor(l, r, zeros, ezfactor, adj?) ==
        q := rightExactQuotient(l, r)::L
        innerFactor(q, zeros, ezfactor, true)

    rfactor(op, r, zeros, ezfactor, adj?) ==
      degree r > 1 or not ((leadingCoefficient r) = 1) =>
        recurfactor(op, r, zeros, ezfactor, adj?)
      op1 := opeval(op, dd - coefficient(r, 0)::L)
      map!((z1 : L) : L +-> opeval(z1, r),
           recurfactor(op1, dd, zeros, ezfactor, adj?))

-- r1? is true means look for 1st-order right-factor also
    innerFactor(l, zeros, ezfactor, r1?) ==
      (n := degree l) <= 1 => [l]
      ll := adjoint l
      for i in 1..(n quo 2) repeat
        (r1? or (i > 1)) and ((u := rightFactor(l, i, zeros, ezfactor)) case L) =>
           return concat!(rfactor(l, u::L, zeros, ezfactor, false), u::L)
        (2 * i < n) and ((u := rightFactor(ll, i, zeros, ezfactor)) case L) =>
           return concat(adjoint(u::L), map!(adjoint,
                    reverse!(rfactor(ll, u::L, zeros, ezfactor, true))))
      [l]

    rightFactor(l, n, zeros, ezfactor) ==
      (n = 1) =>
        (u := expsol(l, zeros, ezfactor)) case "failed" => "failed"
        D() - u::RF::L
--    rec := associatedEquations(l, n::PositiveInteger)
--    empty?(sol := expsols(rec.eq, zeros, ezfactor, true)) => "failed"
      "failed"

    if F has AlgebraicallyClosedField then
      zro1 : UP -> List F
      zro : (UP, UP -> Factored UP) -> List F

      zro(p, ezfactor) ==
        concat [zro1(r.factor) for r in factors ezfactor p]

      zro1 p ==
        [zeroOf(map((z1 : F) : F +-> z1, p)$UnivariatePolynomialCategoryFunctions2(F, UP,
                                             F, SparseUnivariatePolynomial F))]

      if F is AlgebraicNumber then
        import from AlgFactor UP

        factor l  == innerFactor(l, (p1 : UP) : List(F) +-> zro(p1, factor), factor, true)
        factor1 l == innerFactor(l, (p1 : UP) : List(F) +-> zro(p1, factor), factor, false)

      else
        factor l  == innerFactor(l, (p1 : UP) : List(F) +-> zro(p1, squareFree), squareFree, true)
        factor1 l == innerFactor(l, (p1 : UP) : List(F) +-> zro(p1, squareFree), squareFree, false)

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-- Compile order for the differential equation solver:
-- oderf.spad  odealg.spad  nlode.spad  nlinsol.spad  riccati.spad
-- kovacic.spad  lodof.spad  odeef.spad
