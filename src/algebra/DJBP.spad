)abbrev domain DJBP DistributedJetBundlePolynomial
++ Description:
++ \spadtype{DistributedJetBundlePolynomial} implements polynomials
++ in a distributed representation. The unknowns come from a finite list of
++ jet variables. The implementation is basically a copy of the one of
++ \spadtype{GeneralDistributedMultivariatePolynomial}.

DistributedJetBundlePolynomial(R, JB, LJV, E) : Cat == Def where

  B    ==> Boolean
  L    ==> List
  NNI  ==> NonNegativeInteger
  VN   ==> Vector NNI
  OUT  ==> OutputForm
  JBC  ==> JetBundleCategory
  JBFC ==> JetBundleFunctionCategory JB
  DPC  ==> DirectProductCategory(#LJV, NNI)
  PCD  ==> PolynomialCategory(R, E, JB)
  SUP  ==> SparseUnivariatePolynomial
  PGCD ==> PolynomialGcdPackage(E, JB, R, %)
  GBP  ==> GroebnerPackage(R, E, %)
  JBP  ==> JetBundlePolynomial(R, JB)

  R   : Ring
  E   : DPC
  JB  : JBC
  LJV : L JB

  Cat ==> PCD with

    convert : JBP -> %
      ++ \spad{convert(p)} converts a polynomial \spad{p} in recursive
      ++ representation into a polynomial in distributive representation.

    convert : % -> JBP
      ++ \spad{convert(p)} converts a polynomial \spad{p} in distributive
      ++ representation into a polynomial in recursive representation.

    const : % -> R
      ++ \spad{const(p)} coerces a polynomial into an element of the
      ++ coefficient ring, if it is constant. Otherwise an error occurs.

    if R has GcdDomain then
      groebner : L % -> L %
        ++ \spad{groebner(lp)} computes a Groebner basis for the ideal
        ++ generated by the list of polynomials \spad{lp}.


  Def ==> PolynomialRing(R, E) add

    LJVO : L OUT := [jv::OUT  for jv in LJV]
    nl : NNI := #LJV

    -- -------------- --
    -- Representation --
    -- -------------- --

    Term := Record(k : E, c : R)
    Rep := L Term

    lookup(jv : JB) : NNI ==
        -- "Index" of a jet variable in LJV.
        -- Local function.
        for i in 1..nl  for ljv in LJV repeat
            if ljv = jv then return i::NNI
        error "illegal jet variable"

    monomial(p : %, jv : JB, e : NNI) : % ==
        j := lookup jv
        v : VN := zero nl
        qsetelt!(v, j, e)
        p*monomial(1, directProduct v)

    coerce(jv : JB) : % == monomial(1, jv, 1)

    zero?(p : %) : B == empty?(p::Rep)

    ground?(p : %) : B == mainVariable(p) case "failed"

    monomial?(p : %) : B ==
        l : Rep := p::Rep
        empty?(l) or empty? rest(l)

    numberOfMonomials(p : %) ==
        l : Rep := p::Rep
        empty? l => 1
        #l

    mainVariable(p : %) : Union(JB, "failed") ==
        zero? p => "failed"
        tdeg := degree p
        for i in 1..nl  for jv in LJV repeat
            if not zero? tdeg.i then return jv
        "failed"

    variables(p : %) : L JB ==
        maxdeg : VN := new(nl, 0)
        while not zero? p repeat
            tdeg := degree p
            p := reductum p
            for i in 1..nl repeat
                maxdeg.i := max(maxdeg.i, tdeg.i)
        [jv  for jv in LJV  for i in 1..nl | maxdeg.i ~= 0]

    coerce(p : %) : OUT ==
        zero? p => 0$R ::OUT
        lt : L OUT := empty
        for t in reverse p repeat
            l : L OUT := empty
            for i in 1..nl repeat
                t.k.i = 0 => l
                t.k.i = 1 => l := cons(LJVO.i, l)
                l := cons(LJVO.i ^ t.k.i::OUT, l)
            l := reverse l
            if (t.c ~= 1) or empty? l then
                l := cons(t.c::OUT, l)
            if #l = 1 then
                lt := cons(first l, lt)
            else
                lt := cons(reduce("*", l), lt)
        #lt = 1 => first lt
        reduce("+", lt)

    -- --------------- --
    -- Transformations --
    -- --------------- --

    convert(p : JBP) : % ==
        (xx := mainVariable p) case "failed" =>
            cc : R := retract p
            cc::%
        x := xx::JB
        not member?(x, LJV) => error "illegal jet variable"
        up := univariate(p, x)
        res : % := 0
        while not zero? up repeat
            res := res + monomial(convert leadingCoefficient up, _
                                    x, degree up)
            up := reductum up
        res

    convert(p : %) : JBP ==
        (xx := mainVariable p) case "failed" =>
            cc : R := retract p
            cc::JBP
        x := xx::JB
        up := univariate(p, x)
        res : JBP := 0
        while not zero? up repeat
            res := res + monomial(convert leadingCoefficient up, _
                                    x, degree up)
            up := reductum up
        res

    const(p : %) : R ==
        not ground? p => error "not a constant"
        leadingCoefficient p

    retractIfCan(p : %) : Union(R, "failed") ==
        ground? p => leadingCoefficient p
        "failed"

    retract(p : %) : R == const p

    univariate(p : %, jv : JB) : SUP(%) ==
        zero? p => 0
        exp := degree p
        j := lookup jv
        deg : NNI := 0
        nexp := directProduct([if j = i then (deg := exp.i; 0) else exp.i _
                                for i in 1..nl]$VN)
        monomial(monomial(leadingCoefficient p, nexp), deg) + _
            univariate(reductum p, jv)

    univariate(p : %) : SUP(R) ==
        pv := mainVariable(p)$%
        pv case "failed" => monomial(leadingCoefficient p, 0)
        up := univariate(p, pv::JB)
        res : SUP(R) := 0
        while not zero? up repeat
            res := res + monomial(const leadingCoefficient up, degree up)
            up := reductum up
        res

    multivariate(p1 : SUP(%), jv : JB) : % ==
        zero? p1 => 0
        zero? degree p1 => leadingCoefficient p1
        leadingCoefficient(p1)*(jv::%)^degree(p1) + _
          multivariate(reductum p1, jv)

    multivariate(p : SUP(R), jv : JB) : % ==
        zero? p => 0
        leadingCoefficient(p)*monomial(1, jv, degree p) + _
            multivariate(reductum p, jv)

    -- ------- --
    -- Degrees --
    -- ------- --

    totalDegree p ==
        zero? p => 0
        "max"/[reduce("+", (t.k)::VN, 0)  for t in p]

    degree(p : %, jv : JB) : NNI == degree(univariate(p, jv))

    degree(p : %, ljv : L JB) : L NNI == [degree(p, jv)  for jv in ljv]

    minimumDegree(p : %, jv : JB) : NNI == minimumDegree(univariate(p, jv))

    minimumDegree(p : %, ljv : L JB) == [minimumDegree(p, jv)  for jv in ljv]

    -- ---------- --
    -- Evaluation --
    -- ---------- --

    eval(p : %, jv : JB, val : %) : % == univariate(p, jv)(val)

    eval(p : %, jv : JB, val : R) : % == eval(p, jv, val::%)$%

    eval(p : %, ljv : L JB, lval : L R) : % ==
        empty? ljv => p
        eval(eval(p, first ljv, (first lval)::%)$%, rest ljv, rest lval)$%

    evalSortedVarlist(p : %, Ljvar : L JB, Lpval : L %) : % ==
        -- assumes Lvar are sorted correctly
        -- local function
        j := mainVariable p
        j case "failed" => p
        pv := j::JB
        empty? Ljvar or empty? Lpval => p
        mvar := Ljvar.first
        mvar > pv => evalSortedVarlist(p, Ljvar.rest, Lpval.rest)
        pval := Lpval.first
        pts : SUP(%) := map(x +-> evalSortedVarlist(x, Ljvar, Lpval),
                            univariate(p, pv))
        mvar = pv => pts(pval)
        multivariate(pts, pv)

    eval(p : %, Ljvar : L JB, Lpval : L %) : % ==
        nljvar : L JB := sort((x, y) +-> lookup(x) < lookup(y), Ljvar)
        nlpval :=
            Ljvar = nljvar => Lpval
            nlpval := [Lpval.position(mvar, Ljvar)  for mvar in nljvar]
        evalSortedVarlist(p, nljvar, nlpval)

    -- ----------- --
    -- Arithmetics --
    -- ----------- --

    differentiate(p : %, jv : JB) ==
        multivariate(differentiate(univariate(p, jv)), jv)

    if R has Field then
        p : % / r : R == inv(r) * p

    if R has GcdDomain then
        content(p : %) : R ==
            zero?(p) => 0
            "gcd"/[t.c  for t in p]

        if R has EuclideanDomain and not R has Field then
            gcd(p1 : %, p2 : %) : % == gcd(p1, p2)$PGCD
        else
            gcd(p1 : %, p2 : %) : % ==
                r : R
                (pv1 := mainVariable(p1)) case "failed" =>
                    zero? (r := leadingCoefficient p1) => p2
                    gcd(r, content p2)::%
                (pv2 := mainVariable(p2)) case "failed" =>
                    zero? (r := leadingCoefficient p2) => p1
                    gcd(r, content p1)::%
                pv1 < pv2 => gcd(p1, content univariate(p2, pv2))
                pv2 < pv1 => gcd(p2, content univariate(p1, pv1))
                multivariate(gcd(univariate(p1, pv1), univariate(p2, pv2)), pv1)

        groebner(lp : L %) : L % ==
            print(message("groebner$DJBP"))$OUT
            groebner(lp)$GBP


