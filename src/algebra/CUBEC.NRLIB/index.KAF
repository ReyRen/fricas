9267                (|FiniteCubicalComplex| VS)
|domain|
(((|FiniteCubicalComplex| |#1|)
  (|Join| (|SetCategory|)
          (CATEGORY |domain|
           (SIGNATURE |cubicalComplex|
            ($ (|List| |#1|) (|List| (|CubicalFacet|))))
           (SIGNATURE |cubicalComplex|
            ($ (|List| |#1|) (|List| (|List| (|Segment| (|Integer|))))))
           (SIGNATURE |cubicalComplex|
            ($ (|List| |#1|) (|List| (|List| (|List| (|Integer|))))))
           (SIGNATURE |cubicalComplex| ($ (|List| |#1|)))
           (SIGNATURE |maxIndex| ((|NonNegativeInteger|) $))
           (SIGNATURE |addCube| ($ $ (|CubicalFacet|)))
           (SIGNATURE |grade| ((|List| (|List| (|CubicalFacet|))) $))
           (SIGNATURE |addImpliedFaces| ((|List| (|List| (|CubicalFacet|))) $))
           (SIGNATURE |product| ($ $ $))
           (SIGNATURE |fundamentalGroup| ((|GroupPresentation|) $))
           (SIGNATURE |fundamentalGroup|
            ((|GroupPresentation|) $ (|Boolean|) (|Boolean|)))
           (SIGNATURE |homology| ((|List| (|Homology|)) $))
           (SIGNATURE |boundary| ($ $))
           (SIGNATURE |chain| ((|ChainComplex|) $))
           (SIGNATURE |coerce| ((|DeltaComplex| |#1|) $))))
  (|AbelianGroup|))
 (T |FiniteCubicalComplex|))
(|Join| (|SetCategory|)
        (CATEGORY |domain|
         (SIGNATURE |cubicalComplex|
          ($ (|List| |#1|) (|List| (|CubicalFacet|))))
         (SIGNATURE |cubicalComplex|
          ($ (|List| |#1|) (|List| (|List| (|Segment| (|Integer|))))))
         (SIGNATURE |cubicalComplex|
          ($ (|List| |#1|) (|List| (|List| (|List| (|Integer|))))))
         (SIGNATURE |cubicalComplex| ($ (|List| |#1|)))
         (SIGNATURE |maxIndex| ((|NonNegativeInteger|) $))
         (SIGNATURE |addCube| ($ $ (|CubicalFacet|)))
         (SIGNATURE |grade| ((|List| (|List| (|CubicalFacet|))) $))
         (SIGNATURE |addImpliedFaces| ((|List| (|List| (|CubicalFacet|))) $))
         (SIGNATURE |product| ($ $ $))
         (SIGNATURE |fundamentalGroup| ((|GroupPresentation|) $))
         (SIGNATURE |fundamentalGroup|
          ((|GroupPresentation|) $ (|Boolean|) (|Boolean|)))
         (SIGNATURE |homology| ((|List| (|Homology|)) $))
         (SIGNATURE |boundary| ($ $)) (SIGNATURE |chain| ((|ChainComplex|) $))
         (SIGNATURE |coerce| ((|DeltaComplex| |#1|) $))))
"/git/fricas/src/algebra/CUBEC.spad"
((|cubicalComplex| (*1 *1 *2 *3)
  (AND (|isDomain| *2 (|List| *4)) (|isDomain| *3 (|List| (|CubicalFacet|)))
       (|ofCategory| *4 (|AbelianGroup|))
       (|isDomain| *1 (|FiniteCubicalComplex| *4))))
 (|cubicalComplex| (*1 *1 *2 *3)
  (AND (|isDomain| *2 (|List| *4))
       (|isDomain| *3 (|List| (|List| (|Segment| (|Integer|)))))
       (|ofCategory| *4 (|AbelianGroup|))
       (|isDomain| *1 (|FiniteCubicalComplex| *4))))
 (|cubicalComplex| (*1 *1 *2 *3)
  (AND (|isDomain| *2 (|List| *4))
       (|isDomain| *3 (|List| (|List| (|List| (|Integer|)))))
       (|ofCategory| *4 (|AbelianGroup|))
       (|isDomain| *1 (|FiniteCubicalComplex| *4))))
 (|cubicalComplex| (*1 *1 *2)
  (AND (|isDomain| *2 (|List| *3)) (|ofCategory| *3 (|AbelianGroup|))
       (|isDomain| *1 (|FiniteCubicalComplex| *3))))
 (|maxIndex| (*1 *2 *1)
  (AND (|isDomain| *2 (|NonNegativeInteger|))
       (|isDomain| *1 (|FiniteCubicalComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|addCube| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|CubicalFacet|))
       (|isDomain| *1 (|FiniteCubicalComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|grade| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|List| (|CubicalFacet|))))
       (|isDomain| *1 (|FiniteCubicalComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|addImpliedFaces| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|List| (|CubicalFacet|))))
       (|isDomain| *1 (|FiniteCubicalComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|product| (*1 *1 *1 *1)
  (AND (|isDomain| *1 (|FiniteCubicalComplex| *2))
       (|ofCategory| *2 (|AbelianGroup|))))
 (|fundamentalGroup| (*1 *2 *1)
  (AND (|isDomain| *2 (|GroupPresentation|))
       (|isDomain| *1 (|FiniteCubicalComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|fundamentalGroup| (*1 *2 *1 *3 *3)
  (AND (|isDomain| *3 (|Boolean|)) (|isDomain| *2 (|GroupPresentation|))
       (|isDomain| *1 (|FiniteCubicalComplex| *4))
       (|ofCategory| *4 (|AbelianGroup|))))
 (|homology| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|Homology|)))
       (|isDomain| *1 (|FiniteCubicalComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|boundary| (*1 *1 *1)
  (AND (|isDomain| *1 (|FiniteCubicalComplex| *2))
       (|ofCategory| *2 (|AbelianGroup|))))
 (|chain| (*1 *2 *1)
  (AND (|isDomain| *2 (|ChainComplex|))
       (|isDomain| *1 (|FiniteCubicalComplex| *3))
       (|ofCategory| *3 (|AbelianGroup|))))
 (|coerce| (*1 *2 *1)
           (AND (|isDomain| *2 (|DeltaComplex| *3))
                (|isDomain| *1 (|FiniteCubicalComplex| *3))
                (|ofCategory| *3 (|AbelianGroup|)))))
((~= (((|Boolean|) $ $) NIL)) (|product| (($ $ $) 50))
 (|maxIndex| (((|NonNegativeInteger|) $) 27)) (|latex| (((|String|) $) NIL))
 (|homology| (((|List| (|Homology|)) $) 60))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) NIL))
 (|hash| (((|SingleInteger|) $) NIL))
 (|grade| (((|List| (|List| (|CubicalFacet|))) $) 43))
 (|fundamentalGroup| (((|GroupPresentation|) $) 53)
  (((|GroupPresentation|) $ (|Boolean|) (|Boolean|)) 52))
 (|cubicalComplex| (($ (|List| |#1|) (|List| (|CubicalFacet|))) 10)
  (($ (|List| |#1|) (|List| (|List| (|Segment| (|Integer|))))) 17)
  (($ (|List| |#1|) (|List| (|List| (|List| (|Integer|))))) 21)
  (($ (|List| |#1|)) 22))
 (|coerce| (((|OutputForm|) $) 78) (((|DeltaComplex| |#1|) $) 79))
 (|chain| (((|ChainComplex|) $) 63)) (|boundary| (($ $) 36))
 (|addImpliedFaces| (((|List| (|List| (|CubicalFacet|))) $) 46))
 (|addCube| (($ $ (|CubicalFacet|)) 33)) (= (((|Boolean|) $ $) 70)))
CUBEC
(((|SetCategory|) . T))
(((|BasicType|) . T) ((|CoercibleTo| (|OutputForm|)) . T) ((|SetCategory|) . T))
((|constructor|
  (NIL
   "\\indented{2}{A Finite Cubical Complex} \\indented{2}{for more documentation see:} \\indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/cubical/} Date Created: April 2016 Basic Operations: Related packages: Related categories: Related Domains: Also See: AMS Classifications:"))
 (|coerce|
  (((|DeltaComplex| |#1|) $) "\\spad{coerce CubicalComplex} to DeltaComplex"))
 (|chain|
  (((|ChainComplex|) $)
   "returns a matrix sequence representing the face maps in linear algebra form"))
 (|boundary|
  (($ $)
   "Boundary operator. Step down to the next lower dimension,{} this is like hollowing out the complex. It takes the highest dimension entries and replaces them with their boundaries,{} cancelling out where it can."))
 (|homology|
  (((|List| (|Homology|)) $) "calculate homology using SmithNormalForm"))
 (|fundamentalGroup|
  (((|GroupPresentation|) $ (|Boolean|) (|Boolean|))
   "Generates fundamental group from this cubical complex. This works by converting to a DeltaComplex and then generating the fundamentalGroup from that. This is not the most efficient method because the conversion generates lots of higher order faceMaps which are not used. TODO write a faster implementation which only generates edge and square faceMaps. This version has options to: simplify - if \\spad{true} attempts to simplify the group presentation trace - if \\spad{true} outputs trace of simplification rules used.")
  (((|GroupPresentation|) $)
   "Generates fundamental group from this cubical complex. This works by converting to a DeltaComplex and then generating the fundamentalGroup from that. This is not the most efficient method because the conversion generates lots of higher order faceMaps which are not used. This will attempt to simplify the group presentation,{} if you don\\spad{'t} want this use alternative function of same name. TODO write a faster implemetation which only generates edge and square faceMaps."))
 (|product| (($ $ $) "Forms product of two cubical complexes."))
 (|addImpliedFaces|
  (((|List| (|List| (|CubicalFacet|))) $)
   "a function to take a set of faces and add those that are implied by the cubicalComplex conventions (if they don\\spad{'t} already exist). For example,{} if the input is a square [1..2,{} 1..2] then we would add its edges [1..1,{} 1..2],{} [2..2,{} 1..2],{} [1..2,{} 1..1],{} and [1..2,{} 2..2]."))
 (|grade|
  (((|List| (|List| (|CubicalFacet|))) $)
   "A function to grade faces according to the number of non-degenerate intervals. This nests the lists according to their order Vertices,{} edges,{} squares and so on."))
 (|addCube|
  (($ $ (|CubicalFacet|))
   "Add a facet to this simplex If the facet is also in the list then,{} dont append,{} instead change the multiplier."))
 (|maxIndex| (((|NonNegativeInteger|) $) "find the maximum index."))
 (|cubicalComplex| (($ (|List| |#1|)) "construct empty cubical complex")
  (($ (|List| |#1|) (|List| (|List| (|List| (|Integer|)))))
   "constructor where the cubes are supplied")
  (($ (|List| |#1|) (|List| (|List| (|Segment| (|Integer|)))))
   "constructor where the cubes are supplied")
  (($ (|List| |#1|) (|List| (|CubicalFacet|)))
   "constructor where the cubes are supplied")))
(("documentation" 0 6022) ("ancestors" 0 5941) ("parents" 0 5917)
 ("abbreviation" 0 5911) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 4989) ("modemaps" 0 2368) ("sourceFile" 0 2331)
 ("constructorCategory" 0 1260) ("constructorModemap" 0 57)
 ("constructorKind" 0 48) ("constructorForm" 0 20))