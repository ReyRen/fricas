)abbrev package RDEEFX2 ElementaryRischDEX2
++ Risch differential equation, wrapper for extended version.
ElementaryRischDEX2(R, F) : Exports == Implementation where
  R : Join(GcdDomain, Comparable, CharacteristicZero,
           PolynomialFactorizationExplicit,
           RetractableTo Integer, LinearlyExplicitOver Integer)
  F : Join(TranscendentalFunctionCategory, AlgebraicallyClosedField,
           FunctionSpace R)

  Z   ==> Integer
  SY  ==> Symbol
  LF  ==> List F
  UP  ==> SparseUnivariatePolynomial F
  PSOL2 ==> Record(ans : F, right : F, primpart : F, sol? : Boolean)
  Param_Rec_F ==> Record(ratpart : F, coeffs : Vector F)
  Partial_F ==> Union(Param_Rec_F, "failed")
  K ==> Kernel F

  Exports ==> with
    risch_de_ext : (Z, F, F, SY) -> PSOL2
         ++ risch_de_ext(n, f, g, x) returns \spad{[y, h, p, b]} such that
         ++ \spad{dy/dx + n df/dx y + exp(-nf)dp = h} and \spad{b := h = g}.
         ++ The equation \spad{dy/dx + n df/dx y = g} has no solution
         ++ if \spad{h \~~= g} (y is a partial solution in that case).
    do_risch_DE : (F, F, SY, List(K)) -> PSOL2
         ++ do_risch_DE(f, g, x, lk) returns \spad{[y, h, 0, b]}
         ++ such that \spad{dy/dx + df/dx y = h} and \spad{b := h = g}.
         ++ The equation \spad{dy/dx + df/dx y = g} has no solution
         ++ in the field generated by lk if \spad{h \~~= g}
         ++ (y is a partial solution in that case).
    do_param_RDE : (F, F, LF, SY, List(K)) -> Partial_F
         ++ do_param_RDE(f, h, lg, x, lk) solves parametric Risch
         ++ differential equation, that is returns \spad{[y, [c1, ..., ck]]}
         ++ such that dy/dx + n df/dx y + c1 g1 + ... cn gn = h
         ++ where y is in the is in field generated by lk and ci are
         ++ constants or "failed" if there is no solution.

  Implementation ==> add

    Q ==> Fraction(Z)
    L_Param_F ==> List Param_Rec_F
    Param_Rec_QF ==> Record(logands : List F, basis : List Vector Q)

    do_param_RDE(f : F, h : F, lg : LF, x : SY, lk : List(K)) : Partial_F ==
        ext := (x4 : List K, x3 : List F) : L_Param_F +->
                 extendedint(x, x4, x3
                            )$ParametricIntegration(R, F)
        logi := (x2 : List K, x3 : List F) : Param_Rec_QF +->
                  logextint(x, x2, x3
                           )$ParametricIntegration(R, F)
        res1 := param_rde(1, f, h, lg, x, lk, ext, logi
                         )$ParametricRischDE(R, F)
        res1.particular

    do_risch_DE(f : F, g : F, x : SY, lk : List(K)) : PSOL2 ==
        part := do_param_RDE(f, g, [], x, lk)
        part case "failed" =>
            [0, 0, 0, false]
        p1 := part::Param_Rec_F
        [p1.ratpart, g, 0, true]

    if R has EuclideanDomain and F has LiouvillianFunctionCategory
      and F has SpecialFunctionCategory then

        risch_de_ext(n, f, g, x) ==
            ei_int(n, f, g, x)$ElementaryRischDEX(R, F)

    else

        import from IntegrationTools(R, F)

        risch_de_ext(n, f, g, x) ==
            lk := varselect(union(tower(f), tower(g)), x)
            do_risch_DE(n*f, g, x, lk)

