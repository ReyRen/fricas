)abbrev package MAGCD2 ModularAlgebraicGcd2
++ Description: This package computes gcd over field of algebraic
++  functions over Q using modular method based on M. Monagan and
++  van Hoej paper.
++  Core modular operations are passed as parameter (MO) to this
++  package.  Similarly, evaluation functions are passed as
++  parameter ME.
ModularAlgebraicGcd2(PT : Type, MP : Type,
     MPT : Type, MD : Type,
     ME : ModularEvaluationCategory(PT, MP),
     MO : ModularAlgebraicGcdOperations(MP, MPT, MD)
     ) : Exports == Implementation where
  SY ==> Symbol
  RP ==> Polynomial Integer
  UPI ==> SparseUnivariatePolynomial Integer
  MPU ==> Polynomial UPI
  VI ==> Vector Integer
  PA ==> U32Vector
  PAI ==> PrimitiveArray Integer
  PSS1 ==> Record(prime : Integer, eval1coeffbuf : PA,
                 eval1expbuf : SortedExponentVector)
  PSS ==> Record(degx : Integer, degy : Integer, degg : Integer, _
                 sizem : Integer, sldeg : List(Integer), _
                 expdata : SortedExponentVector, coeffdata : PA, _
                 svx : SY, svz : List(SY), offsetdata : VI, pss1 : PSS1)
  PDR ==> Record(nvars : Integer, offsetdata : VI, _
               expdata : SortedExponentVector, _
               coeffdata : PA)

  Exports ==> with
    algebraicGcd : (PT, PT, List(PT), List SY, SY, List(SY)) -> RP
      ++ algebraicGcd(x, y, lm, lp, v, la) computes gcd of x and y
      ++ modulo polynomials in lm.  la is list of algebraic parameters,
      ++ lp is a list of transcendental parameters, v is main variable.

  Implementation ==> add

    algebraicGcd3a : (MP, MP, List(MP), List SY, PSS) -> RP
    algebraicGcd2 : (MP, MP, List(MP), List SY, PSS) -> Union(PDR, "failed")
    algebraicGcd1a : (MP, MP, MD, SY, List(SY)) -> Union(MPT, "failed")
    algebraicGcd1 : (MP, MP, List(MP), PSS) -> Union(PDR, "failed")

    algebraicGcd1a(x, y, mu, vx, lvz) ==
        xuu := MPtoMPT(x, vx, lvz, mu)
        xuu case "failed" => "failed"
        xu := xuu::MPT
        yuu := MPtoMPT(y, vx, lvz, mu)
        yuu case "failed" => "failed"
        yu := yuu::MPT
        repeat
            w1 := pseudoRem(xu, yu, mu)
            zero?(w1) =>
                return canonicalIfCan(yu, mu)
            xu := yu
            yu := w1

    VMR ==> VectorModularReconstructor
    IMODHP ==> InnerModularHermitePade
    PEVALUT ==> PolynomialEvaluationUtilities

    compare_coeff1(nv : Integer, exps : SortedExponentVector, _
                   nexps : SortedExponentVector) : Integer ==
        ne := #exps - nv
        nn := #nexps - nv
        for i in 0..(nv - 1) repeat
            nexps(nn + i) < exps(ne + i) => return -1
            nexps(nn + i) > exps(ne + i) => return 1
        0

    algebraicGcd1(x : MP, y : MP, lm : List(MP), pss : PSS
                 ) : Union(PDR, "failed") ==
        p := pss.pss1.prime
        vx := pss.svx
        lvz := pss.svz
        mdp := pack_modulus(lm, lvz, p)
        mdp case "failed" => "failed"
        mu := mdp::MD
        pres := algebraicGcd1a(x, y, mu, vx, lvz)
        pres case "failed" => "failed"
        res1 := pres::MPT
        dg := degree(res1)
        dg > pss.degg => "failed"
        msize := pss.sizem
        if dg < pss.degg then
            pss.degg := dg
            nsize := qcoerce((dg + 1)*msize)@NonNegativeInteger
            pss.expdata := pack_exps(dg, msize, mu)
            pss.coeffdata := new(nsize, 0)$PA
        repack1(res1, pss.coeffdata, dg, mu)
        offsets := pss.offsetdata
        [1, offsets, pss.expdata, pss.coeffdata]$PDR

    algebraicGcd2(x : MP, y : MP, lm : List(MP), lv : List SY, pss : PSS
                 ) : Union(PDR, "failed") ==
        nv := #lv
        nv = 0 => algebraicGcd1(x, y, lm, pss)
        pss1 := pss.pss1
        p := pss1.prime
        vx := pss.svx
        offsets := pss.offsetdata
        lt : List Integer := []
        rstate : VMR
        exps := empty()$SortedExponentVector
        dx := pss.degx
        dy := pss.degy
        dg := pss.degg
        vt := first(lv)
        nlv := rest(lv)
        nbv := #pss.svz
        good_cnt : Integer := 0
        bad_cnt : Integer := 0
        repeat
            t : Integer := random(p)
            member?(t, lt) => "iterate"
            lt := cons(t, lt)
            xt := eval1(x, vt, t, pss1)$ME
            yt := eval1(y, vt, t, pss1)$ME
            lmt := [eval1(m, vt, t, pss1)$ME for m in lm]
            lcbad : Boolean := false
            for m in lmt for deg in pss.sldeg for z in pss.svz repeat
                if degree(m, z) < deg then lcbad := true
            lcbad or (degree(xt, vx) < dx or degree(yt, vx) < dy) =>
                bad_cnt := bad_cnt + 1
                bad_cnt > good_cnt + 2 => return "failed"
            gtfp := algebraicGcd2(xt, yt, lmt, nlv, pss)
            gtfp case "failed" =>
                bad_cnt := bad_cnt + 1
                bad_cnt > good_cnt + 2 => return "failed"
            gtf := gtfp::PDR
            nexps := gtf.expdata
            coeffs := gtf.coeffdata
            pss.degg = 0 => return
                [nv + nbv + 1, new(1, 0), new(nv + nbv + 1, 0), new(1, 1)]
            if pss.degg < dg or empty?(exps) then
                exps := nexps
                rstate := empty(#coeffs, pss1.prime)$VMR
                bad_cnt := 0
                good_cnt := 0
            if pss.degg < dg then dg := pss.degg
            (cc := compare_coeff1(nv + nbv, exps, nexps)) < 0 =>
                bad_cnt := bad_cnt + 1
                bad_cnt > good_cnt + 2 => return "failed"
            dl := merge_exponents(nv + nbv, offsets, exps, offsets,
                                   nexps)$IMODHP
            odl := dl(1)
            ndl := dl(2)
            if odl ~= [] then
                oer := merge2(nv + nbv, odl, ndl, offsets, exps, _
                              offsets, nexps)$IMODHP
                exps := oer.expdata
                -- need reset in case of change of leading exponent
                ncc := #exps quo (nv + nbv)
                rstate := empty(ncc::NonNegativeInteger, p)$VMR
                good_cnt := 0
            if ndl ~= [] then
                -- expand coeffs
                n0 := #coeffs
                nn := #ndl
                n1 := n0 + nn
                ncoeffs := new(n1, 0)$PA
                i : Integer := 0
                jl := first ndl
                for j in 0..(n1 - 1) repeat
                    j = jl =>
                        ncoeffs(j) := 0
                        ndl := rest ndl
                        jl :=
                            empty?(ndl) => n1
                            first ndl
                    ncoeffs(j) := coeffs(i)
                    i := i + 1
                coeffs := ncoeffs

            chinese_update(coeffs, t, rstate)$VMR
            good_cnt := good_cnt + 1

            -- try reconstruction
            pp := reconstruct(rstate, nv + nbv, offsets, _
                              offsets, exps)$VMR
            pp case "failed" => "iterate"
            -- if succesful return
            return pp::PDR

    base_vars : List Symbol := ['u0, 'u1, 'u2, 'u3, 'u4, 'u5, 'u6, _
              'u7, 'u8, 'u9, 'v0, 'v1, 'v2, 'v3, 'v4, 'v5, 'v6, 'v7, _
              'v8, 'v9, 'w0, 'w1, 'w2, 'w3, 'w4, 'w5, 'w6, 'w7, 'w8, 'w9]

    alg_vars : List Symbol := ['p0, 'p1, 'p2, 'p3, 'p4, 'p5, 'p6, _
              'p7, 'p8, 'p9, 'q0, 'q1, 'q2, 'q3, 'q4, 'q5, 'q6, 'q7, _
              'q8, 'q9, 'r0, 'r1, 'r2, 'r3, 'r4, 'r5, 'r6, 'r7, 'r8, 'r9]

    param_vars : List Symbol := ['a0, 'a1, 'a2, 'a3, 'a4, 'a5, 'a6, _
              'a7, 'a8, 'a9, 'b0, 'b1, 'b2, 'b3, 'b4, 'b5, 'b6, 'b7, _
              'b8, 'b9, 'c0, 'c1, 'c2, 'c3, 'c4, 'c5, 'c6, 'c7, 'c8, 'c9]

    VIR ==> VectorIntegerReconstructor

    reconstruct3(lv : List SY, vx : SY, lvz : List(SY),
                 exps : SortedExponentVector, pp : PAI) : RP ==
        nlv := concat(lv, reverse(lvz))
        pres := unpack_poly(nlv, exps, pp, 0, #pp - 1)$ModularHermitePade()
        multivariate(pres, vx) pretend RP

    algebraicGcd3a(x : MP, y : MP, lm : List(MP), lv : List SY, pss : PSS
                  ) : RP ==
        lp : List Integer := []
        rstate : VIR
        dx := pss.degx
        dy := pss.degy
        dg := pss.degg
        vx := pss.svx
        pss1 := pss.pss1
        lvz := pss.svz
        nbv := #lvz + 1
        nv := #lv
        offsets := pss.offsetdata
        exps : SortedExponentVector := empty()
        repeat
            p := (nextPrime$IntegerPrimesPackage(Integer))(random(1000000)
                    +500000)
            member?(p, lp) => 0
            lp := cons(p, lp)
            pss1.prime := p
            xp := modpreduction(x, p)$ME
            yp := modpreduction(y, p)$ME
            (degree(xp, vx) < dx) and (degree(yp, vx) < dy) => "iterate"
            lmp := [modpreduction(m, p)$ME for m in lm]
            lcbad : Boolean := false
            for m in lmp for deg in pss.sldeg for z in lvz repeat
                if degree(m, z) < deg then lcbad := true
            lcbad => "iterate"
            gtpp := algebraicGcd2(xp, yp, lmp, lv, pss)
            gtpp case "failed" => "iterate"
            gtp := gtpp::PDR
            nexps := gtp.expdata
            coeffs := gtp.coeffdata
            if pss.degg < dg or empty?(exps) then
                exps := nexps
                rstate := empty(#coeffs)
            if pss.degg < dg then
                dg := pss.degg
            dl := merge_exponents(nv + nbv, offsets, exps, offsets,
                                   nexps)$IMODHP
            odl := dl(1)
            ndl := dl(2)
            if odl ~= [] then
                oer := merge2(nv + nbv, odl, ndl, offsets, exps, _
                              offsets, nexps)$IMODHP
                offsets := oer.offsetdata
                exps := oer.expdata
                -- need reset in case of change of leading exponent
                ncc := #exps quo (nv + nbv)
                rstate := empty(ncc::NonNegativeInteger)$VIR
            if ndl ~= [] then
                -- expand coeffs
                n0 := #coeffs
                nn := #ndl
                n1 := n0 + nn
                ncoeffs := new(n1, 0)$PA
                i : Integer := 0
                jl := first ndl
                for j in 0..(n1 - 1) repeat
                    j = jl =>
                        ncoeffs(j) := 0
                        ndl := rest ndl
                        jl :=
                            empty?(ndl) => n1
                            first ndl
                    ncoeffs(j) := coeffs(i)
                    i := i + 1
                coeffs := ncoeffs

            chinese_update(coeffs, p, rstate)$VIR

            pp := reconstruct(rstate, offsets)$VIR
            pp case "failed" => "iterate"
            res := reconstruct3(lv, vx, lvz, exps, pp::PAI)
            if trial_division(x, res, lm, vx, lvz)$ME and
               trial_division(y, res, lm, vx, lvz)$ME then
                return res

    algebraicGcd(x, y, lm, lv, vx, lvz) ==
        n := #lv
        na := #lvz
        n > 30 => error "Too many variables"
        tv0 := first(param_vars, n)
        tvx := first base_vars
        tvz := reverse(first(alg_vars, na))
        tv := concat(tvz, tv0)
        tv := cons(tvx, tv)
        sv := cons(vx, concat(lvz, lv))
        nx := subst_vars(x, sv, tv)
        ny := subst_vars(y, sv, tv)
        nlm := [subst_vars(m, sv, tv) for m in lm]
        ldeg : List(Integer) := [ldegree(m, vz) for m in lm for vz in lvz]
        msize := reduce(_*, ldeg, 1)
        pss : PSS := [degree(nx, tvx), degree(ny, tvx), 0, msize, ldeg, _
                    empty(), empty(), tvx, tvz, [0]$VI, _
                    [0, new(10, 0)$PA, new(10, 0)$SortedExponentVector]$PSS1]
        -- Overestimate
        pss.degg := min(pss.degx, pss.degy) + 1
        ress := algebraicGcd3a(nx, ny, nlm, tv0, pss)
        sval := [monomial(1, v, 1) for v in sv]@List(RP)
        eval(ress, tv, sval)

