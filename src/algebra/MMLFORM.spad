)abbrev domain MMLFORM MathMLFormat
++ Author: Arthur C. Ralfs
++ Date: January 2007
++ This package is based on the TeXFormat domain by Robert S. Sutor
++ without which I wouldn't have known where to start.
++ Basic Operations: coerce, coerceS, coerceL, exprex, display
++ Description:
++    \spadtype{MathMLFormat} provides a coercion from \spadtype{OutputForm}
++    to MathML format.

MathMLFormat() : public == private where
  E      ==> OutputForm
  I      ==> Integer
  L      ==> List
  S      ==> String
  Sy     ==> Symbol
  US     ==> UniversalSegment(Integer)

  public == SetCategory with
    coerce :    E -> S
      ++ coerce(o) changes o in the standard output format to MathML
      ++ format.
    coerceS :   E -> S
      ++ coerceS(o) changes o in the standard output format to MathML
      ++ format and displays formatted result.
    coerceL :   E -> S
      ++ coerceL(o) changes o in the standard output format to MathML
      ++ format and displays result as one long string.
    exprex :    E -> S
      ++ exprex(o) converts \spadtype{OutputForm} to \spadtype{String}
      ++ with the structure preserved with braces.  Actually this is
      ++ not quite accurate.  The function \spadfun{precondition} is first
      ++ applied to the
      ++ \spadtype{OutputForm} expression before \spadfun{exprex}.
      ++ The raw \spadtype{OutputForm} and
      ++ the nature of the \spadfun{precondition} function is
      ++ still obscure to me
      ++ at the time of this writing (2007-02-14).
    display :   S -> Void
      ++ prints the string returned by coerce, adding <math ...> tags.

  private == add
    import from OutputForm
    import from Character
    import from Integer
    import from List OutputForm
    import from List String
    import from OutputFormTools

    sayMsg ==> say$DisplayPackage

    -- local variable declarations and definitions

    expr : E
    prec, opPrec : I
    str :  S
    blank         : S := " \  "

    maxPrec       : I   := 1000000
    minPrec       : I   := 0

    unaryOps      : L Sy := ["-"::Sy]$(L Sy)
    unaryPrecs    : L I := [710]$(L I)

    -- the precedence of / in the following is relatively low because
    -- the bar obviates the need for parentheses.
    binaryOps     : L Sy := ["+->"::Sy, "|"::Sy, "^"::Sy, "/"::Sy, "="::Sy,
                             "~="::Sy, "<"::Sy, "<="::Sy, ">"::Sy, ">="::Sy,
                               'OVER, 'LET]
    binaryPrecs   : L I := [0, 0, 900, 700, 400,
                            400, 400, 400, 400, 400,
                              700, 125]$(L I)

    naryOps       : L Sy := ["-"::Sy, "+"::Sy, "*"::Sy, ","::Sy, ";"::Sy,
                             'ROW, 'STRSEP, 'TENSOR]
    naryPrecs     : L I := [700, 700, 800, 110, 110,
                            0, 0, 850]$(L I)
    naryNGOps     : L Sy := ['ROW]

    plexOps       : L Sy := ['SIGMA, 'SIGMA2, 'PI, 'PI2, 'INTSIGN]
    plexPrecs     : L I := [ 750, 750, 750, 750, 700]$(L I)

    specialOps    : L Sy := ['MATRIX, 'BRACKET, 'BRACE, 'CONCATB, 'VCONCAT,  _
                             'AGGLST, 'CONCAT, 'OVERBAR, 'ROOT, 'SUB, 'TAG, _
                             'SUPERSUB, 'ZAG, 'AGGSET, 'SC, 'PAREN, _
                             'SEGMENT, 'QUOTE, 'theMap, 'SLASH, 'PRIME, _
                             'BOX, 'EQUATNUM, 'BINOMIAL, 'NOTHING]

    -- the next two lists provide translations for some strings for
    -- which MML provides special macros.

    specialStrings : L Sy :=
      ['cos, 'cot, 'csc, 'log, 'sec, 'sin, 'tan,
        'cosh, 'coth, 'csch, 'sech, 'sinh, 'tanh,
          'acos, 'asin, 'atan, 'erf, "..."::Sy, "$"::Sy, 'infinity,
            'Gamma]
    specialStringsInMML : L S :=
      ["<mo>cos</mo>","<mo>cot</mo>","<mo>csc</mo>","<mo>log</mo>","<mo>sec</mo>","<mo>sin</mo>","<mo>tan</mo>",
        "<mo>cosh</mo>","<mo>coth</mo>","<mo>csch</mo>","<mo>sech</mo>","<mo>sinh</mo>","<mo>tanh</mo>",
          "<mo>arccos</mo>","<mo>arcsin</mo>","<mo>arctan</mo>","<mo>erf</mo>","<mo>&#x2026;</mo>","<mo>$</mo>","<mo>&#x221E;</mo>","<mo>&#x0413;</mo>"]

    -- local function signatures

    addBraces :      S -> S
    addBrackets :    S -> S
    displayElt :     S -> Void
      ++ function for recursively displaying mathml nicely formatted
    eltLimit :       (S, I, S) -> I
      ++ demarcates end postion of mathml element with name: S starting at
      ++ position i: I in mathml string s: S and returns end of end tag as
      ++  i: I position in mathml string, i.e. find start and end of
      ++  substring:  <name ...>...</name>
    eltName :        (I, S) -> S
      ++ find name of mathml element starting at position i: I in string s: S
    group :          S -> S
    formatBinary :   (Sy, L E, I) -> S
    formatFunction : (E, L E, I) -> S
    formatMatrix :   L E -> S
    formatNary :     (Sy, S, I, L E, I) -> S
    formatNaryNoGroup : (Sy, S, I, L E, I) -> S
    formatNullary :  Sy -> S
    formatPlex :     (Sy, L E, I) -> S
    formatSpecial :  (Sy, L E, I) -> S
    formatUnary :    (Sy, E, I) -> S
    formatExpr :      (E, I) -> S

    formatPrime : (L E, I) -> S
    formatSub :      (E, L E, I) -> S
    formatSuperSub : (E, L E, I) -> S
    newWithNum :     I -> %
    parenthesize :   S -> S

    postcondition :  S -> S
      -- this function is applied after all other OutputForm -> MathML
      -- transformations.  In the TexFormat domain the ungroup function
      -- first peels off the outermost set of braces however I have
      -- replaced braces with <mrow>s here and sometimes the outermost set
      -- of <mrow>s is necessary to get proper display in Firefox.  For
      -- instance with getting the correct size of brackets on a matrix
      -- the whole expression needs to be enclosed in a mrow element.
      --  It also checks for +- and removes the +.

    stringify :      E -> S
    tagEnd :         (S, I, S) -> I
      ++  finds closing ">" of start or end tag for mathML element
    ungroup :        S -> S

    -- public function definitions

    coerce(expr : E) : S ==
      s : S := postcondition formatExpr(precondition expr, minPrec)
      s

    sayExpr(s : S) : Void ==
        sayMathML$Lisp s

    coerceS(expr : E) : S ==
        s : S := postcondition formatExpr(precondition expr, minPrec)
        sayExpr "<math xmlns=_"http://www.w3.org/1998/Math/MathML_" mathsize=_"big_" display=_"block_">"
        displayElt(s)
        sayExpr "</math>"
        s

    coerceL(expr : E) : S ==
        s : S := postcondition formatExpr(precondition expr, minPrec)
        sayExpr "<math xmlns=_"http://www.w3.org/1998/Math/MathML_" mathsize=_"big_" display=_"block_">"
        sayExpr s
        sayExpr "</math>"
        s

    display(mathml : S) : Void ==
        sayExpr "<math xmlns=_"http://www.w3.org/1998/Math/MathML_" mathsize=_"big_" display=_"block_">"
        sayExpr mathml
        sayExpr "</math>"
        void()$Void



    exprex(expr : E) : S ==
      -- This breaks down an expression into atoms and returns it as
      -- a string.  It's for developmental purposes to help understand
      -- the expressions.
      a : E
      expr := precondition expr
--      sayMsg "0: "stringify expr
      atom?(expr) or (stringify expr = "NOTHING") =>
        concat ["{",stringify expr,"}"]
      op := operator(expr)
      sop : S := exprex op
      args : L E := arguments(expr)
      nargs : I := #args
--      sayMsg concat ["1: ",stringify first le," : ",string(nargs)$S]
      s : S := concat ["{",sop]
      if nargs > 0  then
        for a in args repeat
--        sayMsg concat ["2: ",stringify a]
          s1 : S := exprex a
          s := concat [s, s1]
      s := concat [s,"}"]


    displayElt(mathML : S) : Void ==
      -- Takes a string of syntactically complete mathML
      -- and formats it for display.
--      sayMsg "****displayElt1****"
--      sayMsg mathML
      enT:I -- marks end of tag, e.g. "<name>"
      enE:I -- marks end of element, e.g. "<name> ... </name>"
      end : I -- marks end of mathML string
      u : US
      end := #mathML
      length : I := 60
--      sayMsg "****displayElt1.1****"
      name : S := eltName(1, mathML)
--      sayMsg name
--      sayMsg concat("****displayElt1.2****",name)
      enE := eltLimit(name, 2+#name, mathML)
--      sayMsg "****displayElt2****"
      if enE < length then
--        sayMsg "****displayElt3****"
        u := segment(1, enE)$US
        sayMsg mathML.u
      else
--        sayMsg "****displayElt4****"
        enT := tagEnd(name, 1, mathML)
        u := segment(1, enT)$US
        sayMsg mathML.u
        u := segment(enT+1, enE-#name-3)$US
        displayElt(mathML.u)
        u := segment(enE-#name-2, enE)$US
        sayMsg mathML.u
      if end > enE then
--        sayMsg "****displayElt5****"
        u := segment(enE+1, end)$US
        displayElt(mathML.u)

      void()$Void

    eltName(pos : I, mathML : S) : S ==
      -- Assuming pos is the position of "<" for a start tag of a mathML
      -- element finds and returns the element's name.
      i : I := pos+1
      --sayMsg "eltName:mathmML string: "mathML
      while member?(mathML.i, lowerCase()$CharacterClass)$CharacterClass repeat
         i := i+1
      u : US := segment(pos+1, i-1)
      name : S := mathML.u

    eltLimit(name : S, pos : I, mathML : S) : I ==
      -- Finds the end of a mathML element like "<name ...> ... </name>"
      -- where pos is the position of the space after name in the start tag
      -- although it could point to the closing ">".  Returns the position
      -- of the ">" in the end tag.
      pI : I := pos
      startI : I
      endI : I
      startS:S := concat ["<",name]
      endS:S := concat ["</",name,">"]
      level : I := 1
      --sayMsg "eltLimit: element name: "name
      while (level > 0) repeat
        startI := position(startS, mathML, pI)$String

        endI := position(endS, mathML, pI)$String

        if (startI = 0) then
          level := level-1
          --sayMsg "****eltLimit 1******"
          pI := tagEnd(name, endI, mathML)
        else
          if (startI < endI) then
            level := level+1
            pI := tagEnd(name, startI, mathML)
          else
            level := level-1
            pI := tagEnd(name, endI, mathML)
      pI


    tagEnd(name : S, pos : I, mathML : S) : I ==
      -- Finds the closing ">" for either a start or end tag of a mathML
      -- element, so the return value is the position of ">" in mathML.
      pI : I := pos
      while  (mathML.pI ~= char ">") repeat
        pI := pI+1
      u : US := segment(pos, pI)$US
      --sayMsg "tagEnd: "mathML.u
      pI

    ungroup(str : S) : S ==
      len : I := #str
      len < 14 => str
      lrow : S :=  "<mrow>"
      rrow : S :=  "</mrow>"
      -- drop leading and trailing mrows
      u1 : US := segment(1, 6)$US
      u2 : US := segment(len-6, len)$US
      if (str.u1 =$S lrow) and (str.u2 =$S rrow) then
        u : US := segment(7, len-7)$US
        str := str.u
      str

    postcondition(str : S) : S ==
--      str := ungroup str
      len : I := #str
      plusminus : S := "<mo>+</mo><mo>-</mo>"
      pos : I := position(plusminus, str, 1)
      if pos > 0 then
        ustart : US := segment(1, pos-1)$US
        uend : US := segment(pos+20, len)$US
        str := concat [str.ustart,"<mo>-</mo>",str.uend]
        if pos < len-18 then
          str := postcondition(str)
      str



    stringify expr == (mathObject2String$Lisp expr)@S

    optionalWrap(expr : E) : S ==
        tmp : S := formatExpr(expr, minPrec)
        tmp = "" or tmp = " " => "<none/>"
        concat ["<mrow>", tmp, "</mrow>"]

    group str ==
      concat ["<mrow>",str,"</mrow>"]

    addBraces str ==
      concat ["<mo>{</mo>",str,"<mo>}</mo>"]

    addBrackets str ==
      concat ["<mo>[</mo>",str,"<mo>]</mo>"]

    parenthesize str ==
      concat ["<mo>(</mo>",str,"<mo>)</mo>"]

    formatSpecial(op : Sy, args : L E, prec : I) : S ==
        arg : E
        prescript : Boolean := false
        op = 'theMap => "<mtext>theMap(...)</mtext>"
        op = 'AGGLST =>
            formatNary(","::Sy, "", 0, args, prec)
        op = 'AGGSET =>
            formatNary(";"::Sy, "", 0, args, prec)
        op = 'TAG =>
            group concat [formatExpr(first args, prec),
                          "<mo>&#x02192;</mo>",
                            formatExpr(second args, prec)]
                         --RightArrow
        op = 'SLASH =>
            group concat [formatExpr(first args, prec),
                          "<mo>/</mo>", formatExpr(second args,prec)]
        op = 'VCONCAT =>
            group concat ["<mtable><mtr>",
                          concat([concat ["<mtd>", formatExpr(u, minPrec),
                                          "</mtd>"] for u in args]::L S),
                            "</mtr></mtable>"]
        op = 'CONCATB =>
            formatNary('STRSEP, " ", 0, args, minPrec)
        op = 'CONCAT =>
            formatNary('STRSEP, "", 0, args, minPrec)
        op = 'QUOTE =>
            group concat("<mo>'</mo>", formatExpr(first args, minPrec))
        op = 'BRACKET =>
            group addBrackets ungroup formatExpr(first args, minPrec)
        op = 'BRACE =>
            group addBraces ungroup formatExpr(first args, minPrec)
        op = 'PAREN =>
            group parenthesize ungroup formatExpr(first args, minPrec)
        op = 'PRIME =>
            formatPrime(args, prec)
        op = 'OVERBAR =>
            empty?(args) => ""
            group concat ["<mover accent='true'><mrow>",
                          formatExpr(first args, minPrec),
                           "</mrow><mo stretchy='true'>&#x000AF;</mo></mover>"]
        op = 'ROOT =>
            empty?(args) => ""
            tmp : S := group formatExpr(first args, minPrec)
            empty?(rest(args)) => concat ["<msqrt>", tmp, "</msqrt>"]
            group concat ["<mroot><mrow>", tmp, "</mrow>",
                          formatExpr(first rest args, minPrec), "</mroot>"]
        op = 'SEGMENT =>
            tmp : S := concat [formatExpr(first args, minPrec), "<mo>..</mo>"]
            group
                empty?(rest(args)) => tmp
                concat [tmp, formatExpr(first rest args, minPrec)]
        op = 'SUB =>
            group concat ["<msub>", formatExpr(first args, minPrec),
                formatSpecial('AGGLST, rest args, minPrec), "</msub>"]
        op = 'SUPERSUB =>
            base : S := concat["<mrow>", formatExpr(first args, minPrec),
                               "</mrow>"]
            args := rest args
            n := #args
            n > 4 => error "multiscript object has more than 4 scripts"
            tmp1 := optionalWrap(args(1))
            n = 1 => concat ["<msub>", base, tmp1, "</msub>"]
            tmp2 := optionalWrap(args(2))
            n = 2 => concat ["<msubsup>", base, tmp1, tmp2, "</msubsup>"]
            tmp3 := optionalWrap(args(3))
            base := concat ["<mmultiscripts>", base, tmp1, tmp2,
                            "<mprescripts/>", tmp3]
            n = 3 => concat [base, "<none/></mmultiscripts>"]
            concat [base, optionalWrap(args(4)), "</mmultiscripts>"]
        op = 'SC =>
            -- need to handle indentation someday
            empty?(args) => ""
            tmp := formatNaryNoGroup('STRSEP, "</mtd></mtr><mtr><mtd>",
                                     800, args, minPrec)
            group concat ["<mtable><mtr><mtd>", tmp, "</mtd></mtr></mtable>"]
        op = 'MATRIX => formatMatrix rest args
        op = 'BOX =>
            empty?(args) => ""
            tmp := formatNaryNoGroup('STRSEP, "", 0, args, minPrec)
            group concat ["<mtable frame=_"solid_"><mtr><mtd>", tmp,
                          "</mtd></mtr></mtable>"]
        op = 'EQUATNUM =>
            concat ["<mtable><mtr><mtd>", formatExpr(args.1, minPrec),
                    "</mtd><mtd style=_"padding-left: 50px;_">",
                      formatExpr(args.2, minPrec), "</mtd></mtr></mtable>"]
        op = 'BINOMIAL =>
            -- binomial('f: OutputForm, 'z: OutputForm) produces
            -- (BINOMIAL f z)
            concat ["<mrow><mo stretchy=_"true_">(</mo>",
                    "<mfrac linethickness=_"0_">",
                      formatExpr(args.1, minPrec),
                        formatExpr(args.2, minPrec),
                          "</mfrac><mo>)</mo></mrow>"]
        op = 'NOTHING => "<none/>"
        op = 'ZAG =>
            concat ["<mtable><mtr><mtd style=_"border-right: solid 1px black;",
             " border-bottom: solid 1px black; padding-right: 2px;",
              " padding-left: 2px;_">", formatExpr(first args, minPrec),
               "</mtd></mtr><mtr><mtd style=_"border-left: solid 1px black;",
                 " padding-left: 2px; padding-right: 2px;_">",
                   formatExpr(first rest args, minPrec),
                     "</mtd></mtr></mtable>"]
        concat ["<mtext>not done yet for: ", string(op),"</mtext>"]

    -- this produces prime notation ordinary derivatives.
    formatPrime(args : L E, prec : I) : S ==
        arg2 := second(args)
        if string?(arg2) then
            commaS : S := string(arg2)
            commaTest : S := ","
            if position(commaTest, commaS, 1) > 0 then
               s : S := "<mo>&#x02032;</mo>"
               for i in 2..#commaS repeat
                   commaTest := commaTest","
                   s := s"<mo>&#x02032;</mo>"
               if commaS = commaTest then
                   arg2 := message(s)
        formatSpecial('SUPERSUB, [first args, " "::E, arg2], prec)

    formatPlex(op : Sy, args : L E, prec : I) : S ==
        p : I := position(op, plexOps)
        p < 1 => error "unknown plex op"
        opPrec := plexPrecs.p
        n : I := #args
        (n ~= 2) and (n ~= 3) => error "wrong number of arguments for plex"
        ops : S :=
            op = 'SIGMA =>
                -- sum(a::OutputForm, b::OutputForm) produces
                -- (SIGMA b a)
                n = 2 => "&Sum;"
                error "wrong number of arguments for plex"
            op = 'SIGMA2 =>
                 -- sum(a::OutputForm, b::OutputForm, c::OutputForm) produces
                 -- (SIGMA2 b c a)
                 n = 3 => "&Sum;"
                 error "wrong number of arguments for plex"
            op = 'PI =>
                -- prod(a::OutputForm, b::OutputForm) produces
                -- (PI b a)
                n = 2 =>  "&Pi;"
                error "wrong number of arguments for plex"
            op = 'PI2 =>
                -- prod(a::OutputForm, b::OutputForm, c::OutputForm) produces
                -- (PI2 b c a)
                n = 3 => "&Pi;"
                error "wrong number of arguments for plex"
            op = 'INTSIGN =>
                -- int(a::OutputForm) produces
                -- (INTSIGN NOTHING NOTHING a)
                -- int(a::OutputForm, b::OutputForm) produces
                -- (INTSIGN b NOTHING a)
                -- int(a::OutputForm, b::OutputForm, c::OutputForm) produces
                -- (INTSIGN b c a)
                n = 3 => "&int;"
                error "wrong number of arguments for plex"
            error "Unexpected plex op:" string(op)
        body :=
            op = 'INTSIGN =>
                formatExpr(args(3), minPrec)
            formatExpr(args(n), opPrec)
        t2 : S :=
            n = 3 => formatExpr(args.2, minPrec)
            "<none/>"
        t1 := formatExpr(args(1), minPrec)
        s := concat ["<munderover><mo>", ops, "</mo>", t1, t2, "</munderover>",
                     body]
        if opPrec < prec then s := parenthesize s
        group s

    formatMatrix(args : L E) : S ==
        -- format for args is [[ROW ...], [ROW ...], [ROW ...]]
        -- generate string for formatting columns (centered)
        group addBrackets concat
            ["<mtable><mtr><mtd>",
             formatNaryNoGroup('STRSEP, "</mtd></mtr><mtr><mtd>",
                               0, args, minPrec),
               "</mtd></mtr></mtable>"]

    formatFunction(op : E, args : L E, prec : I) : S ==
        ops := formatExpr(op, minPrec)
        group concat ["<mo>", ops, "</mo>",
                      parenthesize formatNary(","::Sy, "", 0, args, minPrec)]

    formatNullary(op : Sy) ==
        op = 'NOTHING => ""
        group concat ["<mo>", string(op), "</mo><mo>(</mo><mo>)</mo>"]

    formatUnary(op : Sy, arg : E, prec : I) ==
        p : I := position(op, unaryOps)
        p < 1 => error "unknown unary op"
        opPrec := unaryPrecs.p
        s : S := concat ["<mo>", string(op), "</mo>", formatExpr(arg, opPrec)]
        opPrec < prec => group parenthesize s
        op = "-"::Sy => s
        group s

    formatBinary(op : Sy, args : L E, prec : I) : S ==
        p : I := position(op, binaryOps)
        p < 1 => error "unknown binary op"
        opPrec := binaryPrecs.p
        s1 := formatExpr(first args, opPrec)
        s2 := formatExpr(first rest args, opPrec)
        s : S :=
            op = "^"::Sy => concat ["<msup><mrow>", s1, "</mrow><mrow>",
                                    s2, "</mrow></msup>"]
            op = "/"::Sy => concat ["<mfrac><mrow>", s1, "</mrow><mrow>",
                                    s2, "</mrow></mfrac>"]
            op = 'OVER => concat ["<mfrac><mrow>", s1, "</mrow><mrow>",
                                  s2, "</mrow></mfrac>"]
            ops : S :=
                op = 'LET => ":="
                op = "<"::Sy => "&lt;"
                op = "<="::Sy => "&lt;="
                string(op)
            concat ["<mrow>", s1, "</mrow><mo>", ops, "</mo><mrow>",
                    s2, "</mrow>"]
        group
            op = "/"::Sy or op = 'OVER => s
            opPrec < prec => parenthesize s
            s

    formatNary(op : Sy, sep : S, opprec : I, args : L E, prec : I) : S ==
        group formatNaryNoGroup(op, sep, opprec, args, prec)

    formatNaryNoGroup(op : Sy, sep : S, opprec : I, args : L E, prec : I) : S ==
        empty?(args) => ""
        p : I := position(op, naryOps)
        p < 1 => error "unknown nary op"
        ops : S :=
            op = 'STRSEP => sep
            op = "*"::Sy   => "<mo>&#x02062;</mo>"
            op = 'ROW      => "</mtd><mtd>"
            op = 'TENSOR => "<mo>&#x02297;</mo>"
            concat ["<mo>", string(op), "</mo>"]
        l : L S := []
        opPrec :=
            op = 'STRSEP => opprec
            naryPrecs.p
        for a in args repeat
            l := concat(ops, concat(formatExpr(a, opPrec), l)$L(S))$L(S)
        s : S := concat reverse rest l
        opPrec < prec => parenthesize s
        s

    formatExpr(expr : E, prec : I) : S ==
      i, len : Integer
      intSplitLen : Integer := 20
      atom?(expr) =>
        str := stringify expr
        len := #str
        -- this bit seems to deal with integers
        integer?(expr) =>
          i := integer(expr)
          if (i < 0) or (i > 9)
            then
              group
                 nstr : String := ""
                 -- insert some blanks into the string, if too long
                 while ((len := #str) > intSplitLen) repeat
                   nstr := concat [nstr, " ",
                     elt(str, segment(1, intSplitLen)$US)]
                   str := elt(str, segment(intSplitLen + 1)$US)
                 empty? nstr => concat ["<mn>", str, "</mn>"]
                 nstr :=
                   empty? str => nstr
                   concat [nstr, " ", str]
                 concat ["<mn>", elt(nstr, segment(2)$US), "</mn>"]
            else concat ["<mn>", str, "</mn>"]
        str = "%pi" => "<mi>&#x003C0;</mi>"
        -- pi
        str = "%e"  => "<mi>&#x02147;</mi>"
        -- ExponentialE
        str = "%i"  => "<mi>&#x02148;</mi>"
        -- ImaginaryI
        len > 0 and str.1 = char "%" => concat ["<mi>", str, "</mi>"]
        -- should handle floats
        len > 1 and digit? str.1 => concat ["<mn>", str, "</mn>"]
        -- presumably this is a literal string
        len > 0 and str.1 = char "_"" =>
          concat ["<mtext>", str, "</mtext>"]
        len = 1 and str.1 = char " " => " "
        if symbol?(expr) then
            op := symbol(expr)
            (i := position(op, specialStrings)) > 0 =>
                specialStringsInMML.i
        (i := position(char " ", str)) > 0 =>
          -- We want to preserve spacing, so use a roman font.
          concat ["<mtext>", str, "</mtext>"]
        -- if we get to here does that mean it's a variable?
        concat ["<mi>", str, "</mi>"]
      opf : E := operator(expr)
      args : L E := arguments(expr)
      nargs : I := #args

      symbol?(opf) =>
          op := symbol(opf)
          -- special cases
          member?(op, specialOps) => formatSpecial(op, args, prec)
          member?(op, plexOps)    => formatPlex(op, args, prec)

          -- nullary case
          0 = nargs => formatNullary op

          -- unary case
          (1 = nargs) and member?(op, unaryOps) =>
            formatUnary(op, first args, prec)

          -- binary case
          (2 = nargs) and member?(op, binaryOps) =>
            formatBinary(op, args, prec)

          -- nary case
          member?(op, naryNGOps) => formatNaryNoGroup(op, "", 0, args, prec)
          member?(op, naryOps) => formatNary(op, "", 0, args, prec)
          formatFunction(opf, args, prec)
      formatFunction(opf, args, prec)


--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
