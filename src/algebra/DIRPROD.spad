)abbrev domain DIRPROD DirectProduct
++ Author:
++ Basic Functions:
++ Related Constructors: Vector, IndexedVector
++ Also See: OrderedDirectProduct
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This type represents the finite direct or cartesian product of an
++ underlying component type. This contrasts with simple vectors in that
++ the members can be viewed as having constant length. Thus many
++ categorical properties can by lifted from the underlying component type.
++ Component extraction operations are provided but no updating operations.
++ Thus new direct product elements can either be created by converting
++ vector elements using the \spadfun{directProduct} function
++ or by taking appropriate linear combinations of basis vectors provided
++ by the \spad{unitVector} operation.

DirectProduct(dim : NonNegativeInteger, R : Type):
  DirectProductCategory(dim, R) == Vector R add

      Rep := Vector R

      coerce(z : %) : Vector(R)        == copy(z)$Rep pretend Vector(R)
      coerce(r : R) : %                == new(dim, r)$Rep

      parts x == VEC2LIST(x)$Lisp

      directProduct z ==
        size?(z, dim) => copy(z)$Rep
        error "Not of the correct length"

      if R has BasicType then
        same? : % -> Boolean
        same? z == (z1 := z(minIndex z); every?(x +-> x = z1, z))

        if R is NonNegativeInteger or R is Integer or R is PositiveInteger then
          -- This is a hack to gain speed.  Direct product is used
          -- by DistributedPolynomial and calling directly Lisp
          -- operation gives significant speedup.  Once compiler
          -- is smarter this hack will go away.
          x = y ==
            for i in 0..(dim - 1) repeat
                not EQL(QREFELT(x, i)$Lisp, QREFELT(y, i)$Lisp)$Lisp => return false
            true
        else
          x = y ==
            for i in 1..dim repeat
               not (qelt(x, i)$Rep = qelt(y, i)$Rep) => return false
            true
            -- _and/[qelt(x, i)$Rep = qelt(y, i)$Rep for i in 1..dim]

        retract(z : %) : R ==
          not(dim = 0) and same? z => z(minIndex z)
          error "Not retractable"

        retractIfCan(z:%):Union(R, "failed") ==
          not(dim = 0) and same? z => z(minIndex z)
          "failed"

      if R has Finite then
          index(n : PositiveInteger) : % ==
            N : Integer := size()$R
            p : Integer := n-1
            L : List R := [index(((p rem N) + 1)::PositiveInteger)$R]
            for i in 2..dim repeat
              p := p quo N
              L := cons(index(((p rem N) + 1)::PositiveInteger)$R, L)
            vector(L)
          random() == [random()$R for i in 1..dim]
          lookup(x) ==
            N : Integer := size()$R
            L : Integer := lookup(x.1)-1
            for i in 2..dim repeat
              L := L*N+lookup(x.i)-1
            (L+1)::PositiveInteger

      if R has AbelianMonoid then

        0 == zero(dim)$Vector(R) pretend %

      if R has SemiGroup then

        u : % * v : % == map(_*, u, v)$Rep

      if R has CancellationAbelianMonoid then
        tmp0 := new(dim, 0)$Rep

        subtractIfCan(u:%, v:%):Union(%,"failed") ==
          w := tmp0
          for i in 1..dim repeat
            (c := subtractIfCan(qelt(u, i)$Rep, qelt(v,i)$Rep)) case "failed" =>
                    return "failed"
            qsetelt!(w, i, c::R)$Rep
          copy(w)$Rep

      if R has Monoid then

        1 == new(dim, 1)$Vector(R) pretend %

        tmp1 := new(dim, 1)$Rep

        recip z ==
          w := tmp1
          for i in 1..dim repeat
            (u := recip qelt(z, i)) case "failed" => return "failed"
            qsetelt!(w, i, u::R)
          copy(w)$Rep

      if R has AbelianMonoid and R has Monoid then

        unitVector i ==
          v := new(dim, 0)$Vector(R)
          v.i := 1
          v pretend %

      if R has OrderedSet then

          -- Duplicated to gain speed via inlining of '<' in integer case.
          if R is NonNegativeInteger or R is Integer or
                                        R is PositiveInteger then
              x < y ==
                  for i in 0..(dim - 1) repeat
                      a : R := QREFELT(x, i)$Lisp
                      b : R := QREFELT(y, i)$Lisp
                      a < b => return true
                      b < a => return false
                  false
          else
              x < y ==
                  for i in 0..(dim - 1) repeat
                      a : R := QREFELT(x, i)$Lisp
                      b : R := QREFELT(y, i)$Lisp
                      a < b => return true
                      b < a => return false
                  false

      if R has OrderedAbelianMonoidSup then sup(x, y) == map(sup, x, y)


