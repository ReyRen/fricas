)abbrev domain MATRIX Matrix
++ Author: Grabmeier, Gschnitzer, Williamson
++ Date Created: 1987
++ Basic Operations:
++ Related Domains: IndexedMatrix, RectangularMatrix, SquareMatrix
++ Also See:
++ AMS Classifications:
++ Keywords: matrix, linear algebra
++ Examples:
++ References:
++ Description:
++   \spadtype{Matrix} is a matrix domain where 1-based indexing is used
++   for both rows and columns.
Matrix(R) : Exports == Implementation where
  R : AbelianMonoid
  Row ==> Vector R
  Col ==> Vector R
  mnRow ==> 1
  mnCol ==> 1
  MATLIN ==> MatrixLinearAlgebraFunctions(R, Row, Col, %)

  Exports ==> MatrixCategory(R, Row, Col) with
    diagonalMatrix : Vector R -> %
      ++ \spad{diagonalMatrix(v)} returns a diagonal matrix where the elements
      ++ of v appear on the diagonal.

    if R has ConvertibleTo InputForm then ConvertibleTo InputForm

    if R has IntegralDomain then
      invertIfCan : % -> Union(%,"failed")
        ++ \spad{invertIfCan(m)} returns the inverse of the matrix m.
        ++ If the matrix is not invertible, "failed" is returned.
        ++ Error: if the matrix is not square.
--     matrix: Vector Vector R -> %
--       ++ \spad{matrix(v)} converts the vector of vectors v to a matrix, where
--       ++ the vector of vectors is viewed as a vector of the rows of the
--       ++ matrix
--     diagonalMatrix: Vector % -> %
--       ++ \spad{diagonalMatrix([m1, ..., mk])} creates a block diagonal matrix
--       ++ M with block matrices {\em m1}, ..., {\em mk} down the diagonal,
--       ++ with 0 block matrices elsewhere.
--     vectorOfVectors: % -> Vector Vector R
--       ++ \spad{vectorOfVectors(m)} returns the rows of the matrix m as a
--       ++ vector of vectors

  Implementation ==>
   InnerIndexedTwoDimensionalArray(R, mnRow, mnCol, Row, Col) add
    minr ==> minRowIndex
    maxr ==> maxRowIndex
    minc ==> minColIndex
    maxc ==> maxColIndex
    mini ==> minIndex
    maxi ==> maxIndex
    Qelt2 ==> QAREF2O$Lisp
    Qsetelt2 ==> QSETAREF2O$Lisp

    import from List(List(R))

    minRowIndex x == mnRow
    minColIndex x == mnCol

    -- qelt, qsetelt!, swapRows! and copy are logically unnecessary,
    -- but good for performance

    qelt(m, i, j) == Qelt2(m, i, j, mnRow@Integer, mnCol@Integer)
    qsetelt!(m, i, j, r) == Qsetelt2(m, i, j, r, mnRow@Integer, mnCol@Integer)

    swapRows!(x, i1, i2) ==
        (i1 < minRowIndex(x)) or (i1 > maxRowIndex(x)) or _
           (i2 < minRowIndex(x)) or (i2 > maxRowIndex(x)) =>
             error "swapRows!: index out of range"
        i1 = i2 => x
        for j in minColIndex(x)..maxColIndex(x) repeat
            t1 : R := Qelt2(x, i1, j, mnRow@Integer, mnCol@Integer)
            t2 : R := Qelt2(x, i2, j, mnRow@Integer, mnCol@Integer)
            Qsetelt2(x, i1, j, t2, mnRow@Integer, mnCol@Integer)
            Qsetelt2(x, i2, j, t1, mnRow@Integer, mnCol@Integer)
        x

    copy m ==
        ans : % := MAKE_MATRIX(nrows m, ncols m)$Lisp
        for i in minRowIndex(m)..maxRowIndex(m) repeat
            for j in minColIndex(m)..maxColIndex(m) repeat
                qsetelt!(ans, i, j, qelt(m, i, j))
        ans

    if R has CommutativeRing then

        determinant x == determinant(x)$MATLIN
        minordet    x == minordet(x)$MATLIN

    if R has EuclideanDomain then

        rowEchelon  x == rowEchelon(x)$MATLIN

    if R has IntegralDomain then

        rank        x == rank(x)$MATLIN
        nullity     x == nullity(x)$MATLIN
        nullSpace   x == nullSpace(x)$MATLIN

    if R has Field then

        inverse     x == inverse(x)$MATLIN

    if R has IntegralDomain then

        invertIfCan(x) == invertIfCan(x)$MATLIN

--     matrix(v: Vector Vector R) ==
--       (rows := # v) = 0 => new(0, 0, 0)
--       -- error check: this is a top level function
--       cols := # v.mini(v)
--       for k in (mini(v) + 1)..maxi(v) repeat
--         cols ~= # v.k => error "matrix: rows of different lengths"
--       ans := new(rows, cols, 0)
--       for i in minr(ans)..maxr(ans) for k in mini(v)..maxi(v) repeat
--         vv := v.k
--         for j in minc(ans)..maxc(ans) for l in mini(vv)..maxi(vv) repeat
--           ans(i, j) := vv.l
--       ans

    diagonalMatrix(v : Vector R) ==
      n := #v; ans := zero(n, n)
      for i in minr(ans)..maxr(ans) for j in minc(ans)..maxc(ans) _
          for k in mini(v)..maxi(v) repeat qsetelt!(ans, i, j, qelt(v, k))
      ans

--     diagonalMatrix(vec: Vector %) ==
--       rows : NonNegativeInteger := 0
--       cols : NonNegativeInteger := 0
--       for r in mini(vec)..maxi(vec) repeat
--         mat := vec.r
--         rows := rows + nrows mat; cols := cols + ncols mat
--       ans := zero(rows, cols)
--       loR := minr ans; loC := minc ans
--       for r in mini(vec)..maxi(vec) repeat
--         mat := vec.r
--         hiR := loR + nrows(mat) - 1; hiC := loC + nrows(mat) - 1
--         for i in loR..hiR for k in minr(mat)..maxr(mat) repeat
--           for j in loC..hiC for l in minc(mat)..maxc(mat) repeat
--             ans(i, j) := mat(k, l)
--         loR := hiR + 1; loC := hiC + 1
--       ans

--     vectorOfVectors x ==
--       vv : Vector Vector R := new(nrows x, 0)
--       cols := ncols x
--       for k in mini(vv)..maxi(vv) repeat
--         vv.k := new(cols, 0)
--       for i in minr(x)..maxr(x) for k in mini(vv)..maxi(vv) repeat
--         v := vv.k
--         for j in minc(x)..maxc(x) for l in mini(v)..maxi(v) repeat
--           v.l := x(i, j)
--       vv

    if R has ConvertibleTo InputForm then
      convert(x : %) : InputForm ==
         convert [convert('matrix)@InputForm,
                  convert listOfLists x]$List(InputForm)

