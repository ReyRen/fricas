)abbrev domain WGRPH WeightedGraph
++ Author: Martin Baker
++ Date Created: January 2012
++ Basic Operations:
++ Related Constructors:
++ Keywords: graph theory
++ Description: allows us to model weighted graphs
++ This graph assigns a weight to each arrow. This is used when
++ calculating say, lowest 'cost' routes.
++ An arrow with a higher weight is more 'costly'
++ in some way and therefore we try to choose the minimum weight.
++ For arrows in series the overall weight is the sum of the individual
++ weights.
++ For arrows in parallel the overall weight is the minimum of the
++ individual weights.
++ I may change this in future to allow different cost metrics to
++ be plugged in.
++
++ References:
++ http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/graph/

WeightedGraph(S, W) : Exports == Implementation where

 S : SetCategory
 W : OrderedAbelianMonoid
 WEIGHT ==> Union(W,"disjoint")
 NNI==> NonNegativeInteger
 OBJT ==> Record(value : S, posX : NNI, posY : NNI)
 ARROW ==> Record(name : String, arrType : NNI, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)
 -- represent the graph in this domain
 WOBJT ==> Record(value : S, posX : NNI, posY : NNI, weight : W)
 WARROW ==> Record(name : String, weight : W, fromOb : NNI, _
           toOb : NNI, xOffset : Integer, yOffset : Integer, map : List NNI)
 SPROD ==> Product(S, S)
 GRPHPROD ==> WeightedGraph(SPROD, W)
 OBJTPROD ==> Record(value : SPROD, posX : NNI, posY : NNI, weight : W)
 DF ==> DoubleFloat
 PT ==> SCartesian(2)
 x<<y ==> hconcat(x::OutputForm,y::OutputForm)

 Exports ==> FiniteGraph(S) with

  weightedGraph : (ob : List S) -> %
    ++ constructor for graph with given list of
    ++ object names. Use this version of the constructor
    ++ if you don't intend to create diagrams and therefore don't
    ++ care about x, y coordinates.
    ++ more objects and arrows can be added later if required.
  weightedGraph : (ob : List WOBJT) -> %
    ++ constructor for graph with given objects
    ++ more objects and arrows can be added later if required.
  weightedGraph : (ob : List WOBJT, ar : List WARROW) -> %
    ++ weightedGraph(ob, ar) constructs graph with objects on and arrows ar.
    ++ More objects and arrows can be added later if required.
  weightedGraph : (ob : List OBJT, ar : List ARROW) -> %
    ++ constructor for graph with given objects and arrows
    ++ more objects and arrows can be added later if required.
  weightedGraph : (obs : List S,
                   ars : List(Record(fromOb : NNI, toOb : NNI))) -> %
    ++ weightedGraph(obs, ars) constructs graph with objects obs
    ++ and arrows ars. This constructor just has pure abstract graph
    ++ information without decoration information.
  weightedGraph : (poset : FinitePoset(S)) -> %
    ++ weightedGraph(poset) constructs graph from a partially
    ++ ordered set. This will be a graph with, at most, one arrow
    ++ between any two nodes.
  weightedGraph : (ob : List S, am : List List NNI) -> %
    ++ constructor for graph with given objects and adjacency
    ++ matrix.
  addWArrow! : (s : %, name : String, n1 : NNI, n2 : NNI, w : W) -> %
    ++ addWArrow!(s, name, n1, n2, w) adds a weighted arrow to the graph s,
    ++ where name is name of the arrow, w is weight of the arrow,
    ++ n1 is starting point of the arrow, n2 is endpoint of the arrow.
  distanceWeighted : (s : %, a : NNI, b : NNI) -> WEIGHT
    ++ the shortest distance between 'a' and 'b' in terms of
    ++ weight.
  routeNodeWeight : (s : %, r : List NNI) -> W
    ++ the cumulative weight of a given route. The route is given
    ++ in terms of a sequence of node indexes.
  routeArrowWeight : (s : %, r : List NNI) -> W
    ++ the cumulative weight of a given route. The route is given
    ++ in terms of a sequence of arrow indexes.
  "*":(%,%) -> GRPHPROD
    ++ tensor product : the tensor product G*H of graphs G and H is
    ++ a graph such that the vertex set of G*H is the Cartesian
    ++ product V(G) \times V(H); and any two vertices (u, u') and (v, v')
    ++ are adjacent in G \times H if and only if u' is adjacent with
    ++ v' and u is adjacent with v.
  cartesian : (%, %) -> GRPHPROD
    ++ Cartesian product: the vertex set of G o H is the Cartesian
    ++ product V(G) \times V(H) and any two vertices (u, u') and (v, v')
    ++  are adjacent in G o H if and only if either
    ++ u = v and u' is adjacent with v' in H, or
    ++ u' = v' and u is adjacent with v in G.
  closedTensor : (a : %, b : %, f : (S, S)->S) -> %
    ++ as tensor product but returns %.
  closedCartesian : (a : %, b : %, f : (S, S)->S) -> %
    ++ as Cartesian product but returns %.
  weightedDistanceMatrix : (%) -> TwoDimensionalArray WEIGHT
    ++ The elements of the returned array will represent the
    ++ distance weights between vertices.
    ++ if there is no connection between the vertices then the
    ++ element will be set to "disjoint"
  coerce : (poset : FinitePoset(S)) -> %
    ++ coerce FinitePoset to graph

 Implementation ==> add

  -- The representation consists of 2 Lists:
  --
  -- Vertices (or objects or nodes)
  -- ------------------------------
  -- This table has an entry for each vertex:
  -- Record(value: S, posX: NNI, posY: NNI)
  -- posX and posY are not part of the mathematical structure but
  -- are useful so that it can be drawn in a useful way.
  -- Although this is thought of as a set (no duplication or ordering)
  -- it is implemented as a list because entries in this table are
  -- indexed by the following part so the order of the objects can't
  -- be changed unless the index numbers in the following tables are
  -- changed.
  --
  -- Arrows (or edges)
  -- -----------------
  -- This table has an entry for each arrow:
  -- Record(name: String, weight: OrderedAbelianMonoid, fromOb: NNI,
  --     toOb: NNI, xOffset: Integer, yOffset: Integer)
  -- fromOb and toOb are the endpoints of the arrow which are
  -- indexes into the vertex list.
  -- weight is used for routing
  -- name, xOffset and yOffset are used to draw the graph.
  Rep := Record(_
        objects : List WOBJT, _
        arrows : List WARROW_
        )

  -- constructor for graph with given list of
  -- object names. Use this version of the constructor
  -- if you don't intend to create diagrams and therefore don't
  -- care about x, y coordinates.
  -- more objects and arrows can be added later if required.
  weightedGraph(ob : List S) : % ==
    objs : List WOBJT := [[x, 0::NNI, 0::NNI, 0$W] for x in ob]
    [objs, []]

  -- constructor for graph with given objects
  -- more objects and arrows can be added later if required.
  weightedGraph(ob : List WOBJT) : % ==
    [ob, []]

  -- constructor for graph with given objects and arrows
  -- more objects and arrows can be added later if required.
  weightedGraph(ob : List WOBJT, ar : List WARROW) : % ==
    [ob, ar]

  -- constructor for graph with given objects and arrows
  -- more objects and arrows can be added later if required.
  weightedGraph(ob : List OBJT, ar : List ARROW) : % ==
    arrs : List WARROW := []
    for a in ar repeat
      arro : WARROW := [a.name, 0$W, a.fromOb, a.toOb, a.xOffset, a.yOffset, a.map]
      arrs := concat(arrs, arro)
    fobs : List WOBJT := []
    for f in ob for fn in 1..#ob repeat
      fo : WOBJT := [f.value, f.posX, f.posY, 0$W]
      fobs := concat(fobs, fo)
    [fobs, arrs]

  -- weightedGraph(obs, ars) constructs graph with objects obs
  -- and arrows ars. This constructor just has pure abstract graph information
  -- without decoration information.
  weightedGraph(obs : List S, ars : List(Record(fromOb : NNI, toOb : NNI))
               ) : % ==
      nodes := empty()$List(OBJT)
      for ob in obs for obn in 1..#(obs) repeat
          -- build nodes (objects)
          o : OBJT := [ob, createX(#obs, obn), createY(#obs, obn)]
          nodes := concat(nodes, o)
      edges := empty()$List(ARROW)
      for ar in ars for arn in 1..#(ars) repeat
          -- build edges (arrows)
          edges := concat(edges, [concat("a", string(arn)), 0::NNI,
             ar.fromOb, ar.toOb, 0::Integer, 0::Integer, []])$List(ARROW)
      weightedGraph(nodes, edges)

  -- weightedGraph(poset) constructs graph from a partially
  -- ordered set. This will be a graph with, at most, one arrow
  -- between any two nodes.
  weightedGraph(poset : FinitePoset(S)) : % ==
      obs : List(S) := getVert(poset)$FinitePoset(S)
      ars := []$List(Record(fromOb : NNI, toOb : NNI))
      mat : List(List(Boolean)) := getArr(poset)$FinitePoset(S)
      for x in mat for xn in 1..#mat repeat
          for y in x for yn in 1..#x repeat
              if y then
                  z : Record(fromOb : NNI, toOb : NNI) := [xn,yn]
                  ars := concat(ars, z)$List(Record(fromOb : NNI, toOb : NNI))
      weightedGraph(obs, ars)

  -- constructor for graph with given objects and adjacency
  -- matrix.
  weightedGraph(objs : List S, am : List List NNI) : % ==
    obs : List WOBJT := []
    for obn in 1..#(objs) repeat
      -- build objects
      ob := objs.obn
      o : WOBJT := [ob, createX(#objs, obn), createY(#objs, obn), 0$W]
      obs := concat(obs, o)
    ar : List WARROW := []
    for i in 1..#am repeat
      for j in 1..#(am.i) repeat
        if (am.i).j = 1 then
          a : WARROW := ["a",0$W,i,j,0::Integer,0::Integer,[]]
          ar := concat(ar, a)
    [obs, ar]

  -- adds an object to this graph
  -- Use this version
  -- if you don't intend to create diagrams and therefore don't
  -- care about x, y coordinates.
  addObject!(s : %, n : S) : % ==
    obs : List WOBJT := s.objects
    obj : WOBJT := [n, 0::NNI, 0::NNI, 0$W]
    if obs = []
      then s.objects := [obj]
      else s.objects := concat(obs, obj)
    s

  -- adds an object to this graph
  addObject!(s : %, n : OBJT) : % ==
    error "this form of addObject! not supported in multifunctionGraph"
    [[], []]

  -- Here only to implement FiniteGraph, not very useful as it has zero weight
  addArrow!(s : %, ar: ARROW) : % ==
      addWArrow!(s,ar.name, ar.fromOb, ar.toOb, 0$W)

  -- included only for compatibility with FiniteGraph
  -- adds an arrow with zero weight
  addArrow!(s : %, nm : String, n1 : NNI, n2 : NNI) : % ==
    addWArrow!(s, nm, n1, n2, 0$W)

  -- adds an arrow to this graph, where:
  -- s is the graph where the arrow is to be added
  -- nm is the name of the arrow
  -- n1 is the index of the start object
  -- n2 is the index of the end object
  -- w is the weight of the arrow
  addWArrow!(s : %, nm : String, n1 : NNI, n2 : NNI, w : W) : % ==
    arrss : List WARROW := s.arrows
    a : WARROW := [nm, w, n1, n2, 0::Integer, 0::Integer, []]
    if empty?(arrss)
      then
        s.arrows := [a]
        return s
      else
        arrs : List WARROW := concat(arrss, a)
        s.arrows := arrs
        return s

  -- returns a list of all the vertices (or objects)
  getVertices(s : %) : List OBJT ==
    res : List OBJT := []
    for soj in s.objects repeat
      o : OBJT := [soj.value, soj.posX, soj.posY]
      res := concat(res, o)
    res

  -- returns a list of all the arrows (or edges)
  -- does not contain weight information
  getArrows(s : %) : List ARROW ==
    arrs : List ARROW := []
    for a in s.arrows repeat
      aw : ARROW := [a.name, 0::NNI, a.fromOb, a.toOb, _
                     a.xOffset, a.yOffset, a.map]
      arrs := concat(arrs, aw)
    arrs

  -- constructs a graph without vertices or edges
  initial() : % ==
    [[], []]

  -- constructs a graph with a single vertex and a single loop
  terminal(a : S) : % ==
    o : WOBJT := [a, 0::NNI, 0::NNI, 0$W]
    ar : WARROW := ["loop",0$W,1::NNI,1::NNI,0::Integer,0::Integer,[]]
    [[o], [ar]]

  -- constructs a graph with objects given connected in a
  -- cycle but with one gap.
  cycleOpen(objs : List S, arrowName : String) : % ==
    obs : List WOBJT := []
    ars : List WARROW := []
    arn : Integer := 1::NNI
    for obn in 1..#(objs) repeat
      -- build objects
      ob := objs.obn
      o : WOBJT := [ob, createX(#objs, obn), createY(#objs, obn), 0$W]
      obs := concat(obs, o)
      -- build arrows
      next : NNI := obn+1
      if next <= #(objs) then
        a : WARROW := [concat(arrowName, string(arn)), 0$W, obn, next, _
                      0::Integer, 0::Integer, []]
        ars := concat(ars, a)
        arn := arn + 1
    [obs, ars]

  -- constructs a graph with objects given connected in a
  -- cycle.
  cycleClosed(objs : List S, arrowName : String) : % ==
    obs : List WOBJT := []
    ars : List WARROW := []
    arn : Integer := 1::NNI
    for obn in 1..#(objs) repeat
      -- build objects
      ob := objs.obn
      o : WOBJT := [ob, createX(#objs, obn), createY(#objs, obn), 0$W]
      obs := concat(obs, o)
      -- build arrows
      next : NNI := obn+1
      if next-1 = #(objs) then next := 1::NNI
      if next <= #(objs) then
        a : WARROW := [concat(arrowName, string(arn)), 0$W, obn, next, _
                      0::Integer, 0::Integer, []]
        ars := concat(ars, a)
        arn := arn + 1
    [obs, ars]

  -- constructs a graph with objects given and arrows from
  -- each object only to itself.
  unit(objs : List S, arrowName : String) : % ==
    obs : List WOBJT := []
    ars : List WARROW := []
    arn : Integer := 1::NNI
    for obn in 1..#(objs) repeat
      -- build objects
      ob := objs.obn
      o : WOBJT := [ob, createX(#objs, obn), createY(#objs, obn), 0$W]
      obs := concat(obs, o)
      -- build arrows
      a : WARROW := [concat(arrowName, string(arn)), 0$W, obn, obn, _
                    0::Integer, 0::Integer, []]
      ars := concat(ars, a)
      arn := arn + 1
    [obs, ars]

  -- constructs a graph with objects given and fully connected
  -- arrows, that is, each object has an arrow to every other
  -- object except itself.
  kgraph(objs : List S, arrowName : String) : % ==
    obs : List WOBJT := []
    ars : List WARROW := []
    arn : Integer := 1::NNI
    for obn in 1..#(objs) repeat
      -- build objects
      ob := objs.obn
      o : WOBJT := [ob, createX(#objs, obn), createY(#objs, obn), 0$W]
      obs := concat(obs, o)
      -- build arrows
      for obm in 1..#(objs) repeat
       if obn ~= obm then
        a : WARROW := [concat(arrowName, string(arn)), 0$W, obn, obm, _
                      0::Integer, 0::Integer, []]
        ars := concat(ars, a)
        arn := arn + 1
    [obs, ars]

  -- sum : disjoint union of vertices with arrows from appropriate
  -- input
  _+(a, b) : % ==
    lo : List WOBJT := concat(a.objects, b.objects)
    bStart : NNI := #(a.objects)
    lb : List WARROW := []
    for ba in b.arrows repeat
      arr : WARROW := [ba.name, ba.weight, _
         ba.fromOb + bStart, ba.toOb + bStart, ba.xOffset, ba.yOffset, ba.map]
      lb := concat(lb, arr)$(List WARROW)
    la : List WARROW := concat(a.arrows, lb)
    [lo, la]

  -- sum : union (not necessarily disjoint) of vertices with arrows
  -- merged in from appropriate input, if arrow exists from both
  -- inputs then it will be duplicated.
  merge(a : %, b : %) : % ==
    -- bmap is a map into merged vertices
    bmap : List NNI := [x for x in 1..#a.objects] -- map does not change in a
    -- for each object in 'b' check if it exists in 'a' and if not add it
    newIndex : NNI := #a.objects
    mergedObjects := a.objects
    for bob in b.objects repeat
      i : Integer := position(bob, a.objects)
      if i<1
        then -- returns 0 if not found
          mergedObjects := concat(mergedObjects, bob)
          newIndex := newIndex + 1
          bmap := concat(bmap, newIndex)
        else
          bmap := concat(bmap, i::NNI)
    -- now merge arrows
    bStart : NNI := #(a.objects)
    lb : List WARROW := []
    for ba in b.arrows repeat
      -- map to and from indexes
      toI : NNI := bmap.(ba.toOb + bStart)
      fromI : NNI := bmap.(ba.fromOb + bStart)
      arr : WARROW := [ba.name, ba.weight, _
         fromI, toI, ba.xOffset, ba.yOffset, ba.map]
      lb := concat(lb, arr)$(List WARROW)
    la : List WARROW := concat(a.arrows, lb)
    [mergedObjects, la]

  -- this is a local function used by both tensor and Cartesian
  -- product to calculate the new vertices.
  objProd(a : %, b : %) : List OBJTPROD ==
    newObjs : List OBJTPROD := []
    for aoi in a.objects repeat
      ai : S := aoi.value
      axi : NNI := aoi.posX
      ayi : NNI := aoi.posY
      for boi in b.objects repeat
        bi : S := boi.value
        bxi : NNI := boi.posX
        byi : NNI := boi.posY
        x : NNI := bxi*diagramWidth(a)+axi
        y : NNI := byi*diagramHeight(a)+ayi
        widtha : NNI := diagramWidth(a)
        heighta : NNI := diagramHeight(a)
        sp : SPROD := construct(ai, bi)$SPROD
        ob : OBJTPROD := [sp, x, y, 0$W]
        newObjs := concat(newObjs, ob)
    newObjs

  -- this is a local function used by both tensor and Cartesian
  -- product to calculate the new index.
  indexProd(aObj : %, a : NNI, b : NNI) : NNI ==
    a + ((b::Integer-1)::NNI * #aObj.objects)

  -- tensor product : the tensor product A*B of graphs A and B is
  -- a graph such that the vertex set of A*B is the Cartesian
  -- product V(A) \times V(B)
  -- any two vertices <au, bu> and <av, bv> are adjacent in A \times B
  -- if and only if bu is adjacent with bv
  -- and au is adjacent with av.
  --
  -- So this is defined over S^2 (that is Product(S, S))
  _*(a : %, b : %) : GRPHPROD ==
    -- new objects are calculated by local objProd function
    -- calculate new arrows:
    newArrs : List WARROW := []
    for au in 1..#a.objects repeat
      for av in 1..#a.objects repeat
        for bu in 1..#b.objects repeat
          for bv in 1..#b.objects repeat
            if isDirectSuccessor?(a, au, av) and isDirectSuccessor?(b, bu, bv) then
              an:String := concat([arrowName(a,au,av),"*",arrowName(b,bu,bv)])
              arr : WARROW := [an, 0$W, _
                 indexProd(b, bu, au), _
                 indexProd(b, bv, av), 0::NNI, 0::NNI, []]
              newArrs := concat(newArrs, arr)$(List WARROW)
    weightedGraph(objProd(a, b), newArrs)$GRPHPROD

  -- Cartesian product: the vertex set of A o B is the Cartesian
  -- product V(A) \times V(B) and any two vertices <au, bu> and <av, bv>
  -- are adjacent in A o B if and only if either
  -- au = av and bu is adjacent with bv or
  -- bu = bv and au is adjacent with av.
  cartesian(a : %, b : %) : GRPHPROD ==
    -- new objects are calculated by local objProd function
    -- calculate new arrows:
    newArrs : List WARROW := []
    for au in 1..#a.objects repeat
      for av in 1..#a.objects repeat
        for bu in 1..#b.objects repeat
          for bv in 1..#b.objects repeat
            if ((bu = bv) and isDirectSuccessor?(a, au, av)) or _
               ((au = av) and isDirectSuccessor?(b, bu, bv)) then
              an : String := if (bu = bv) and isDirectSuccessor?(a, au, av)_
                    then concat([arrowName(a,au,av),"#",string(bv)])_
                    else concat([arrowName(b,bu,bv),"#",string(av)])
              arr : WARROW := [an, 0$W, _
                 indexProd(b, bu, au), _
                 indexProd(b, bv, av), 0::NNI, 0::NNI, []]
              newArrs := concat(newArrs, arr)$(List WARROW)
    weightedGraph(objProd(a, b), newArrs)$GRPHPROD

  -- this is a local function used by both closed tensor and closed
  -- Cartesian product to calculate the new vertices.
  closedObjProd(a : %, b : %, f : (S, S)->S) : List WOBJT ==
    newObjs : List WOBJT := []
    for aoi in a.objects repeat
      ai : S := aoi.value
      axi : NNI := aoi.posX
      ayi : NNI := aoi.posY
      for boi in b.objects repeat
        bi : S := boi.value
        bxi : NNI := boi.posX
        byi : NNI := boi.posY
        x : NNI := bxi*diagramWidth(a)+axi
        y : NNI := byi*diagramHeight(a)+ayi
        widtha : NNI := diagramWidth(a)
        heighta : NNI := diagramHeight(a)
        sp : S := f(ai, bi)
        ob : WOBJT := [sp, x, y, 0$W]
        newObjs := concat(newObjs, ob)
    newObjs


  -- as tensor product but returns %.
  closedTensor(a : %, b : %, f : (S, S)->S) : % ==
    -- new objects are calculated by local closedObjProd function
    -- calculate new arrows:
    newArrs : List WARROW := []
    for au in 1..#a.objects repeat
      for av in 1..#a.objects repeat
        for bu in 1..#b.objects repeat
          for bv in 1..#b.objects repeat
            if isDirectSuccessor?(a, au, av) and isDirectSuccessor?(b, bu, bv) then
              an:String := concat([arrowName(a,au,av),"*",arrowName(b,bu,bv)])
              arr : WARROW := [an, 0$W, _
                 indexProd(b, bu, au), _
                 indexProd(b, bv, av), 0::NNI, 0::NNI, []]
              newArrs := concat(newArrs, arr)$(List WARROW)
    weightedGraph(closedObjProd(a, b, f), newArrs)

  -- as Cartesian product but returns %.
  closedCartesian(a : %, b : %, f : (S, S)->S) : % ==
    -- new objects are calculated by local closedObjProd function
    -- calculate new arrows:
    newArrs : List WARROW := []
    for au in 1..#a.objects repeat
      for av in 1..#a.objects repeat
        for bu in 1..#b.objects repeat
          for bv in 1..#b.objects repeat
            if ((bu = bv) and isDirectSuccessor?(a, au, av)) or _
               ((au = av) and isDirectSuccessor?(b, bu, bv)) then
              an : String := if (bu = bv) and isDirectSuccessor?(a, au, av)_
                    then concat([arrowName(a,au,av),"#",string(bv)])_
                    else concat([arrowName(b,bu,bv),"#",string(av)])
              arr : WARROW := [an, 0$W, _
                 indexProd(b, bu, au), _
                 indexProd(b, bv, av), 0::NNI, 0::NNI, []]
              newArrs := concat(newArrs, arr)$(List WARROW)
    weightedGraph(closedObjProd(a, b, f), newArrs)

  -- create a new graph by mapping from this one
  -- newOb should contain the new list of vertices.
  -- m should contain a NNI value for each vertex, this is the
  -- new index into newOb. It is allowed that newOb may contain
  -- less objects than s (for surjective mapping) or
  -- more objects than s (for injective mapping)
  map(s : %, m : List NNI, newOb : List S, offsetX : Integer, offsetY : Integer) : % ==
    newObjs : List WOBJT := [[o, 0::NNI, 0::NNI, 0$W] for o in newOb]
    for oi in 1..#(s.objects) repeat
      i := m.oi
      newObjs.i : WOBJT := [(newObjs.i).value, _
          ((((s.objects).oi).posX)+offsetX)::NNI, _
          ((((s.objects).oi).posY)+offsetY)::NNI, _
          0$W]
    newArrs : List WARROW := []
    for oldArrow in s.arrows repeat
      newArr : WARROW := [oldArrow.name, oldArrow.weight, _
                       m.(oldArrow.fromOb), m.(oldArrow.toOb), _
                       oldArrow.xOffset, oldArrow.yOffset, oldArrow.map]
      newArrs := concat(newArrs, newArr)
    [newObjs, newArrs]

  -- similar to map function but reverses the directions of
  -- the arrows
  mapContra(s : %, m : List NNI, newOb : List S, offsetX : Integer, offsetY : Integer) : % ==
    newObjs : List WOBJT := [[o, 0::NNI, 0::NNI, 0$W] for o in newOb]
    for oi in 1..#(s.objects) repeat
      i := m.oi
      newObjs.i : WOBJT := [(newObjs.i).value, _
          ((((s.objects).oi).posX)+offsetX)::NNI, _
          ((((s.objects).oi).posY)+offsetY)::NNI, _
          0$W]
    newArrs : List WARROW := []
    for oldArrow in s.arrows repeat
      newArr : WARROW := [oldArrow.name, oldArrow.weight, _
                       m.(oldArrow.toOb), m.(oldArrow.fromOb), _
                       oldArrow.xOffset, oldArrow.yOffset, oldArrow.map]
      newArrs := concat(newArrs, newArr)
    [newObjs, newArrs]

  -- local function used by route to give a route between a
  -- and b, track visited nodes to avoid infinite loop.
  routeNodeRecursive(s : %, a : NNI, b : NNI, visited : List NNI) : List NNI ==
   if #visited > #getVertices(s) then return []
   shortest : List NNI := []
   if a = b then
     return [a]
   if isDirectSuccessor?(s, a, b) then
     return [a, b]
   for arr in getArrows(s) repeat
     if isDirectSuccessor?(s, a, arr.fromOb) then
       d := routeNodeRecursive(s, arr.fromOb, b, concat(visited, a)$List(NNI))
       if shortest = []
         then
           shortest := d
         else if (d ~= []) and_
           routeNodeWeight(s, concat(a, d)) < routeNodeWeight(s, concat(a, shortest)) then
             shortest := d
   if shortest = [] then
     return []
   concat(a, shortest)

  -- the shortest route between 'a' and 'b' as a
  -- sequence of node indexes.
  -- overrides version in FiniteGraph as this version takes into account
  -- weightings
  -- [a] if  'a' = 'b'
  -- [] if it is not possible to go from 'a' to 'b'
  routeNodes(s : %, a : NNI, b : NNI) : List NNI == routeNodeRecursive(s, a, b, [])

  -- local function used by route to give a route between nodes 'a'
  -- and 'b', returns arrow indexes.
  -- track visited arrows to avoid infinite loop.
  routeArrowRecursive(s : %, a : NNI, b : NNI, visited : List NNI) : List NNI ==
   -- test for infinite loop
   if #visited > #getVertices(s) then return [0]
   shortest : List NNI := [0]
   if a = b then
     return []
   arrn := getArrowIndex(s, a, b)
   if arrn ~= 0 then
       return [arrn]
   aa : NNI := 0
   shortestFullPath : List NNI := [0]
   arrs := getArrows(s)
   for arr in arrs repeat
     if isDirectSuccessor?(s, a, arr.fromOb) then
       aa := getArrowIndex(s, a, arr.fromOb)
       d := routeArrowRecursive(s, arr.fromOb, b, concat(visited, a)$List(NNI))
       fullPath := concat(aa, d)
       if shortest = [0]
         then
           shortest := d
           shortestFullPath := fullPath
         else if (d ~= [0]) and_
           routeArrowWeight(s, fullPath) < routeArrowWeight(s, shortestFullPath) then
             shortest := d
             shortestFullPath := fullPath
   if shortest = [0] then
     return [0]
   shortestFullPath

  -- the shortest route between 'a' and 'b' as a
  -- sequence of arrow indexes.
  -- overrides version in FiniteGraph as this version takes into account
  -- weightings
  -- [] if  'a' = 'b'
  -- [0] if it is not possible to go from 'a' to 'b'
  routeArrows(s : %, a : NNI, b : NNI) : List NNI == routeArrowRecursive(s, a, b, [])

  -- the shortest distance between 'a' and 'b' in terms of
  -- weight.
  distanceWeighted(s : %, a : NNI, b : NNI) : WEIGHT ==
    r : List NNI := routeNodeRecursive(s, a, b, [])
    if #r = 0 then return "disjoint"
    routeNodeWeight(s, r)

  -- this is a local function used by routeNodeWeight. It returns
  -- the minimum weight between two adjacent node indexes.
  getWeightBetween(s : %, i1 : NNI, i2 : NNI) : W ==
    isDisjoint : Boolean := true
    res : W := 0$W
    arrs := s.arrows
    for arr in arrs repeat
      if isDisjoint
        then
          if (arr.fromOb = i1) and (arr.toOb = i2)
            then
              res := arr.weight
              isDisjoint := false
        else
          if (arr.fromOb = i1) and (arr.toOb = i2) and (arr.weight < res)
            then res := arr.weight
    res

  -- the cumulative weight of a given route. The route is given
  -- in terms of a sequence of node indexes.
  routeNodeWeight(s : %, r : List NNI) : W ==
    res : W := 0$W
    fst : Boolean := true
    lasti : NNI := 0
    for i in r repeat
      if not fst then
        w := getWeightBetween(s, lasti, i)
        res := res + w
      fst := false
      lasti := i
    res

  -- the cumulative weight of a given route. The route is given
  -- in terms of a sequence of arrow indexes.
  routeArrowWeight(s : %, r : List NNI) : W ==
    res : W := 0$W
    for i in r repeat
      a : WARROW := (s.arrows).i
      res := res + a.weight
    res

  -- The elements of the returned array will represent the
  -- distance weights between vertices.
  -- if there is no connection between the vertices then the
  -- element will be set to "disjoint"
  weightedDistanceMatrix(s : %) : TwoDimensionalArray WEIGHT ==
    n := # getVertices s
    m : TwoDimensionalArray := new(n, n, 0)
    for u in 1..n repeat
        for v in 1..n repeat
            qsetelt!(m, u, v, distanceWeighted(s, u, v))
    m

  -- coerce FinitePoset to graph
  coerce(poset : FinitePoset(S)) : % ==
      weightedGraph(poset)

--Copyright (c) 2012-2016, Martin J Baker.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of Martin J Baker. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

)if false
\eject
\begin{thebibliography}{99}
For more details see:
[1] Floyd's algorithm
\url{https://en.wikipedia.org/wiki/Floyd-Warshall_algorithm}
[2] Wiki page about 2-categories
\url{https://en.wikipedia.org/wiki/2-category}

\end{thebibliography}
\end{document}
)endif
