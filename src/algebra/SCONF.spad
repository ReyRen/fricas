)abbrev domain SCONF SConformal
++ Author: Martin Baker
++ Date Created: September 2010
++ Basic Operations: point, elt, setelt, copy, dimension, minIndex, maxIndex,
++ convert
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/prog/scratchpad/mycode/graph/
++ Description: an implementation of PointCategory to represent points and
++ vectors in n+2 dimensional conformal space based on n dimensional
++ Euclidean space.

SConformal(n) : Exports == Implementation where
  ++ Domain for representing points, vectors, subspaces and properties
  ++ of conformal space
  n : PositiveInteger
    ++ number of base dimensions (excluding point at infinity and point
    ++ at origin)
  PI ==> PositiveInteger
  DF ==> DoubleFloat
  --
  -- What I would like to do is be able to coerce to a CliffordAlgebra
  -- with a specific signature representing conformal space
  -- however Axiom does not allow a specific matrix to be
  -- created here.
  --bLin ==> squareMatrix([[1@DF, 0@DF, 0@DF, 0@DF], _
  --                     [0@DF, 1@DF, 0@DF, 0@DF], _
  --                     [0@DF, 0@DF, 1@DF, 0@DF], _
  --                     [0@DF, 0@DF, 0@DF, 1@DF]])
  --CA ==> CliffordAlgebra(4, DF, bLin)

  Exports == SPointCategory() with
    normalisePoint : (pt : %) -> %
      ++ normalised point has scalar value of one, if this is not the
      ++ case then scale values

    --coerce: % -> CA
    --coerce: CA -> %

  Implementation ==> add

    import from OutputForm

    dim := 2^(n+2)
      ++ the total dimension of all the grades from scalar up to
      ++ pseudoscalar

    z : %

    -- count of floating point numbers to represent a Clifford algebra
    -- number given by dim
    Rep := PrimitiveArray DF

    New ==> new(dim, 0$DF)$Rep

    -- spnt(a, b) constructs a 2D point defined by a and b
    -- of type DF
    -- z.1 is point at zero which is set to -1
    -- z.2 is point at infinity which is set to a^2 + b^2
    -- z.4 is a
    -- z.8 is b
    spnt(a : DF, b : DF) : % ==
      inf : DF := (a*a + b*b)*0.5::DF
      (z := New; z.1 := -1@DF; z.2 := inf; z.4 := a; z.8 := b; z)

    -- spnt(a, b, c) constructs a 3D point defined by a, b and c
    -- of type DF
    -- z.1 is point at zero which is set to -1
    -- z.2 is point at infinity which is set to a^2 + b^2
    -- z.4 is a
    -- z.8 is b
    -- z.16 is c
    spnt(a : DF, b : DF, c : DF) : % ==
      inf : DF := (a*a + b*b + c*c)*0.5::DF
      z := New; z.1 := -1@DF; z.2 := inf
      z.4 := a; z.8 := b
      if n>2 then z.16 := c
      z

    -- svec(a, b) constructs a 2D vector defined by a and b
    -- of type DF
    svec(a : DF, b : DF) : % ==
      (z := New; z.1 := 0@DF; z.2 := 0@DF; z.4 := a; z.8 := b; z)

    -- svec(a, b, c) constructs a 3D vector defined by a, b and c
    -- of type DF
    svec(a : DF, b : DF, c : DF) : % ==
      z := New; z.1 := 0@DF; z.2 := 0@DF
      z.4 := a; z.8 := b
      if n>2 then z.16 := c
      z

    -- min(a, b) returns a point whose value in each dimension is
    -- the minimum. So if a has the smallest x value and b has the
    -- smallest y value then the result will combine these. This is
    -- useful for constructing boundary boxes around sets of points.
    min(a : %, b : %) : % ==
      pt := New
      pt.8 := min(a.8, b.8)
      pt.4 := min(a.4, b.4)
      pt.2 := (pt.4*pt.4 + pt.8*pt.8)*0.5::DF
      pt.1 := -1@DF
      pt

    -- max(a, b) returns a point whose value in each dimension is
    -- the maximum. So if a has the largest x value and b has the
    -- largest y value then the result will combine these. This is
    -- useful for constructing boundary boxes around sets of points.
    max(a : %, b : %) : % ==
      pt := New
      pt.8 := max(a.8, b.8)
      pt.4 := max(a.4, b.4)
      pt.2 := (pt.4*pt.4 + pt.8*pt.8)*0.5::DF
      pt.1 := -1@DF
      pt

    dimension(p)== 2 -- dimension of base space

    -- Test for NaN (Not a Number)
    -- That is have we divided by zero or taken sqrt of negative number at
    -- some stage?
    -- Common Lisp does not support NaN ? So we need some sort of test for
    -- invalid numbers
    -- If not equal to itself then we assume that its not a valid number
    nan?(x : DF) : Boolean == x ~= x

    -- Is this a valid point? if any of its elements are not valid
    -- then return true
    -- Examples of invalid floating point numbers are when have we
    -- have divided a given element by zero or taken
    -- sqrt of negative number at some stage?
    -- Note: we can still represent a point at infinity and we can
    -- represent points using complex numbers, but we do this using
    -- projective or conformal space or by using the appropriate
    -- instance of SPointCategory, not by using invalid floating
    -- point numbers.
    Pnan?(p : %) : Boolean ==
      for i in 0..(dim-1) repeat
        if nan?(p.i) then return true
      false

    -- scale until length is 1
    unitVector(p : %) : % ==
      factor := sqrt(p.4*p.4 + p.8*p.8)
      pt := New
      pt.4 := p.4/factor
      pt.8 := p.8/factor
      pt.2 := (pt.4*pt.4 + pt.8*pt.8)*0.5::DF
      pt.1 := -1@DF
      pt

    -- returns the distance between the points p1 and p2
    -- there are 2 metrics associated with any SPointCategory
    -- the underlying space and the space that it is embedded in
    -- this is the distance in the underlying space.
    distanceSquared(p1 : %, p2 : %) : DF ==
      1@DF

    -- This returns the length of the parallel component of two vectors
    -- in the case of Euclidean space this is the dot product of two
    -- vectors. We use this function to test the colinearity
    parallel(x : %, y : %) : DF == x.6 * y.6 + x.10 * y.10

    -- This returns a vector perpendicular to the two vectors
    -- in the case of 3D Euclidean space this is the cross product of the
    -- two vectors. We use this function to compute orthogonal
    perpendicular(x : %, y : %) : % ==
      pt := New
      pt.4 := 0@DF
      pt.8 := 1@DF
      pt.2 := (pt.4*pt.4 + pt.8*pt.8)*0.5::DF
      pt.1 := -1@DF
      pt

    -- scalar multiplication
    _*(s : DF, x : %) : % ==
      pt := New
      pt.4 := x.4 * s
      pt.8 := x.8 * s
      pt.2 := (pt.4*pt.4 + pt.8*pt.8)*0.5::DF
      pt.1 := -1@DF
      pt

    -- addition
    _+(x : %, y : %) : % ==
      pt := New
      pt.4 := x.4 + y.4
      pt.8 := x.8 + y.8
      pt.2 := (pt.4*pt.4 + pt.8*pt.8)*0.5::DF
      pt.1 := -1@DF
      pt

    -- subtraction
    _-(x : %, y : %) : % ==
      pt := New
      pt.4 := x.4 - y.4
      pt.8 := x.8 - y.8
      pt.2 := (pt.4*pt.4 + pt.8*pt.8)*0.5::DF
      pt.1 := -1@DF
      pt

    -- return true if param is inside bounding box
    -- where bounding box is specified by min and max
    inBounds?(pt : %, mns : %, mxs : %) : Boolean ==
     -- left of box - check minimum x
      qelt(pt, 4) < qelt(mns, 4) => false
      -- right of box - check maximum x
      qelt(pt, 4) > qelt(mxs, 4) => false
      -- below box - check minimum y
      qelt(pt, 8) < qelt(mns, 8) => false
      -- above box - check maximum y
      qelt(pt, 8) > qelt(mxs, 8) => false
      -- inside box so return true
      true

   -- returns the 'x'(left to right) screen coordinate
    screenCoordX(pt : %) : DF == pt.4

    -- returns the 'y'(bottom to top) screen coordinate
    screenCoordY(pt : %) : DF == pt.8

    -- returns the 'z'(out from screen) screen coordinate
    screenCoordZ(pt : %) : DF == if n>2 then pt.16 else 0@DF

    -- returns screen coordinates as a list
    screenCoords(pt : %) : List DF ==
      if n>2 then return [pt.4, pt.8, pt.16]
      [pt.4, pt.8]

    -- returns extended coordinates as a list
    extendedCoords(pt : %) : List DF == entries(pt)

    -- normalalised point has scalar value of one, if this is not the
    -- case then scale values
    normalisePoint(pt : %) : % ==
      scaleFactor : DF := pt.1
      if scaleFactor < 0.01::DF and scaleFactor > -0.01::DF then
        print message("can't apply normalisePoint to a vector")
        return pt
      if scaleFactor < -0.99::DF and scaleFactor > -1.01::DF then
        return pt
      pt2 := New
      infin := 0@DF
      for x in 1..n repeat
        index := 2^(x+1)
        pt2.index := pt.index / (-scaleFactor)
        infin := infin + ((pt2.index)*(pt2.index))*0.5::DF
      pt2.1 := -1@DF
      pt2.2 := infin
      pt2


    -- toPoint(p) returns a Point with the same coordinates as p
    -- If p was originally a vector then that will be treated as the
    -- distance from the origin.
    toPoint(p : %) ==
      pt := New
      for i in 0..(dim-1) repeat pt.i := p.i
      pt.1 := -1$DF
      pt

    -- toVector returns a Vector with the same coordinates as p
    -- If p was originally a point then the vector will be the
    -- distance from the origin.
    toVector(p : %) ==
      pt := New
      for i in 0..(dim-1) repeat pt.i := p.i
      pt.1 := 0$DF
      pt

    -- isPoint?(p) returns true if this represents a point as
    -- opposed to a vector.
    isPoint?(p : %) == p.1 < -0.1::DF

    -- isVector? returns true if this represents a vector as
    -- opposed to a point.
    isVector?(p : %) == p.1 > -0.9::DF

--    coerce(me: %): C ==
--      multivector(extendedCoords(me))$C

--    coerce(cmpx: C): % ==
--      [real(cmpx), imag(cmpx)]

    -- start of SetCategory definitions --

    hash(s : %) : SingleInteger == 0$SingleInteger

    -- returns true if x equals y
    _=(x : %, y : %) : Boolean ==
      for i in 0..(dim-1) repeat
        if x.i ~= y.i then return false
      true

    -- returns true if x is not equal to y
    _~_=(x : %, y : %) : Boolean == not(x = y)

    -- output
    coerce(pt : %) : OutputForm ==
      eles : List OutputForm := [(pt.i)::OutputForm for i in 0..(dim-1)]
      paren(eles)

)if false

\section{SceneIFS domain}
Many of the functions here are from NumericTubePlot and related
packages. However I needed them to be defined over SPointCategory
so I adapted them here.
)endif

