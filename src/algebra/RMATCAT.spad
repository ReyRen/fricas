)abbrev category RMATCAT RectangularMatrixCategory
++ Authors: Grabmeier, Gschnitzer, Williamson
++ Date Created: 1987
++ Basic Operations:
++ Related Domains: RectangularMatrix(m, n, R)
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
++   \spadtype{RectangularMatrixCategory} is a category of matrices of fixed
++   dimensions.  The dimensions of the matrix will be parameters of the
++   domain.  Domains in this category will be R-modules and will be
++   non-mutable.
RectangularMatrixCategory(m, n, R, Row, Col) : Category == Definition where
  m, n : NonNegativeInteger
  R   : Join(SemiRng, AbelianMonoid)
  Row : DirectProductCategory(n, R)
  Col : DirectProductCategory(m, R)

  Definition ==> Join(BiModule(R, R), HomogeneousAggregate(R), _
      finiteAggregate) with

    if R has Finite then Finite

    if R has CommutativeRing then Module(R)

--% Matrix creation

    matrix : List List R -> %
      ++ \spad{matrix(l)} converts the list of lists l to a matrix, where the
      ++ list of lists is viewed as a list of the rows of the matrix.

--% Predicates

    square?  : % -> Boolean
      ++ \spad{square?(m)} returns true if m is a square matrix (i.e. if m
      ++ has the same number of rows as columns) and false otherwise.
    diagonal? : % -> Boolean
      ++ \spad{diagonal?(m)} returns true if the matrix m is square and diagonal
      ++ (i.e. all entries of m not on the diagonal are zero) and false
      ++ otherwise.
    symmetric? : % -> Boolean
      ++ \spad{symmetric?(m)} returns true if the matrix m is square and
      ++ symmetric (i.e. \spad{m[i, j] = m[j, i]} for all \spad{i} and j) and
      ++ false otherwise.
    if R has AbelianGroup then
        antisymmetric? : % -> Boolean
          ++ \spad{antisymmetric?(m)} returns true if the matrix m is
          ++ square and antisymmetric (i.e. \spad{m[i, j] = -m[j, i]} for
          ++ all i and j) and false otherwise.

    antisymmetric? : % -> Boolean
      ++ \spad{antisymmetric?(m)} returns true if the matrix m is square and
      ++ antisymmetric (i.e. \spad{m[i, j] = -m[j, i]} for all \spad{i} and j)
      ++ and false otherwise.

--% Size inquiries

    minRowIndex : % -> Integer
      ++ \spad{minRowIndex(m)} returns the index of the 'first' row of the
      ++ matrix m.
    maxRowIndex : % -> Integer
      ++ \spad{maxRowIndex(m)} returns the index of the 'last' row of the
      ++ matrix m.
    minColIndex : % -> Integer
      ++ \spad{minColIndex(m)} returns the index of the 'first' column of the
      ++ matrix m.
    maxColIndex : % -> Integer
      ++ \spad{maxColIndex(m)} returns the index of the 'last' column of the
      ++ matrix m.
    nrows : % -> NonNegativeInteger
      ++ \spad{nrows(m)} returns the number of rows in the matrix m.
    ncols : % -> NonNegativeInteger
      ++ \spad{ncols(m)} returns the number of columns in the matrix m.

--% Part extractions

    listOfLists : % -> List List R
      ++ \spad{listOfLists(m)} returns the rows of the matrix m as a list
      ++ of lists.
    elt : (%, Integer, Integer) -> R
      ++ \spad{elt(m, i, j)} returns the element in the \spad{i}th row and
      ++ \spad{j}th column of the matrix m.
      ++ Error: if indices are outside the proper
      ++ ranges.
    qelt : (%, Integer, Integer) -> R
      ++ \spad{qelt(m, i, j)} returns the element in the \spad{i}th row and
      ++ \spad{j}th column of
      ++ the matrix m. Note: there is NO error check to determine if indices are
      ++ in the proper ranges.
    elt : (%, Integer, Integer, R) -> R
      ++ \spad{elt(m, i, j, r)} returns the element in the \spad{i}th row and
      ++ \spad{j}th column of the matrix m, if m has an \spad{i}th row and a
      ++ \spad{j}th column, and returns r otherwise.
    row : (%, Integer) -> Row
      ++ \spad{row(m, i)} returns the \spad{i}th row of the matrix m.
      ++ Error: if the index is outside the proper range.
    column : (%, Integer) -> Col
      ++ \spad{column(m, j)} returns the \spad{j}th column of the matrix m.
      ++ Error: if the index outside the proper range.

--% Map and Zip

    map : (R -> R, %) -> %
      ++ \spad{map(f, a)} returns b, where \spad{b(i, j) = a(i, j)} for all i, j.
    map : ((R, R) -> R, %, %) -> %
      ++ \spad{map(f, a, b)} returns c, where c is such that
      ++ \spad{c(i, j) = f(a(i, j), b(i, j))} for all \spad{i}, j.

--% Arithmetic

    if R has IntegralDomain then
      "exquo": (%,R) -> Union(%,"failed")
        ++ \spad{exquo(m, r)} computes the exact quotient of the elements
        ++ of m by r, returning \spad{"failed"} if this is not possible.
    if R has Field then
      "/": (%,R) -> %
        ++ \spad{m/r} divides the elements of m by r. Error: if \spad{r = 0}.

--% Linear algebra

    if R has EuclideanDomain then
      rowEchelon : % -> %
        ++ \spad{rowEchelon(m)} returns the row echelon form of the matrix m.
      columnSpace : % -> List Col
        ++ \spad{columnSpace(m)} returns a sublist of columns of the matrix m
        ++ forming a basis of its column space.
    if R has IntegralDomain then
      rank : % -> NonNegativeInteger
        ++ \spad{rank(m)} returns the rank of the matrix m.
      nullity : % -> NonNegativeInteger
        ++ \spad{nullity(m)} returns the nullity of the matrix m. This is
        ++ the dimension of the null space of the matrix m.
      nullSpace : % -> List Col
        ++ \spad{nullSpace(m)}+ returns a basis for the null space of
        ++ the matrix m.
   add

     if R has Finite then
         size() == (size()$R)^(m*n)

         random() == matrix [[random()$R for i in 1..n] for j in 1..m]

         lookup x ==
             s := size()$R
             pow : Integer := 1
             l := listOfLists(x)
             res : Integer := 1
             for r in l repeat
                 for c in r repeat
                     res := res + (lookup(c)$R-1)*pow
                     pow := pow*s
             res::PositiveInteger

         index i ==
             s := size()$R
             old := divide(i-1, s)
             res : List List R := []

             for i in 1..m repeat
                 row : List R := []
                 for j in 1..n repeat
                     el : R := index((old.remainder + 1)::PositiveInteger)$R
                     row := cons(el, row)
                     old := divide(old.quotient, s)
                 res := cons(reverse! row, res)

             matrix reverse! res

     nrows x == m
     ncols x == n
     square? x == m = n

     diagonal? x ==
       not square? x => false
       for i in minRowIndex x .. maxRowIndex x repeat
         for j in minColIndex x .. maxColIndex x
           | (j - minColIndex x) ~= (i - minRowIndex x) repeat
             not zero? qelt(x, i, j) => return false
       true

     symmetric? x ==
       m ~= n => false
       mr := minRowIndex x; mc := minColIndex x
       for i in 0..(n - 1) repeat
         for j in (i + 1)..(n - 1) repeat
           qelt(x, mr + i, mc + j) ~= qelt(x, mr + j, mc + i) => return false
       true

     if R has AbelianGroup then
         antisymmetric? x ==
             (nRows := nrows x) ~= ncols x => false
             mr := minRowIndex x; mc := minColIndex x
             for i in 0..(nRows - 1) repeat
                 for j in i..(nRows - 1) repeat
                     qelt(x, mr + i, mc + j) ~= -qelt(x, mr + j, mc + i) =>
                         return false
             true


