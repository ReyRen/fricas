)abbrev package SUMRF RationalFunctionSum
++ Summation of rational functions
++ Author: Manuel Bronstein
++ Description: Computes sums of rational functions;
RationalFunctionSum(R) : Exports == Impl where
    R : Join(IntegralDomain, Comparable, RetractableTo Integer)

    P   ==> Polynomial R
    RF  ==> Fraction P
    FE  ==> Expression R
    SE  ==> Symbol

    Exports ==> with
        sum : (P, SE) -> RF
            ++ sum(a(n), n) returns \spad{A} which
            ++ is the indefinite sum of \spad{a} with respect to
            ++ upward difference on \spad{n}, i.e. \spad{A(n+1) - A(n) = a(n)}.
        sum : (RF, SE) -> Union(RF, FE)
            ++ sum(a(n), n) returns \spad{A} which
            ++ is the indefinite sum of \spad{a} with respect to
            ++ upward difference on \spad{n}, i.e. \spad{A(n+1) - A(n) = a(n)}.
        sum : (P, SegmentBinding P) -> RF
            ++ sum(f(n), n = a..b) returns \spad{f(a) + f(a+1) + ... f(b)}.
        sum : (RF, SegmentBinding RF) -> Union(RF, FE)
            ++ sum(f(n), n = a..b) returns \spad{f(a) + f(a+1) + ... f(b)}.

    Impl ==> add
      import from RationalFunction R
      import from GosperSummationMethod(IndexedExponents SE, SE, R, P, RF)

      innersum    : (RF, SE) -> Union(RF, "failed")
      innerpolysum : (P, SE) -> RF

      sum(f : RF, s : SegmentBinding RF) ==
        (indef := innersum(f, v := variable s)) case "failed" =>
          summation(f::FE, map((z : RF) : FE +-> z::FE,
                               s)$SegmentBindingFunctions2(RF, FE))
        eval(indef::RF, v, 1 + high(segment(s)))
          - eval(indef::RF, v, low(segment(s)))

      sum(an : RF, n : SE) ==
        (u := innersum(an, n)) case "failed" => summation(an::FE, n)
        u::RF

      sum(p : P, s : SegmentBinding P) ==
        f := sum(p, v := variable s)
        eval(f, v, (1 + high(segment(s)))::RF) -
            eval(f, v, low(segment(s))::RF)

      innersum(an, n) ==
        (r := retractIfCan(an)@Union(P, "failed")) case "failed" =>
           an1 := eval(an, n, -1 + n::RF)
           (u := GospersMethod(an/an1, n, new$SE)) case "failed" =>
             "failed"
           an1 * eval(u::RF, n, -1 + n::RF)
        sum(r::P, n)

      sum(p : P, n : SE) ==
        rec := sum(p, n)$InnerPolySum(IndexedExponents SE, SE, R, P)
        rec.num / (rec.den :: P)

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
