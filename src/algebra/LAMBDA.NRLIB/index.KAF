9946                (|Lambda| UT)
|domain|
(((|Lambda| |#1|)
  (|Join| (|CoercibleTo| (|OutputForm|))
          (CATEGORY |domain| (SIGNATURE |lambda| ($ (|NonNegativeInteger|)))
           (SIGNATURE |lambda| ($ |#1|)) (SIGNATURE |lambda| ($ $ $))
           (SIGNATURE |lambda| ($ $ |#1|))
           (SIGNATURE |parseLambda| ($ (|String|)))
           (SIGNATURE |parseTerm|
            ((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|)))
             (|String|) (|NonNegativeInteger|)))
           (SIGNATURE |atom?| ((|Boolean|) $))
           (SIGNATURE |isCompound?| ((|Boolean|) $))
           (SIGNATURE |isLambda?| ((|Boolean|) $))
           (SIGNATURE |isBoundNode?| ((|Boolean|) $))
           (SIGNATURE |isFreeNode?| ((|Boolean|) $))
           (SIGNATURE |getBoundValue| ((|NonNegativeInteger|) $))
           (SIGNATURE |getVariable| (|#1| $))
           (SIGNATURE |free?| ((|Boolean|) $))
           (SIGNATURE |getChildren| ((|List| $) $))
           (SIGNATURE |subst| ($ $ $ $)) (SIGNATURE |bind| ($ $))
           (SIGNATURE |unbind| ($ $)) (SIGNATURE |redux| ($ $))
           (SIGNATURE = ((|Boolean|) $ $))
           (SIGNATURE |toStringConven| ((|String|) $ (|List| (|String|))))
           (SIGNATURE |toString| ((|String|) $))))
  (|VarCat|))
 (T |Lambda|))
(|Join| (|CoercibleTo| (|OutputForm|))
        (CATEGORY |domain| (SIGNATURE |lambda| ($ (|NonNegativeInteger|)))
         (SIGNATURE |lambda| ($ |#1|)) (SIGNATURE |lambda| ($ $ $))
         (SIGNATURE |lambda| ($ $ |#1|))
         (SIGNATURE |parseLambda| ($ (|String|)))
         (SIGNATURE |parseTerm|
          ((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|)))
           (|String|) (|NonNegativeInteger|)))
         (SIGNATURE |atom?| ((|Boolean|) $))
         (SIGNATURE |isCompound?| ((|Boolean|) $))
         (SIGNATURE |isLambda?| ((|Boolean|) $))
         (SIGNATURE |isBoundNode?| ((|Boolean|) $))
         (SIGNATURE |isFreeNode?| ((|Boolean|) $))
         (SIGNATURE |getBoundValue| ((|NonNegativeInteger|) $))
         (SIGNATURE |getVariable| (|#1| $)) (SIGNATURE |free?| ((|Boolean|) $))
         (SIGNATURE |getChildren| ((|List| $) $)) (SIGNATURE |subst| ($ $ $ $))
         (SIGNATURE |bind| ($ $)) (SIGNATURE |unbind| ($ $))
         (SIGNATURE |redux| ($ $)) (SIGNATURE = ((|Boolean|) $ $))
         (SIGNATURE |toStringConven| ((|String|) $ (|List| (|String|))))
         (SIGNATURE |toString| ((|String|) $))))
"/git/fricas/src/algebra/LAMBDA.spad"
((|lambda| (*1 *1 *2)
  (AND (|isDomain| *2 (|NonNegativeInteger|)) (|isDomain| *1 (|Lambda| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|lambda| (*1 *1 *2)
  (AND (|isDomain| *1 (|Lambda| *2)) (|ofCategory| *2 (|VarCat|))))
 (|lambda| (*1 *1 *1 *1)
  (AND (|isDomain| *1 (|Lambda| *2)) (|ofCategory| *2 (|VarCat|))))
 (|lambda| (*1 *1 *1 *2)
  (AND (|isDomain| *1 (|Lambda| *2)) (|ofCategory| *2 (|VarCat|))))
 (|parseLambda| (*1 *1 *2)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *1 (|Lambda| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|parseTerm| (*1 *2 *3 *4)
  (AND (|isDomain| *3 (|String|)) (|isDomain| *4 (|NonNegativeInteger|))
       (|isDomain| *2
                   (|Record| (|:| |rft| (|Lambda| *5))
                             (|:| |pout| (|NonNegativeInteger|))))
       (|isDomain| *1 (|Lambda| *5)) (|ofCategory| *5 (|VarCat|))))
 (|atom?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|Lambda| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|isCompound?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|Lambda| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|isLambda?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|Lambda| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|isBoundNode?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|Lambda| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|isFreeNode?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|Lambda| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|getBoundValue| (*1 *2 *1)
  (AND (|isDomain| *2 (|NonNegativeInteger|)) (|isDomain| *1 (|Lambda| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|getVariable| (*1 *2 *1)
  (AND (|isDomain| *1 (|Lambda| *2)) (|ofCategory| *2 (|VarCat|))))
 (|free?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|Lambda| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|getChildren| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|Lambda| *3))) (|isDomain| *1 (|Lambda| *3))
       (|ofCategory| *3 (|VarCat|))))
 (|subst| (*1 *1 *1 *1 *1)
  (AND (|isDomain| *1 (|Lambda| *2)) (|ofCategory| *2 (|VarCat|))))
 (|bind| (*1 *1 *1)
  (AND (|isDomain| *1 (|Lambda| *2)) (|ofCategory| *2 (|VarCat|))))
 (|unbind| (*1 *1 *1)
  (AND (|isDomain| *1 (|Lambda| *2)) (|ofCategory| *2 (|VarCat|))))
 (|redux| (*1 *1 *1)
  (AND (|isDomain| *1 (|Lambda| *2)) (|ofCategory| *2 (|VarCat|))))
 (= (*1 *2 *1 *1)
    (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|Lambda| *3))
         (|ofCategory| *3 (|VarCat|))))
 (|toStringConven| (*1 *2 *1 *3)
  (AND (|isDomain| *3 (|List| (|String|))) (|isDomain| *2 (|String|))
       (|isDomain| *1 (|Lambda| *4)) (|ofCategory| *4 (|VarCat|))))
 (|toString| (*1 *2 *1)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *1 (|Lambda| *3))
       (|ofCategory| *3 (|VarCat|)))))
((|unbind| (($ $) 58))
 (|toStringConven| (((|String|) $ (|List| (|String|))) 50))
 (|toString| (((|String|) $) 55)) (|subst| (($ $ $ $) 57)) (|redux| (($ $) 59))
 (|parseTerm|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   39))
 (|parseLambda| (($ (|String|)) 44))
 (|lambda| (($ (|NonNegativeInteger|)) 9) (($ |#1|) 10) (($ $ $) 11)
  (($ $ |#1|) 13))
 (|isLambda?| (((|Boolean|) $) 19)) (|isFreeNode?| (((|Boolean|) $) 21))
 (|isCompound?| (((|Boolean|) $) 18)) (|isBoundNode?| (((|Boolean|) $) 20))
 (|getVariable| ((|#1| $) 25)) (|getChildren| (((|List| $) $) 17))
 (|getBoundValue| (((|NonNegativeInteger|) $) 22))
 (|free?| (((|Boolean|) $) 33)) (|coerce| (((|OutputForm|) $) 29))
 (|bind| (($ $) 12)) (|atom?| (((|Boolean|) $) 15)) (= (((|Boolean|) $ $) 56)))
LAMBDA
(((|CoercibleTo| (|OutputForm|)) . T))
(((|CoercibleTo| (|OutputForm|)) . T))
((|constructor| (NIL "macro to simplify output"))
 (|toString|
  (((|String|) $)
   "return string representation using deBruijn index for bound variables. notation assumes association to the left,{} in the absence of brackets,{} the term to the left binds more tightly than the one on the right."))
 (|toStringConven|
  (((|String|) $ (|List| (|String|)))
   "return string representation using conventional notation,{} that is deBruijn index is replaced by name using String value for bound variables. notation assumes association to the left,{} in the absence of brackets,{} the term to the left binds more tightly than the one on the right."))
 (=
  (((|Boolean|) $ $)
   "return \\spad{true} if equal (deep search) that is: all terms at all levels in tree must be alpha-equivalent to return \\spad{true} That is the names,{} but not the deBruijn index,{} of the bound variables can be different. beta-equivalence is not implemented because it is not decidable."))
 (|redux|
  (($ $) "beta reduction - apply beta reduction recusivly to all subnodes"))
 (|unbind|
  (($ $)
   "if this is a lambda term then replace De Bruijn index in sub-nodes with string name"))
 (|bind|
  (($ $)
   "if this is a lambda term then replace string name in sub-nodes with De Bruijn index"))
 (|subst| (($ $ $ $) "substitution of 'a' for \\spad{'b'} in \\spad{'n'}"))
 (|getChildren|
  (((|List| $) $)
   "returns 2 child nodes if this is a compound term returns 1 child node if this is a lamda term otherwise returns []"))
 (|free?|
  (((|Boolean|) $)
   "if this is a lambda term then is it free,{} that is does its variable appear in its expression"))
 (|getVariable|
  ((|#1| $)
   "introspection: returns value of unbound variable in unbound leaf node or bound variable in lambda term"))
 (|getBoundValue|
  (((|NonNegativeInteger|) $)
   "introspection: returns deBruijn index of bound variable in bound leaf node"))
 (|isFreeNode?|
  (((|Boolean|) $)
   "introspection: returns \\spad{true} if this is a unbound leaf node"))
 (|isBoundNode?|
  (((|Boolean|) $)
   "introspection: returns \\spad{true} if this is a bound leaf node"))
 (|isLambda?|
  (((|Boolean|) $)
   "introspection: returns \\spad{true} if this is a lambda definition"))
 (|isCompound?|
  (((|Boolean|) $)
   "introspection: returns \\spad{true} if this is a compound term containing two nodes"))
 (|atom?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is an atom,{} that is free or bound variable otherwise return \\spad{false} if this is a compound or lambda definition"))
 (|parseTerm|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   "parseTerm is used by parseLambda. It would rarely be called externally but it is here to allow it to call parseLambda that is to allow circular calls"))
 (|parseLambda|
  (($ (|String|))
   "Constructs nested lambda terms from a string notation assumes format like this: <term> : \\spad{:=} \"\\spad{\\\"} var \".\"<term> | \\spad{n} | <term><term> | \"(\"<term>\")\" where: \\\\ = lambda (\\spad{I} would like to use unicode lambda symbol but \\indented{12}{\\spad{I} would also like to keep maximum compatibility} \\indented{12}{with non-unicode versions of Lisp)} \\spad{n} = De Bruijn index which is a integer where,{} 1=inside inner \\indented{12}{lambda term,{} 2= next outer lambda term,{} 3= next} \\indented{12}{outer and so on.} brackets can be used around whole terms."))
 (|lambda|
  (($ $ |#1|)
   "Constructs lambda term and bind any variables with the name provided")
  (($ $ $) "Constructs a node containing multiple terms")
  (($ |#1|) "Constructs a reference to a free variable")
  (($ (|NonNegativeInteger|))
   "Constructs a reference to a bound variable from its deBruijn index")))
(("documentation" 0 6180) ("ancestors" 0 6141) ("parents" 0 6102)
 ("abbreviation" 0 6095) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 5267) ("modemaps" 0 2482) ("sourceFile" 0 2444)
 ("constructorCategory" 0 1298) ("constructorModemap" 0 43)
 ("constructorKind" 0 34) ("constructorForm" 0 20))