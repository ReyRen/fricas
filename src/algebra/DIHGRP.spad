)abbrev domain DIHGRP DihedralGroup
++ Author: Franz Lehner
++ Date Created: 30.12.2014
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ \spad{DihedralGroup(n, a, b)} is the dihedral group generated by
++ a rotation a of order n and a reflection b.
DihedralGroup(n: PositiveInteger, a: Symbol, b: Symbol):Exports == Implementation where
  EXPA ==> IntegerMod n
  EXPB ==> IntegerMod 2
  Exports ==> Join(FiniteGroup, FinitelyGenerated, Comparable) with
    expa : % -> EXPA
    ++ \spad{expa(x)} returns the exponent of the rotation a in the normal form
    ++ of x
    expb : % -> EXPB
    ++ \spad{expa(x)} returns the exponent of the reflection b in the normal
    ++ form of x
    exponenta : % -> Integer
    ++ \spad{exponenta(x)} returns the exponent of the rotation a in the normal
    ++ form of x as integer
    exponentb : % -> Integer
    ++ \spad{exponentb(x)} returns the exponent of the reflection b in the normal
    ++ form of x as integer
  Implementation ==> add
    Rep := Record (expa : EXPA, expb : EXPB)
    rep(x:%) : Rep == x :: Rep
    per(r:Rep) : % == r :: %

    expa(x:%) : EXPA == (rep x).expa
    expb(x:%) : EXPB == (rep x).expb

    exponenta(x:%) : Integer == convert expa(x)
    exponentb(x:%) : Integer == convert expb(x)

    1 : % == per([0,0]$Rep)

    one?(x:%) : Boolean == zero? expa x and zero? expb x

    coerce(y:%) : OutputForm ==
        one? y => (1$Integer)::OutputForm
        zero? expa y => b::OutputForm
        if one? expa y then
            aout:= a::OutputForm
        else
            aout : OutputForm := a::OutputForm^((expa y)::OutputForm)
        zero? expb y => aout
        aout * (b::OutputForm)

    generators() : List % == [per([1,0]$Rep), per([0,1]$Rep)]

    -- Group operations
    _*(x:%, y:%): % ==
        zero? expb x => per ([expa x + expa y, expb y]$Rep)
        -- otherwise the second a exponent is twisted
        per ([expa x - expa y, expb x + expb y]$Rep)

    inv(x: %) : % ==
        zero? expb x => per [-expa x, 0]
        x

    order(x:%) : Integer ==
        one? x => 0
        one? expb x => 2
        n quo gcd(convert expa x, n)

    -- Comparable
    _=(x:%, y:%) : Boolean == expa x = expa y and expb x = expb y

    -- reverse lexicographic order on the exponents,
    -- so Zn comes before its coset
    smaller?(x:%, y:%) : Boolean ==
        convert expb x < convert expb y => true
        convert expb x > convert expb y => false
        convert expa x < convert expa y => true
        false

    -- FiniteGroup
    size() : NonNegativeInteger == (2*n)::NonNegativeInteger

    index(i: PositiveInteger) : % ==
        i > 2*n => error "out of range"
        imodn := coerce(i-1)@EXPA
        i > n => per ([imodn, 1]$Rep)
        per ([imodn, 0]$Rep)

    lookup(x) ==
        xa : PositiveInteger := qcoerce(convert(expa x)@Integer + 1) + qcoerce(n*convert(expb x)@Integer)

    enumerate() : List % ==
        concat([per [k::EXPA, 0] for k in 0@Integer..n::Integer-1], [per [k::EXPA, 1] for k in 0@Integer..n::Integer-1])
