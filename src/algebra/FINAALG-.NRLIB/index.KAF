21300               (|FiniteRankNonAssociativeAlgebra&| S R)
|domain|
(((|FiniteRankNonAssociativeAlgebra&| |#1| |#2|)
  (CATEGORY |domain|
   (SIGNATURE |rightMinimalPolynomial|
    ((|SparseUnivariatePolynomial| |#2|) |#1|))
   (SIGNATURE |leftMinimalPolynomial|
    ((|SparseUnivariatePolynomial| |#2|) |#1|))
   (SIGNATURE |associatorDependence| ((|List| (|Vector| |#2|))))
   (SIGNATURE |rightRecip| ((|Union| |#1| "failed") |#1|))
   (SIGNATURE |leftRecip| ((|Union| |#1| "failed") |#1|))
   (SIGNATURE |recip| ((|Union| |#1| "failed") |#1|))
   (SIGNATURE |lieAlgebra?| ((|Boolean|)))
   (SIGNATURE |jordanAlgebra?| ((|Boolean|)))
   (SIGNATURE |noncommutativeJordanAlgebra?| ((|Boolean|)))
   (SIGNATURE |jordanAdmissible?| ((|Boolean|)))
   (SIGNATURE |lieAdmissible?| ((|Boolean|)))
   (SIGNATURE |jacobiIdentity?| ((|Boolean|)))
   (SIGNATURE |alternative?| ((|Boolean|)))
   (SIGNATURE |flexible?| ((|Boolean|)))
   (SIGNATURE |rightAlternative?| ((|Boolean|)))
   (SIGNATURE |leftAlternative?| ((|Boolean|)))
   (SIGNATURE |antiAssociative?| ((|Boolean|)))
   (SIGNATURE |associative?| ((|Boolean|)))
   (SIGNATURE |antiCommutative?| ((|Boolean|)))
   (SIGNATURE |commutative?| ((|Boolean|)))
   (SIGNATURE |rightCharacteristicPolynomial|
    ((|SparseUnivariatePolynomial| |#2|) |#1|))
   (SIGNATURE |leftCharacteristicPolynomial|
    ((|SparseUnivariatePolynomial| |#2|) |#1|))
   (SIGNATURE |rightTraceMatrix| ((|Matrix| |#2|) (|Vector| |#1|)))
   (SIGNATURE |leftTraceMatrix| ((|Matrix| |#2|) (|Vector| |#1|)))
   (SIGNATURE |rightDiscriminant| (|#2| (|Vector| |#1|)))
   (SIGNATURE |leftDiscriminant| (|#2| (|Vector| |#1|)))
   (SIGNATURE |represents| (|#1| (|Vector| |#2|) (|Vector| |#1|)))
   (SIGNATURE |coordinates| ((|Matrix| |#2|) (|Vector| |#1|) (|Vector| |#1|)))
   (SIGNATURE |coordinates| ((|Vector| |#2|) |#1| (|Vector| |#1|)))
   (SIGNATURE |rightNorm| (|#2| |#1|)) (SIGNATURE |leftNorm| (|#2| |#1|))
   (SIGNATURE |rightTrace| (|#2| |#1|)) (SIGNATURE |leftTrace| (|#2| |#1|))
   (SIGNATURE |rightRegularRepresentation|
    ((|Matrix| |#2|) |#1| (|Vector| |#1|)))
   (SIGNATURE |leftRegularRepresentation|
    ((|Matrix| |#2|) |#1| (|Vector| |#1|)))
   (SIGNATURE |structuralConstants|
    ((|Vector| (|Matrix| |#2|)) (|Vector| |#1|))))
  (|FiniteRankNonAssociativeAlgebra| |#2|) (|CommutativeRing|))
 (T |FiniteRankNonAssociativeAlgebra&|))
(CATEGORY |domain|
 (SIGNATURE |rightMinimalPolynomial|
  ((|SparseUnivariatePolynomial| |#2|) |#1|))
 (SIGNATURE |leftMinimalPolynomial| ((|SparseUnivariatePolynomial| |#2|) |#1|))
 (SIGNATURE |associatorDependence| ((|List| (|Vector| |#2|))))
 (SIGNATURE |rightRecip| ((|Union| |#1| "failed") |#1|))
 (SIGNATURE |leftRecip| ((|Union| |#1| "failed") |#1|))
 (SIGNATURE |recip| ((|Union| |#1| "failed") |#1|))
 (SIGNATURE |lieAlgebra?| ((|Boolean|)))
 (SIGNATURE |jordanAlgebra?| ((|Boolean|)))
 (SIGNATURE |noncommutativeJordanAlgebra?| ((|Boolean|)))
 (SIGNATURE |jordanAdmissible?| ((|Boolean|)))
 (SIGNATURE |lieAdmissible?| ((|Boolean|)))
 (SIGNATURE |jacobiIdentity?| ((|Boolean|)))
 (SIGNATURE |alternative?| ((|Boolean|))) (SIGNATURE |flexible?| ((|Boolean|)))
 (SIGNATURE |rightAlternative?| ((|Boolean|)))
 (SIGNATURE |leftAlternative?| ((|Boolean|)))
 (SIGNATURE |antiAssociative?| ((|Boolean|)))
 (SIGNATURE |associative?| ((|Boolean|)))
 (SIGNATURE |antiCommutative?| ((|Boolean|)))
 (SIGNATURE |commutative?| ((|Boolean|)))
 (SIGNATURE |rightCharacteristicPolynomial|
  ((|SparseUnivariatePolynomial| |#2|) |#1|))
 (SIGNATURE |leftCharacteristicPolynomial|
  ((|SparseUnivariatePolynomial| |#2|) |#1|))
 (SIGNATURE |rightTraceMatrix| ((|Matrix| |#2|) (|Vector| |#1|)))
 (SIGNATURE |leftTraceMatrix| ((|Matrix| |#2|) (|Vector| |#1|)))
 (SIGNATURE |rightDiscriminant| (|#2| (|Vector| |#1|)))
 (SIGNATURE |leftDiscriminant| (|#2| (|Vector| |#1|)))
 (SIGNATURE |represents| (|#1| (|Vector| |#2|) (|Vector| |#1|)))
 (SIGNATURE |coordinates| ((|Matrix| |#2|) (|Vector| |#1|) (|Vector| |#1|)))
 (SIGNATURE |coordinates| ((|Vector| |#2|) |#1| (|Vector| |#1|)))
 (SIGNATURE |rightNorm| (|#2| |#1|)) (SIGNATURE |leftNorm| (|#2| |#1|))
 (SIGNATURE |rightTrace| (|#2| |#1|)) (SIGNATURE |leftTrace| (|#2| |#1|))
 (SIGNATURE |rightRegularRepresentation|
  ((|Matrix| |#2|) |#1| (|Vector| |#1|)))
 (SIGNATURE |leftRegularRepresentation| ((|Matrix| |#2|) |#1| (|Vector| |#1|)))
 (SIGNATURE |structuralConstants| ((|Vector| (|Matrix| |#2|)) (|Vector| |#1|))))
"/git/fricas/src/algebra/FINAALG.spad"
((|commutative?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|antiCommutative?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|associative?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|antiAssociative?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|leftAlternative?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|rightAlternative?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|flexible?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|alternative?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|jacobiIdentity?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|lieAdmissible?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|jordanAdmissible?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|noncommutativeJordanAlgebra?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|jordanAlgebra?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|lieAlgebra?| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|associatorDependence| (*1 *2)
  (AND (|ofCategory| *4 (|CommutativeRing|))
       (|isDomain| *2 (|List| (|Vector| *4)))
       (|isDomain| *1 (|FiniteRankNonAssociativeAlgebra&| *3 *4))
       (|ofCategory| *3 (|FiniteRankNonAssociativeAlgebra| *4)))))
((|structuralConstants| (((|Vector| (|Matrix| |#2|)) (|Vector| $)) 59))
 (|rightTraceMatrix| (((|Matrix| |#2|) (|Vector| $)) 115))
 (|rightTrace| ((|#2| $) 31))
 (|rightRegularRepresentation| (((|Matrix| |#2|) $ (|Vector| $)) 120))
 (|rightRecip| (((|Union| $ "failed") $) 73)) (|rightNorm| ((|#2| $) 34))
 (|rightMinimalPolynomial| (((|SparseUnivariatePolynomial| |#2|) $) 81))
 (|rightDiscriminant| ((|#2| (|Vector| $)) 104))
 (|rightCharacteristicPolynomial| (((|SparseUnivariatePolynomial| |#2|) $) 27))
 (|rightAlternative?| (((|Boolean|)) 98))
 (|represents| (($ (|Vector| |#2|) (|Vector| $)) 109))
 (|recip| (((|Union| $ "failed") $) 77))
 (|noncommutativeJordanAlgebra?| (((|Boolean|)) 93))
 (|lieAlgebra?| (((|Boolean|)) 88)) (|lieAdmissible?| (((|Boolean|)) 52))
 (|leftTraceMatrix| (((|Matrix| |#2|) (|Vector| $)) 113))
 (|leftTrace| ((|#2| $) 30))
 (|leftRegularRepresentation| (((|Matrix| |#2|) $ (|Vector| $)) 119))
 (|leftRecip| (((|Union| $ "failed") $) 71)) (|leftNorm| ((|#2| $) 33))
 (|leftMinimalPolynomial| (((|SparseUnivariatePolynomial| |#2|) $) 80))
 (|leftDiscriminant| ((|#2| (|Vector| $)) 102))
 (|leftCharacteristicPolynomial| (((|SparseUnivariatePolynomial| |#2|) $) 25))
 (|leftAlternative?| (((|Boolean|)) 97)) (|jordanAlgebra?| (((|Boolean|)) 90))
 (|jordanAdmissible?| (((|Boolean|)) 50))
 (|jacobiIdentity?| (((|Boolean|)) 85)) (|flexible?| (((|Boolean|)) 99))
 (|coordinates| (((|Vector| |#2|) $ (|Vector| $)) NIL)
  (((|Matrix| |#2|) (|Vector| $) (|Vector| $)) 107))
 (|commutative?| (((|Boolean|)) 95))
 (|associatorDependence| (((|List| (|Vector| |#2|))) 84))
 (|associative?| (((|Boolean|)) 96)) (|antiCommutative?| (((|Boolean|)) 94))
 (|antiAssociative?| (((|Boolean|)) 45)) (|alternative?| (((|Boolean|)) 100)))
((|HasCategory| |#2| '(|IntegralDomain|)))
FINAALG-
((|constructor|
  (NIL
   "A FiniteRankNonAssociativeAlgebra is a non associative algebra over a commutative ring \\spad{R} which is a free \\spad{R}-module of finite rank."))
 (|unit|
  (((|Union| $ "failed"))
   "\\spad{unit()} returns a unit of the algebra (necessarily unique),{} or \\spad{\"failed\"} if there is none."))
 (|rightUnit|
  (((|Union| $ "failed"))
   "\\spad{rightUnit()} returns a right unit of the algebra (not necessarily unique),{} or \\spad{\"failed\"} if there is none."))
 (|leftUnit|
  (((|Union| $ "failed"))
   "\\spad{leftUnit()} returns a left unit of the algebra (not necessarily unique),{} or \\spad{\"failed\"} if there is none."))
 (|rightUnits|
  (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
             "failed"))
   "\\spad{rightUnits()} returns the affine space of all right units of the algebra,{} or \\spad{\"failed\"} if there is none."))
 (|leftUnits|
  (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
             "failed"))
   "\\spad{leftUnits()} returns the affine space of all left units of the algebra,{} or \\spad{\"failed\"} if there is none."))
 (|rightMinimalPolynomial|
  (((|SparseUnivariatePolynomial| |#2|) $)
   "\\spad{rightMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of right powers of \\spad{a}. Note: the polynomial never has a constant term as in general the algebra has no unit."))
 (|leftMinimalPolynomial|
  (((|SparseUnivariatePolynomial| |#2|) $)
   "\\spad{leftMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of left powers of \\spad{a}. Note: the polynomial never has a constant term as in general the algebra has no unit."))
 (|associatorDependence|
  (((|List| (|Vector| |#2|)))
   "\\spad{associatorDependence()} looks for the associator identities,{} \\spadignore{i.e.} finds a basis of the solutions of the linear combinations of the six permutations of \\spad{associator(a,{} b,{} c)} which yield 0,{} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra. The order of the permutations is \\spad{123 231 312 132 321 213}."))
 (|rightRecip|
  (((|Union| $ "failed") $)
   "\\spad{rightRecip(a)} returns an element,{} which is a right inverse of \\spad{a},{} or \\spad{\"failed\"} if there is no unit element,{} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|leftRecip|
  (((|Union| $ "failed") $)
   "\\spad{leftRecip(a)} returns an element,{} which is a left inverse of \\spad{a},{} or \\spad{\"failed\"} if there is no unit element,{} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|recip|
  (((|Union| $ "failed") $)
   "\\spad{recip(a)} returns an element,{} which is both a left and a right inverse of \\spad{a},{} or \\spad{\"failed\"} if there is no unit element,{} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|lieAlgebra?|
  (((|Boolean|))
   "\\spad{lieAlgebra?()} tests if the algebra is anticommutative and \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra (Jacobi identity). Example: for every associative algebra \\spad{(A,{} +,{} @)} we can construct a Lie algebra \\spad{(A,{} +,{} *)},{} where \\spad{a*b := a@b-b@a}."))
 (|jordanAlgebra?|
  (((|Boolean|))
   "\\spad{jordanAlgebra?()} tests if the algebra is commutative,{} characteristic is not 2,{} and \\spad{(a*b)*a^2 - a*(b*a^2) = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra (Jordan identity). Example: for every associative algebra \\spad{(A,{} +,{} @)} we can construct a Jordan algebra \\spad{(A,{} +,{} *)},{} where \\spad{a*b := (a@b+b@a)/2}."))
 (|noncommutativeJordanAlgebra?|
  (((|Boolean|))
   "\\spad{noncommutativeJordanAlgebra?()} tests if the algebra is flexible and Jordan admissible."))
 (|jordanAdmissible?|
  (((|Boolean|))
   "\\spad{jordanAdmissible?()} tests if 2 is invertible in the coefficient domain and the multiplication defined by \\spad{(1/2)(a*b+b*a)} determines a Jordan algebra,{} \\spadignore{i.e.} satisfies the Jordan identity. The property of \\spadatt{CommutativeStar} follows from by definition."))
 (|lieAdmissible?|
  (((|Boolean|))
   "\\spad{lieAdmissible?()} tests if the algebra defined by the commutators is a Lie algebra,{} \\spadignore{i.e.} satisfies the Jacobi identity. The property of anticommutativity follows from definition."))
 (|jacobiIdentity?|
  (((|Boolean|))
   "\\spad{jacobiIdentity?()} tests if \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra. For example,{} this holds for crossed products of 3-dimensional vectors."))
 (|powerAssociative?|
  (((|Boolean|))
   "\\spad{powerAssociative?()} tests if all subalgebras generated by a single element are associative."))
 (|alternative?|
  (((|Boolean|))
   "\\spad{alternative?()} tests if \\spad{2*associator(a,{} a,{} b) = 0 = 2*associator(a,{} b,{} b)} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|flexible?|
  (((|Boolean|))
   "\\spad{flexible?()} tests if \\spad{2*associator(a,{} b,{} a) = 0} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|rightAlternative?|
  (((|Boolean|))
   "\\spad{rightAlternative?()} tests if \\spad{2*associator(a,{} b,{} b) = 0} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|leftAlternative?|
  (((|Boolean|))
   "\\spad{leftAlternative?()} tests if \\spad{2*associator(a,{} a,{} b) = 0} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|antiAssociative?|
  (((|Boolean|))
   "\\spad{antiAssociative?()} tests if multiplication in algebra is anti-associative,{} \\spadignore{i.e.} \\spad{(a*b)*c + a*(b*c) = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra."))
 (|associative?|
  (((|Boolean|))
   "\\spad{associative?()} tests if multiplication in algebra is associative."))
 (|antiCommutative?|
  (((|Boolean|))
   "\\spad{antiCommutative?()} tests if \\spad{a*a = 0} for all \\spad{a} in the algebra. Note: this implies \\spad{a*b + b*a = 0} for all \\spad{a} and \\spad{b}."))
 (|commutative?|
  (((|Boolean|))
   "\\spad{commutative?()} tests if multiplication in the algebra is commutative."))
 (|rightCharacteristicPolynomial|
  (((|SparseUnivariatePolynomial| |#2|) $)
   "\\spad{rightCharacteristicPolynomial(a)} returns the characteristic polynomial of the right regular representation of \\spad{a} with respect to any basis."))
 (|leftCharacteristicPolynomial|
  (((|SparseUnivariatePolynomial| |#2|) $)
   "\\spad{leftCharacteristicPolynomial(a)} returns the characteristic polynomial of the left regular representation of \\spad{a} with respect to any basis."))
 (|rightTraceMatrix|
  (((|Matrix| |#2|) (|Vector| $))
   "\\spad{rightTraceMatrix([v1,{} ...,{} vn])} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the right trace of the product \\spad{vi*vj}."))
 (|leftTraceMatrix|
  (((|Matrix| |#2|) (|Vector| $))
   "\\spad{leftTraceMatrix([v1,{} ...,{} vn])} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the left trace of the product \\spad{vi*vj}."))
 (|rightDiscriminant|
  ((|#2| (|Vector| $))
   "\\spad{rightDiscriminant([v1,{} ...,{} vn])} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the right trace of the product \\spad{vi*vj}. Note: the same as \\spad{determinant(rightTraceMatrix([v1,{} ...,{} vn]))}."))
 (|leftDiscriminant|
  ((|#2| (|Vector| $))
   "\\spad{leftDiscriminant([v1,{} ...,{} vn])} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the left trace of the product \\spad{vi*vj}. Note: the same as \\spad{determinant(leftTraceMatrix([v1,{} ...,{} vn]))}."))
 (|represents|
  (($ (|Vector| |#2|) (|Vector| $))
   "\\spad{represents([a1,{} ...,{} am],{} [v1,{} ...,{} vm])} returns the linear combination \\spad{a1*vm + ... + an*vm}."))
 (|coordinates|
  (((|Matrix| |#2|) (|Vector| $) (|Vector| $))
   "\\spad{coordinates([a1,{} ...,{} am],{} [v1,{} ...,{} vn])} returns a matrix whose \\spad{i}-th row is formed by the coordinates of \\spad{\\spad{ai}} with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}.")
  (((|Vector| |#2|) $ (|Vector| $))
   "\\spad{coordinates(a,{} [v1,{} ...,{} vn])} returns the coordinates of \\spad{a} with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}."))
 (|rightNorm|
  ((|#2| $)
   "\\spad{rightNorm(a)} returns the determinant of the right regular representation of \\spad{a}."))
 (|leftNorm|
  ((|#2| $)
   "\\spad{leftNorm(a)} returns the determinant of the left regular representation of \\spad{a}."))
 (|rightTrace|
  ((|#2| $)
   "\\spad{rightTrace(a)} returns the trace of the right regular representation of \\spad{a}."))
 (|leftTrace|
  ((|#2| $)
   "\\spad{leftTrace(a)} returns the trace of the left regular representation of \\spad{a}."))
 (|rightRegularRepresentation|
  (((|Matrix| |#2|) $ (|Vector| $))
   "\\spad{rightRegularRepresentation(a,{} [v1,{} ...,{} vn])} returns the matrix \\spad{m} of the linear map defined by right multiplication by \\spad{a} with respect to the \\spad{R}-module basis \\spad{b = [v1,{} ...,{} vn]}. That is for all \\spad{x} \\spad{coordinates(x*a,{} b) = m*coordinates(x,{} b)}."))
 (|leftRegularRepresentation|
  (((|Matrix| |#2|) $ (|Vector| $))
   "\\spad{leftRegularRepresentation(a,{} [v1,{} ...,{} vn])} returns the matrix \\spad{m} of the linear map defined by left multiplication by \\spad{a} with respect to the \\spad{R}-module basis \\spad{b = [v1,{} ...,{} vn]}. That is for all \\spad{x} \\spad{coordinates(a*x,{} b) = m*coordinates(x,{} b)}."))
 (|structuralConstants|
  (((|Vector| (|Matrix| |#2|)) (|Vector| $))
   "\\spad{structuralConstants([v1,{} v2,{} ...,{} vm])} calculates the structural constants \\spad{[(gammaijk) for k in 1..m]} defined by \\spad{\\spad{vi} * vj = gammaij1 * v1 + ... + gammaijm * vm},{} where \\spad{[v1,{} ...,{} vm]} is an \\spad{R}-module basis of a subalgebra."))
 (|conditionsForIdempotents|
  (((|List| (|Polynomial| |#2|)) (|Vector| $))
   "\\spad{conditionsForIdempotents([v1,{} ...,{} vn])} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}."))
 (|rank|
  (((|PositiveInteger|))
   "\\spad{rank()} returns the rank of the algebra as \\spad{R}-module."))
 (|someBasis|
  (((|Vector| $)) "\\spad{someBasis()} returns some \\spad{R}-module basis."))
 (|unitsKnown|
  ((|attribute|)
   "unitsKnown means that \\spadfun{recip} truly yields reciprocal or \\spad{\"failed\"} if not a unit,{} similarly for \\spadfun{leftRecip} and \\spadfun{rightRecip}. The reason is that we use left,{} respectively right,{} minimal polynomials to decide this question.")))
(("documentation" 0 9792) ("ancestors" 0 NIL) ("parents" 0 NIL)
 ("abbreviation" 0 9783) ("predicates" 0 9740) ("superDomain" 0 NIL)
 ("operationAlist" 0 7986) ("modemaps" 0 4468) ("sourceFile" 0 4429)
 ("constructorCategory" 0 2372) ("constructorModemap" 0 70)
 ("constructorKind" 0 61) ("constructorForm" 0 20))