)abbrev package CHARPOL2 CharacteristicPolynomial2
++ Description: This package computes characteristic polynomial
++  using Danilewski method.
CharacteristicPolynomial2(F : Field) : Exports == Implementation where

  Mat ==> Matrix(F)
  Rec ==> Record(matrix : Mat, block_list : List(Integer))
  Up ==> SparseUnivariatePolynomial(F)
  Exports ==> with
    danilewski : Mat -> Rec
      ++ danilewski(m) converts m to block form where
      ++ each block represents transposition of multiplication
      ++ by a polynomial.
    char_pol : Mat -> Up
      ++ char_pol(m) computes characteristic polynomial of m.

  Implementation ==> add

    NNI ==> NonNegativeInteger

    danilewski(m : Mat) : Rec ==
        n := ncols(m)
        n ~= nrows(m) => error "need square matrix"
        n1 := n::Integer
        nn := n::Integer
        blocks : List(Integer) := []
        for nc in 1..(n - 1) repeat
            n1 := n - nc + 1
            k1 := n1 - 1
            has_block : Boolean := false
            if (piv := qelt(m, n1, k1)) = 0 then
                has_block := true
                for kk in 1..(k1 - 1) repeat
                    if (piv := qelt(m, n1, kk)) ~= 0 then
                        m := swapRows!(m, kk, k1)
                        m := swapColumns!(m, kk, k1)
                        has_block := false
                        break
            has_block =>
                nn := k1
                blocks := cons(n1, blocks)
                "iterate"
            piv := 1/piv
            for i in 1..k1 repeat
                cc := piv*qelt(m, i, k1)
                for j in 1..nn repeat
                    val :=
                        j = k1 => cc
                        qelt(m, i, j) - cc*qelt(m, n1, j)
                    qsetelt!(m, i, j, val)
            for j in 1..nn repeat
                s : F := 0
                for i in 1..k1 repeat
                    s := s + qelt(m, n1, i)*qelt(m, i, j)
                qsetelt!(m, k1, j, s)
            for i in 0..(nn - n1) repeat
                qsetelt!(m, k1, k1 + i, qelt(m, k1, k1 + i)
                                        + qelt(m, n1, n1 + i))
            for j in 1..nn repeat
                qsetelt!(m, n1, j, 0)
            qsetelt!(m, n1, k1, 1)
        [m, cons(1, blocks)]


    char_pol(m) ==
        pp := danilewski(copy(m))
        n := ncols(m)
        blocks := pp.block_list
        mp := pp.matrix
        res := 1$Up
        while not(empty?(blocks)) repeat
            i0 := first(blocks)
            blocks := rest(blocks)
            i1 : Integer :=
                 empty?(blocks) => n + 1
                 first(blocks)
            res1 := 0$Up
            for i in 0..(i1 - i0 - 1) repeat
                res1 := res1 + monomial(mp(i0, (i1 - i - 1)::NNI), i::NNI)$Up
            res1 := monomial(-1$F, (i1 - i0)::NNI)$Up + res1
            if even?(i1 - i0) then
                res1 := -res1
            res := res*res1
        res

