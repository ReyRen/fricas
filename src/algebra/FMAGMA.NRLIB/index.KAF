5433                (|FreeMagma| |VarSet|)
|domain|
(((|FreeMagma| |#1|)
  (|Join| (|OrderedSet|) (|RetractableTo| |#1|)
          (CATEGORY |domain| (SIGNATURE * ($ $ $))
           (SIGNATURE |coerce| ((|FreeMonoid| |#1|) $))
           (SIGNATURE |first| (|#1| $)) (SIGNATURE |left| ($ $))
           (SIGNATURE |length| ((|PositiveInteger|) $))
           (SIGNATURE |lexico| ((|Boolean|) $ $)) (SIGNATURE |mirror| ($ $))
           (SIGNATURE |rest| ($ $)) (SIGNATURE |retractable?| ((|Boolean|) $))
           (SIGNATURE |right| ($ $)) (SIGNATURE |varList| ((|List| |#1|) $))))
  (|OrderedSet|))
 (T |FreeMagma|))
(|Join| (|OrderedSet|) (|RetractableTo| |#1|)
        (CATEGORY |domain| (SIGNATURE * ($ $ $))
         (SIGNATURE |coerce| ((|FreeMonoid| |#1|) $))
         (SIGNATURE |first| (|#1| $)) (SIGNATURE |left| ($ $))
         (SIGNATURE |length| ((|PositiveInteger|) $))
         (SIGNATURE |lexico| ((|Boolean|) $ $)) (SIGNATURE |mirror| ($ $))
         (SIGNATURE |rest| ($ $)) (SIGNATURE |retractable?| ((|Boolean|) $))
         (SIGNATURE |right| ($ $)) (SIGNATURE |varList| ((|List| |#1|) $))))
"/git/fricas/src/algebra/FMAGMA.spad"
((* (*1 *1 *1 *1)
    (AND (|isDomain| *1 (|FreeMagma| *2)) (|ofCategory| *2 (|OrderedSet|))))
 (|coerce| (*1 *2 *1)
           (AND (|isDomain| *2 (|FreeMonoid| *3))
                (|isDomain| *1 (|FreeMagma| *3))
                (|ofCategory| *3 (|OrderedSet|))))
 (|first| (*1 *2 *1)
  (AND (|isDomain| *1 (|FreeMagma| *2)) (|ofCategory| *2 (|OrderedSet|))))
 (|left| (*1 *1 *1)
  (AND (|isDomain| *1 (|FreeMagma| *2)) (|ofCategory| *2 (|OrderedSet|))))
 (|length| (*1 *2 *1)
  (AND (|isDomain| *2 (|PositiveInteger|)) (|isDomain| *1 (|FreeMagma| *3))
       (|ofCategory| *3 (|OrderedSet|))))
 (|lexico| (*1 *2 *1 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|FreeMagma| *3))
       (|ofCategory| *3 (|OrderedSet|))))
 (|mirror| (*1 *1 *1)
  (AND (|isDomain| *1 (|FreeMagma| *2)) (|ofCategory| *2 (|OrderedSet|))))
 (|rest| (*1 *1 *1)
  (AND (|isDomain| *1 (|FreeMagma| *2)) (|ofCategory| *2 (|OrderedSet|))))
 (|retractable?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|FreeMagma| *3))
       (|ofCategory| *3 (|OrderedSet|))))
 (|right| (*1 *1 *1)
  (AND (|isDomain| *1 (|FreeMagma| *2)) (|ofCategory| *2 (|OrderedSet|))))
 (|varList| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| *3)) (|isDomain| *1 (|FreeMagma| *3))
       (|ofCategory| *3 (|OrderedSet|)))))
((~= (((|Boolean|) $ $) NIL)) (|varList| (((|List| |#1|) $) 14))
 (|smaller?| (((|Boolean|) $ $) NIL)) (|right| (($ $) 18))
 (|retractable?| (((|Boolean|) $) 19))
 (|retractIfCan| (((|Union| |#1| "failed") $) 22)) (|retract| ((|#1| $) 20))
 (|rest| (($ $) 36)) (|mirror| (($ $) 24)) (|min| (($ $ $) NIL))
 (|max| (($ $ $) NIL)) (|lexico| (((|Boolean|) $ $) 42))
 (|length| (((|PositiveInteger|) $) 38)) (|left| (($ $) 17))
 (|latex| (((|String|) $) NIL))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) NIL))
 (|hash| (((|SingleInteger|) $) NIL)) (|first| ((|#1| $) 35))
 (|coerce| (((|OutputForm|) $) 31) (($ |#1|) 23) (((|FreeMonoid| |#1|) $) 27))
 (>= (((|Boolean|) $ $) NIL)) (> (((|Boolean|) $ $) NIL))
 (= (((|Boolean|) $ $) 12)) (<= (((|Boolean|) $ $) NIL))
 (< (((|Boolean|) $ $) 40)) (* (($ $ $) 34)))
FMAGMA
(((|OrderedSet|) . T) ((|RetractableTo| |#1|) . T))
(((|BasicType|) . T) ((|CoercibleTo| (|OutputForm|)) . T) ((|Comparable|) . T)
 ((|OrderedSet|) . T) ((|PartialOrder|) . T) ((|RetractableTo| |#1|) . T)
 ((|SetCategory|) . T))
((|constructor|
  (NIL
   "This type is the basic representation of parenthesized words (binary trees over arbitrary symbols) useful in \\spadtype{LiePolynomial}. \\newline Author: Michel Petitot (petitot@lifl.\\spad{fr})."))
 (|varList|
  (((|List| |#1|) $)
   "\\spad{varList(x)} returns the list of distinct entries of \\spad{x}."))
 (|right|
  (($ $)
   "\\spad{right(x)} returns right subtree of \\spad{x} or error if \\spadopFrom{retractable?}{FreeMagma}(\\spad{x}) is \\spad{true}."))
 (|retractable?|
  (((|Boolean|) $)
   "\\spad{retractable?(x)} tests if \\spad{x} is a tree with only one entry."))
 (|rest|
  (($ $)
   "\\spad{rest(x)} return \\spad{x} without the first entry or error if \\spadopFrom{retractable?}{FreeMagma}(\\spad{x}) is \\spad{true}."))
 (|mirror|
  (($ $)
   "\\spad{mirror(x)} returns the reversed word of \\spad{x}. That is \\spad{x} itself if \\spadopFrom{retractable?}{FreeMagma}(\\spad{x}) is \\spad{true} and \\spad{mirror(z) * mirror(y)} if \\spad{x} is \\spad{y*z}."))
 (|lexico|
  (((|Boolean|) $ $)
   "\\spad{lexico(x,{} y)} returns \\spad{true} iff \\spad{x} is smaller than \\spad{y} \\spad{w}.\\spad{r}.\\spad{t}. the lexicographical ordering induced by \\spad{VarSet}. \\spad{N}.\\spad{B}. This operation does not take into account the tree structure of its arguments. Thus this is not a total ordering."))
 (|length|
  (((|PositiveInteger|) $)
   "\\spad{length(x)} returns the number of entries in \\spad{x}."))
 (|left|
  (($ $)
   "\\spad{left(x)} returns left subtree of \\spad{x} or error if \\spadopFrom{retractable?}{FreeMagma}(\\spad{x}) is \\spad{true}."))
 (|first|
  ((|#1| $) "\\spad{first(x)} returns the first entry of the tree \\spad{x}."))
 (|coerce|
  (((|FreeMonoid| |#1|) $)
   "\\spad{coerce(x)} returns the element of \\spadtype{FreeMonoid}(VarSet) corresponding to \\spad{x} by removing parentheses."))
 (* (($ $ $) "\\spad{x*y} returns the tree \\spad{[x,{} y]}.")))
(("documentation" 0 3494) ("ancestors" 0 3317) ("parents" 0 3265)
 ("abbreviation" 0 3258) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 2446) ("modemaps" 0 1153) ("sourceFile" 0 1115)
 ("constructorCategory" 0 620) ("constructorModemap" 0 52)
 ("constructorKind" 0 43) ("constructorForm" 0 20))