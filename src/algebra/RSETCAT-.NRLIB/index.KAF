12984               (|RegularTriangularSetCategory&| S R E V P)
|domain|
(((|RegularTriangularSetCategory&| |#1| |#2| |#3| |#4| |#5|)
  (CATEGORY |domain|
   (SIGNATURE |extend| ((|List| |#1|) (|List| |#5|) (|List| |#1|)))
   (SIGNATURE |extend| ((|List| |#1|) (|List| |#5|) |#1|))
   (SIGNATURE |extend| ((|List| |#1|) |#5| (|List| |#1|)))
   (SIGNATURE |extend| ((|List| |#1|) |#5| |#1|))
   (SIGNATURE |augment| ((|List| |#1|) (|List| |#5|) (|List| |#1|)))
   (SIGNATURE |augment| ((|List| |#1|) (|List| |#5|) |#1|))
   (SIGNATURE |augment| ((|List| |#1|) |#5| (|List| |#1|)))
   (SIGNATURE |augment| ((|List| |#1|) |#5| |#1|))
   (SIGNATURE |intersect| ((|List| |#1|) |#5| (|List| |#1|)))
   (SIGNATURE |intersect| ((|List| |#1|) (|List| |#5|) (|List| |#1|)))
   (SIGNATURE |intersect| ((|List| |#1|) (|List| |#5|) |#1|))
   (SIGNATURE |intersect| ((|List| |#1|) |#5| |#1|))
   (SIGNATURE |purelyAlgebraicLeadingMonomial?| ((|Boolean|) |#5| |#1|))
   (SIGNATURE |purelyAlgebraic?| ((|Boolean|) |#1|))
   (SIGNATURE |algebraicCoefficients?| ((|Boolean|) |#5| |#1|))
   (SIGNATURE |purelyTranscendental?| ((|Boolean|) |#5| |#1|))
   (SIGNATURE |purelyAlgebraic?| ((|Boolean|) |#5| |#1|))
   (SIGNATURE |extend| (|#1| |#1| |#5|)))
  (|RegularTriangularSetCategory| |#2| |#3| |#4| |#5|) (|GcdDomain|)
  (|OrderedAbelianMonoidSup|) (|OrderedSet|)
  (|RecursivePolynomialCategory| |#2| |#3| |#4|))
 (T |RegularTriangularSetCategory&|))
(CATEGORY |domain|
 (SIGNATURE |extend| ((|List| |#1|) (|List| |#5|) (|List| |#1|)))
 (SIGNATURE |extend| ((|List| |#1|) (|List| |#5|) |#1|))
 (SIGNATURE |extend| ((|List| |#1|) |#5| (|List| |#1|)))
 (SIGNATURE |extend| ((|List| |#1|) |#5| |#1|))
 (SIGNATURE |augment| ((|List| |#1|) (|List| |#5|) (|List| |#1|)))
 (SIGNATURE |augment| ((|List| |#1|) (|List| |#5|) |#1|))
 (SIGNATURE |augment| ((|List| |#1|) |#5| (|List| |#1|)))
 (SIGNATURE |augment| ((|List| |#1|) |#5| |#1|))
 (SIGNATURE |intersect| ((|List| |#1|) |#5| (|List| |#1|)))
 (SIGNATURE |intersect| ((|List| |#1|) (|List| |#5|) (|List| |#1|)))
 (SIGNATURE |intersect| ((|List| |#1|) (|List| |#5|) |#1|))
 (SIGNATURE |intersect| ((|List| |#1|) |#5| |#1|))
 (SIGNATURE |purelyAlgebraicLeadingMonomial?| ((|Boolean|) |#5| |#1|))
 (SIGNATURE |purelyAlgebraic?| ((|Boolean|) |#1|))
 (SIGNATURE |algebraicCoefficients?| ((|Boolean|) |#5| |#1|))
 (SIGNATURE |purelyTranscendental?| ((|Boolean|) |#5| |#1|))
 (SIGNATURE |purelyAlgebraic?| ((|Boolean|) |#5| |#1|))
 (SIGNATURE |extend| (|#1| |#1| |#5|)))
"/git/fricas/src/algebra/RSETCAT.spad"
((|purelyTranscendental?| (((|Boolean|) |#5| $) 20))
 (|purelyAlgebraicLeadingMonomial?| (((|Boolean|) |#5| $) 23))
 (|purelyAlgebraic?| (((|Boolean|) |#5| $) 16) (((|Boolean|) $) 44))
 (|intersect| (((|List| $) |#5| $) NIL) (((|List| $) (|List| |#5|) $) 76)
  (((|List| $) (|List| |#5|) (|List| $)) 74) (((|List| $) |#5| (|List| $)) 77))
 (|extend| (($ $ |#5|) NIL) (((|List| $) |#5| $) NIL)
  (((|List| $) |#5| (|List| $)) 59) (((|List| $) (|List| |#5|) $) 61)
  (((|List| $) (|List| |#5|) (|List| $)) 63))
 (|augment| (((|List| $) |#5| $) NIL) (((|List| $) |#5| (|List| $)) 53)
  (((|List| $) (|List| |#5|) $) 55) (((|List| $) (|List| |#5|) (|List| $)) 57))
 (|algebraicCoefficients?| (((|Boolean|) |#5| $) 26)))
RSETCAT-
((|constructor|
  (NIL
   "The category of regular triangular sets,{} introduced under the name regular chains in [1] (and other papers). In [3] it is proved that regular triangular sets and towers of simple extensions of a field are equivalent notions. In the following definitions,{} all polynomials and ideals are taken from the polynomial ring \\spad{k[x1,{} ...,{} xn]} where \\spad{k} is the fraction field of \\spad{R}. The triangular set \\spad{[t1,{} ...,{} tm]} is regular iff for every \\spad{i} the initial of \\spad{ti+1} is invertible in the tower of simple extensions associated with \\spad{[t1,{} ...,{} \\spad{ti}]}. A family \\spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Kalkbrener of a given ideal \\spad{I} iff the radical of \\spad{I} is equal to the intersection of the radical ideals generated by the saturated ideals of the \\spad{[T1,{} ...,{} \\spad{Ti}]}. A family \\spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Kalkbrener of a given triangular set \\spad{T} iff it is a split of Kalkbrener of the saturated ideal of \\spad{T}. Let \\spad{K} be an algebraic closure of \\spad{k}. Assume that \\spad{V} is finite with cardinality \\spad{n} and let \\spad{A} be the affine space \\spad{K^n}. For a regular triangular set \\spad{T} let denote by \\spad{W(T)} the set of regular zeros of \\spad{T}. A family \\spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Lazard of a given subset \\spad{S} of \\spad{A} iff the union of the \\spad{W(\\spad{Ti})} contains \\spad{S} and is contained in the closure of \\spad{S} (\\spad{w}.\\spad{r}.\\spad{t}. Zariski topology). A family \\spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Lazard of a given triangular set \\spad{T} if it is a split of Lazard of \\spad{W(T)}. Note that if \\spad{[T1,{} ...,{} Ts]} is a split of Lazard of \\spad{T} then it is also a split of Kalkbrener of \\spad{T}. The converse is \\spad{false}. This category provides operations related to both kinds of splits,{} the former being related to ideals decomposition whereas the latter deals with varieties decomposition. See the example illustrating the \\spadtype{RegularTriangularSet} constructor for more explanations about decompositions by means of regular triangular sets. \\newline"))
 (|zeroSetSplit|
  (((|List| $) (|List| |#5|) (|Boolean|))
   "\\spad{zeroSetSplit(lp,{} clos?)} returns \\spad{lts} a split of Kalkbrener of the radical ideal associated with \\spad{lp}. If \\spad{clos?} is \\spad{false},{} it is also a decomposition of the variety associated with \\spad{lp} into the regular zero set of the \\spad{ts} in \\spad{lts} (or,{} in other words,{} a split of Lazard of this variety). See the example illustrating the \\spadtype{RegularTriangularSet} constructor for more explanations about decompositions by means of regular triangular sets."))
 (|extend|
  (((|List| $) (|List| |#5|) (|List| $))
   "\\spad{extend(lp,{} lts)} returns the same as \\spad{concat([extend(lp,{} ts) for ts in lts])|}")
  (((|List| $) (|List| |#5|) $)
   "\\spad{extend(lp,{} ts)} returns \\spad{ts} if \\spad{empty? lp} \\spad{extend(p,{} ts)} if \\spad{lp = [p]} else \\spad{extend(first lp,{} extend(rest lp,{} ts))}")
  (((|List| $) |#5| (|List| $))
   "\\spad{extend(p,{} lts)} returns the same as \\spad{concat([extend(p,{} ts) for ts in lts])|}")
  (((|List| $) |#5| $)
   "\\spad{extend(p,{} ts)} assumes that \\spad{p} is a non-constant polynomial whose main variable is greater than any variable of \\spad{ts}. Then it returns a split of Kalkbrener of \\spad{ts+p}. This may not be \\spad{ts+p} itself,{} if for instance \\spad{ts+p} is not a regular triangular set."))
 (|internalAugment|
  (($ (|List| |#5|) $)
   "\\spad{internalAugment(lp,{} ts)} returns \\spad{ts} if \\spad{lp} is empty otherwise returns \\spad{internalAugment(rest lp,{} internalAugment(first lp,{} ts))}")
  (($ |#5| $)
   "\\spad{internalAugment(p,{} ts)} assumes that \\spad{augment(p,{} ts)} returns a singleton and returns it."))
 (|augment|
  (((|List| $) (|List| |#5|) (|List| $))
   "\\spad{augment(lp,{} lts)} returns the same as \\spad{concat([augment(lp,{} ts) for ts in lts])}")
  (((|List| $) (|List| |#5|) $)
   "\\spad{augment(lp,{} ts)} returns \\spad{ts} if \\spad{empty? lp},{} \\spad{augment(p,{} ts)} if \\spad{lp = [p]},{} otherwise \\spad{augment(first lp,{} augment(rest lp,{} ts))}")
  (((|List| $) |#5| (|List| $))
   "\\spad{augment(p,{} lts)} returns the same as \\spad{concat([augment(p,{} ts) for ts in lts])}")
  (((|List| $) |#5| $)
   "\\spad{augment(p,{} ts)} assumes that \\spad{p} is a non-constant polynomial whose main variable is greater than any variable of \\spad{ts}. This operation assumes also that if \\spad{p} is added to \\spad{ts} the resulting set,{} say \\spad{ts+p},{} is a regular triangular set. Then it returns a split of Kalkbrener of \\spad{ts+p}. This may not be \\spad{ts+p} itself,{} if for instance \\spad{ts+p} is required to be square-free."))
 (|intersect|
  (((|List| $) |#5| (|List| $))
   "\\spad{intersect(p,{} lts)} returns the same as \\spad{intersect([p],{} lts)}")
  (((|List| $) (|List| |#5|) (|List| $))
   "\\spad{intersect(lp,{} lts)} returns the same as \\spad{concat([intersect(lp,{} ts) for ts in lts])|}")
  (((|List| $) (|List| |#5|) $)
   "\\spad{intersect(lp,{} ts)} returns \\spad{lts} a split of Lazard of the intersection of the affine variety associated with \\spad{lp} and the regular zero set of \\spad{ts}.")
  (((|List| $) |#5| $)
   "\\spad{intersect(p,{} ts)} returns the same as \\spad{intersect([p],{} ts)}"))
 (|squareFreePart|
  (((|List| (|Record| (|:| |val| |#5|) (|:| |tower| $))) |#5| $)
   "\\spad{squareFreePart(p,{} ts)} returns \\spad{lpwt} such that \\spad{lpwt.i.val} is a square-free polynomial \\spad{w}.\\spad{r}.\\spad{t}. \\spad{lpwt.i.tower},{} this polynomial being associated with \\spad{p} modulo \\spad{lpwt.i.tower},{} for every \\spad{i}. Moreover,{} the list of the \\spad{lpwt.i.tower} is a split of Kalkbrener of \\spad{ts}. WARNING: This assumes that \\spad{p} is a non-constant polynomial such that if \\spad{p} is added to \\spad{ts},{} then the resulting set is a regular triangular set."))
 (|lastSubResultant|
  (((|List| (|Record| (|:| |val| |#5|) (|:| |tower| $))) |#5| |#5| $)
   "\\spad{lastSubResultant(p1,{} p2,{} ts)} returns \\spad{lpwt} such that \\spad{lpwt.i.val} is a quasi-monic \\spad{gcd} of \\spad{p1} and \\spad{p2} \\spad{w}.\\spad{r}.\\spad{t}. \\spad{lpwt.i.tower},{} for every \\spad{i},{} and such that the list of the \\spad{lpwt.i.tower} is a split of Kalkbrener of \\spad{ts}. Moreover,{} if \\spad{p1} and \\spad{p2} do not have a non-trivial \\spad{gcd} \\spad{w}.\\spad{r}.\\spad{t}. \\spad{lpwt.i.tower} then \\spad{lpwt.i.val} is the resultant of these polynomials \\spad{w}.\\spad{r}.\\spad{t}. \\spad{lpwt.i.tower}. This assumes that \\spad{p1} and \\spad{p2} have the same maim variable and that this variable is greater that any variable occurring in \\spad{ts}."))
 (|lastSubResultantElseSplit|
  (((|Union| |#5| (|List| $)) |#5| |#5| $)
   "\\spad{lastSubResultantElseSplit(p1,{} p2,{} ts)} returns either \\spad{g} a quasi-monic \\spad{gcd} of \\spad{p1} and \\spad{p2} \\spad{w}.\\spad{r}.\\spad{t}. the \\spad{ts} or a split of Kalkbrener of \\spad{ts}. This assumes that \\spad{p1} and \\spad{p2} have the same maim variable and that this variable is greater that any variable occurring in \\spad{ts}."))
 (|invertibleSet|
  (((|List| $) |#5| $)
   "\\spad{invertibleSet(p,{} ts)} returns a split of Kalkbrener of the quotient ideal of the ideal \\spad{I} by \\spad{p} where \\spad{I} is the radical of saturated of \\spad{ts}."))
 (|invertible?|
  (((|Boolean|) |#5| $)
   "\\spad{invertible?(p,{} ts)} returns \\spad{true} iff \\spad{p} is invertible in the tower associated with \\spad{ts}.")
  (((|List| (|Record| (|:| |val| (|Boolean|)) (|:| |tower| $))) |#5| $)
   "\\spad{invertible?(p,{} ts)} returns \\spad{lbwt} where \\spad{lbwt.i} is the result of \\spad{invertibleElseSplit?(p,{} lbwt.i.tower)} and the list of the \\spad{(lqrwt.i).tower} is a split of Kalkbrener of \\spad{ts}."))
 (|invertibleElseSplit?|
  (((|Union| (|Boolean|) (|List| $)) |#5| $)
   "\\spad{invertibleElseSplit?(p,{} ts)} returns \\spad{true} (resp. \\spad{false}) if \\spad{p} is invertible in the tower associated with \\spad{ts} or returns a split of Kalkbrener of \\spad{ts}."))
 (|purelyAlgebraicLeadingMonomial?|
  (((|Boolean|) |#5| $)
   "\\spad{purelyAlgebraicLeadingMonomial?(p,{} ts)} returns \\spad{true} iff the main variable of any non-constant iterarted initial of \\spad{p} is algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))
 (|algebraicCoefficients?|
  (((|Boolean|) |#5| $)
   "\\spad{algebraicCoefficients?(p,{} ts)} returns \\spad{true} iff every variable of \\spad{p} which is not the main one of \\spad{p} is algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}."))
 (|purelyTranscendental?|
  (((|Boolean|) |#5| $)
   "\\spad{purelyTranscendental?(p,{} ts)} returns \\spad{true} iff every variable of \\spad{p} is not algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}"))
 (|purelyAlgebraic?|
  (((|Boolean|) $)
   "\\spad{purelyAlgebraic?(ts)} returns \\spad{true} iff for every algebraic variable \\spad{v} of \\spad{ts} we have \\spad{algebraicCoefficients?(t_v,{} ts_v_-)} where \\spad{ts_v} is \\spadopFrom{select}{TriangularSetCategory}(\\spad{ts},{} \\spad{v}) and \\spad{ts_v_-} is \\spadopFrom{collectUnder}{TriangularSetCategory}(\\spad{ts},{} \\spad{v}).")
  (((|Boolean|) |#5| $)
   "\\spad{purelyAlgebraic?(p,{} ts)} returns \\spad{true} iff every variable of \\spad{p} is algebraic \\spad{w}.\\spad{r}.\\spad{t}. \\spad{ts}.")))
(("documentation" 0 3258) ("ancestors" 0 NIL) ("parents" 0 NIL)
 ("abbreviation" 0 3249) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 2533) ("modemaps" 0 NIL) ("sourceFile" 0 2494)
 ("constructorCategory" 0 1434) ("constructorModemap" 0 73)
 ("constructorKind" 0 64) ("constructorForm" 0 20))