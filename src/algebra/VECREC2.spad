)abbrev domain VECREC2 VectorIntegerReconstructor
++ Description: This domain supports modular methods based on
++  evaluation and rational reconstruction.  Each evaluation
++  is done modulo machine sized prime p.  Both Chinese
++  remaindering and (linear) Hensel lift are supported.
++  Once enough evaluations are known rational reconstruction
++  produces vector of rational numbers or integers.
VectorIntegerReconstructor() : Export == Implementation where
   RatRec ==> Record(num : Integer, den : Integer)
   PAI ==> PrimitiveArray Integer
   RR ==> Record(numers : PAI, denoms : PAI)
   VI ==> Vector Integer
   Export ==> with
       empty : (Integer) -> %
         ++ empty(n) produces reconstructor with n slots
       chinese_update : (U32Vector, Integer, %) -> Void
         ++ chinese_update(v, p, r) informs r about evaluation at p
       hensel_update : (U32Vector, Integer, %) -> Void
         ++ one step of Hensel lifting
       rational_reconstruction : (Integer, Integer, Integer, Integer) -> _
           Union(RatRec, "failed")
       rational_reconstruction : % -> Union(RR, "failed")
       remove_denoms : (VI, PAI, PAI) -> PAI
         ++ remove common denominators in blocks
       reconstruct : (%, VI) -> Union(PAI, "failed")
         ++ combines rational reconstruction with removal of
         ++ common denominators in blocks.

   Implementation ==> add
       Rep := Record(cmod : Integer, curj : Integer,  _
                     nmods : Integer, nints : Integer, _
                     ints : PrimitiveArray Integer,
                     bints : PrimitiveArray Integer,
                     bcmod : Integer, bnmods : Integer,
                     nrecs : Integer,
                     numers : PrimitiveArray Integer,
                     denoms : PrimitiveArray Integer)


       modInverse(c : Integer, p : Integer) : Integer ==
          (extendedEuclidean(c, p, 1)::Record(coef1 : Integer, _
               coef2 : Integer)).coef1

       empty(nint) ==
           intvec := new(nint::NonNegativeInteger, _
                          0)$PrimitiveArray(Integer)
           [1, 0, 0, nint, intvec, empty()$PrimitiveArray(Integer), _
            1, 0, 0, empty()$PrimitiveArray(Integer), _
            empty()$PrimitiveArray(Integer)]$Rep

       chinese_update(vec, p, statearg) ==
           state := statearg::Rep
           mp := state.cmod
           mpval := positiveRemainder(mp, p)
           mpval = 0 => error "Duplicate modulus in update"
           mpcor := modInverse(mpval, p)
           mpfact := mpcor*mp
           nmp := mp*p
           mpfact := positiveRemainder(mpfact, nmp)
           state.nmods := state.nmods + 1
           intvec := state.ints
           for i in 0..(state.nints - 1) repeat
               ii := intvec(i)
               cor := positiveRemainder(vec(i) - ii, p)
               intvec(i) := positiveRemainder(ii + mpfact*cor, nmp)
           if state.nmods >= 200 and
             positiveRemainder(state.nmods, 100) = 0 then
               state.bnmods := state.nmods
               empty?(state.bints) =>
                   state.bints := new(state.nints::NonNegativeInteger, _
                          0)$PrimitiveArray(Integer)
                   bintvec := state.bints
                   for i in 0..(state.nints - 1) repeat
                       bintvec(i) := intvec(i)
                       intvec(i) := 0
                   state.bcmod := nmp
                   nmp := 1
               bintvec := state.bints
               bmp := state.bcmod
               mpval := positiveRemainder(bmp, nmp)
               mpcor := modInverse(mpval, nmp)
               mpfact := mpcor*bmp
               nbmp := bmp*nmp
               mpfact := positiveRemainder(mpfact, nbmp)
               for i in 0..(state.nints - 1) repeat
                   ii := bintvec(i)
                   cor := positiveRemainder(intvec(i) - ii, nmp)
                   bintvec(i) := positiveRemainder(ii + mpfact*cor, nbmp)
                   intvec(i) := 0
               state.bcmod := nbmp
               nmp := 1
           state.cmod := nmp

       hensel_update(vec, p, statearg) ==
           state := statearg::Rep
           mp := state.cmod
           intvec := state.ints
           for i in 0..(state.nints - 1) repeat
               intvec(i) := intvec(i) + vec(i)*mp
           state.cmod := p*mp

       rational_reconstruction(x : Integer, y : Integer, i : Integer, _
                 j : Integer) : Union(RatRec, "failed") ==
           r0 : Integer := y
           s0 : Integer := 0
           r1 : Integer := positiveRemainder(x, y)
           s1 : Integer := 1
           while r1 > i repeat
               qr := divide(r0, r1)
               r0 := r1
               r1 := qr.remainder
               tmp := s0 - qr.quotient*s1
               s0 := s1
               s1 := tmp
           if s1 < 0 then
               s1 := -s1
               r1 := -r1
           s1 > j => "failed"
           gcd(s1, y) ~= 1 => "failed"
           [r1, s1]


       rational_reconstruction2(statearg : %, block_offsets : VI) _
               : Union(RR, "failed") ==
           state := statearg::Rep
           modulus := state.cmod
           intvec := state.ints
           if state.nmods >= 200 then
               if state.nmods - state.nrecs < 150 then
                   state.cmod ~= 1 =>
                       positiveRemainder(state.nmods, 100) = 0 =>
                           error "impossible"
                       return "failed"
               state.nrecs := state.bnmods
               modulus := state.bcmod
               intvec := state.bints
           j0 := state.curj
           bound := approxSqrt(modulus)$IntegerRoots(Integer) quo 10
           bound2 := modulus - bound
           ok := true
           pp := rational_reconstruction(intvec(j0), modulus, bound, bound)
           pp case "failed" => "failed"
           n := state.nints
           mm := #block_offsets
           if empty?(state.numers) then
               state.numers := new(n::NonNegativeInteger, _
                                   0)$PrimitiveArray(Integer)
               state.denoms := new(n::NonNegativeInteger, _
                                   0)$PrimitiveArray(Integer)
           nums := state.numers
           dens := state.denoms
           ppr := pp :: RatRec
           nums(j0) := ppr.num
           dens(j0) := ppr.den
           cden := ppr.den
           co : Integer := 0
           cb : Integer := 1
           for jj in 1..mm repeat
              ctmp := block_offsets(jj)
              if ctmp > j0 then
                  cb := jj
                  co := ctmp
                  break
           j := j0
           repeat
               j := j + 1
               if j >= n then j := j - n
               if j = co and mm > 1 then
                   cden := 1
                   cb :=
                       cb = mm => 1
                       cb + 1
                   co := block_offsets(cb)
               j = j0 => return [nums, dens]
               r1 := positiveRemainder(cden*intvec(j), modulus)
               r1 < bound =>
                   nums(j) := r1
                   dens(j) := cden
               r1 > bound2 =>
                   nums(j) := r1 - modulus
                   dens(j) := cden
               pp := rational_reconstruction(r1, modulus, bound, bound)
               pp case "failed" =>
                   state.curj := j
                   return "failed"
               ppr := pp :: RatRec
               cden := cden*ppr.den
               cden > bound =>
                   state.curj := j
                   return "failed"
               nums(j) := ppr.num
               dens(j) := cden

       rational_reconstruction(statearg : %) : Union(RR, "failed") ==
           rational_reconstruction2(statearg, new(1, 0)$VI)

       lcm(nums : PAI, lo : Integer, hi : Integer) : Integer ==
           res := nums(lo)
           for i in (lo + 1)..hi repeat
               res := lcm(res, nums(i))
           res

       gcd(nums : PAI, lo : Integer, hi : Integer) : Integer ==
           res := nums(lo)
           for i in (lo + 1)..hi repeat
               res := gcd(res, nums(i))
           res

       remove_denoms(block_offsets : VI, nums : PAI, _
                      dens : PAI) : PAI ==
            nb := #block_offsets
            np := #nums
            res := new(np, 0)$PAI
            for ib in 1..nb repeat
                li := block_offsets(ib)
                hi : Integer :=
                    ib = nb => np
                    block_offsets(ib + 1)
                hi := hi - 1
                cden := lcm(dens, li, hi)
                for i in li..hi repeat
                    tmpp2  := (cden exquo dens(i))::Integer
                    res(i) := nums(i)*tmpp2
                cfactor := gcd(res, li, hi)
                if cfactor ~= 1 and cfactor ~= 0 then
                    for i in li..hi repeat
                        res(i) := (res(i) exquo cfactor)::Integer
            res

       reconstruct(statearg : %, block_offsets : VI) : _
               Union(PAI, "failed") ==
           pp := rational_reconstruction2(statearg, block_offsets)
           pp case "failed" => return "failed"
           ppr := pp::RR
           remove_denoms(block_offsets, ppr.numers, ppr.denoms)
