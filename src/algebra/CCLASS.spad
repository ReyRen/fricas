)abbrev domain CCLASS CharacterClass
++ Author: Stephen M. Watt
++ Date Created: July 1986
++ Basic Operations: charClass
++ Related Domains: Character, Bits
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
++   This domain allows classes of characters to be defined and manipulated
++   efficiently.


CharacterClass : Join(SetCategory, ConvertibleTo String,
  FiniteSetAggregate Character, ConvertibleTo List Character) with
        charClass : String -> %
            ++ charClass(s) creates a character class which contains
            ++ exactly the characters given in the string s.
        charClass : List Character -> %
            ++ charClass(l) creates a character class which contains
            ++ exactly the characters given in the list l.
        digit :  constant -> %
            ++ digit() returns the class of all characters
            ++ for which \spadfunFrom{digit?}{Character} is true.
        hexDigit : constant -> %
            ++ hexDigit() returns the class of all characters for which
            ++ \spadfunFrom{hexDigit?}{Character} is true.
        upperCase : constant -> %
            ++ upperCase() returns the class of all characters for which
            ++ \spadfunFrom{upperCase?}{Character} is true.
        lowerCase :  constant -> %
            ++ lowerCase() returns the class of all characters for which
            ++ \spadfunFrom{lowerCase?}{Character} is true.
        alphabetic  :  constant -> %
            ++ alphabetic() returns the class of all characters for which
            ++ \spadfunFrom{alphabetic?}{Character} is true.
        alphanumeric :  constant -> %
            ++ alphanumeric() returns the class of all characters for which
            ++ \spadfunFrom{alphanumeric?}{Character} is true.

    == add
        Rep := IndexedBits(0)
        -- N   := size()$Character

        import from Character

        N   := 256

        a, b : %

        digit()         == charClass "0123456789"
        hexDigit()      == charClass "0123456789abcdefABCDEF"
        upperCase()     == charClass "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        lowerCase()     == charClass "abcdefghijklmnopqrstuvwxyz"
        alphabetic()    == union(upperCase(), lowerCase())
        alphanumeric()  == union(alphabetic(), digit())

        a = b           == a =$Rep b

        member?(c, a)   ==
            (i := ord c) < N => a(i)
            false

        union(a, b)      == Or(a, b)
        intersect (a, b) == And(a, b)
        difference(a, b) == And(a, Not b)
        -- FIXME: this is bogus for codes >= N
        complement a    == Not a

        convert(cl) : String ==
          construct(convert(cl)@List(Character))
        convert(cl : %) : List(Character) ==
          [char(i) for i in 0..N-1 | cl.i]

        charClass(s : String) ==
            cl := new(N, false)
            for i in minIndex(s)..maxIndex(s) repeat
                (j := ord s.i) >= N => error "character code too large"
                cl(j) := true
            cl

        charClass(l : List Character) ==
            cl := new(N, false)
            for c in l repeat
                (j := ord c) >= N => error "character code too large"
                cl(j) := true
            cl

        coerce(cl) : OutputForm == (convert(cl)@String)::OutputForm

        -- Stuff to make a legal SetAggregate view
        # a             == (n := 0; for i in 0..N-1 | a.i repeat n := n+1; n)
        empty() : %       == charClass []
        set() : % == empty()

        insert!(c, a)  ==
            (i := ord c) < N => (a(i) := true; a)
            error "character code too large"

        remove!(c : Character, a)  ==
            if(i := ord c) < N then a(i) := false
            a

        inspect(a) ==
            for i in 0..N-1 | a.i repeat
                 return char i
            error "Cannot take a character from an empty class."

        extract!(a) ==
            for i in 0..N-1 | a.i repeat
                 a.i := false
                 return char i
            error "Cannot take a character from an empty class."

        map(f, a) ==
            b := new(N, false)
            for i in 0..N-1 | a.i repeat b(ord f char i) := true
            b

        temp : % := new(N, false)$Rep
        map!(f, a) ==
            fill!(temp, false)
            for i in 0..N-1 | a.i repeat temp(ord f char i) := true
            copyInto!(a, temp, 0)

        parts a ==
            [char i for i in 0..N-1 | a.i]

