27448               (|FiniteRankNonAssociativeAlgebra| R)
|category|
(((|FiniteRankNonAssociativeAlgebra| |#1|) (|Category|) (|CommutativeRing|))
 (T |FiniteRankNonAssociativeAlgebra|))
(|Join| (|NonAssociativeAlgebra| |t#1|)
        (CATEGORY |domain| (SIGNATURE |someBasis| ((|Vector| $)))
         (SIGNATURE |rank| ((|PositiveInteger|)))
         (SIGNATURE |conditionsForIdempotents|
          ((|List| (|Polynomial| |t#1|)) (|Vector| $)))
         (SIGNATURE |structuralConstants|
          ((|Vector| (|Matrix| |t#1|)) (|Vector| $)))
         (SIGNATURE |leftRegularRepresentation|
          ((|Matrix| |t#1|) $ (|Vector| $)))
         (SIGNATURE |rightRegularRepresentation|
          ((|Matrix| |t#1|) $ (|Vector| $)))
         (SIGNATURE |leftTrace| (|t#1| $)) (SIGNATURE |rightTrace| (|t#1| $))
         (SIGNATURE |leftNorm| (|t#1| $)) (SIGNATURE |rightNorm| (|t#1| $))
         (SIGNATURE |coordinates| ((|Vector| |t#1|) $ (|Vector| $)))
         (SIGNATURE |coordinates| ((|Matrix| |t#1|) (|Vector| $) (|Vector| $)))
         (SIGNATURE |represents| ($ (|Vector| |t#1|) (|Vector| $)))
         (SIGNATURE |leftDiscriminant| (|t#1| (|Vector| $)))
         (SIGNATURE |rightDiscriminant| (|t#1| (|Vector| $)))
         (SIGNATURE |leftTraceMatrix| ((|Matrix| |t#1|) (|Vector| $)))
         (SIGNATURE |rightTraceMatrix| ((|Matrix| |t#1|) (|Vector| $)))
         (SIGNATURE |leftCharacteristicPolynomial|
          ((|SparseUnivariatePolynomial| |t#1|) $))
         (SIGNATURE |rightCharacteristicPolynomial|
          ((|SparseUnivariatePolynomial| |t#1|) $))
         (SIGNATURE |commutative?| ((|Boolean|)))
         (SIGNATURE |antiCommutative?| ((|Boolean|)))
         (SIGNATURE |associative?| ((|Boolean|)))
         (SIGNATURE |antiAssociative?| ((|Boolean|)))
         (SIGNATURE |leftAlternative?| ((|Boolean|)))
         (SIGNATURE |rightAlternative?| ((|Boolean|)))
         (SIGNATURE |flexible?| ((|Boolean|)))
         (SIGNATURE |alternative?| ((|Boolean|)))
         (SIGNATURE |powerAssociative?| ((|Boolean|)))
         (SIGNATURE |jacobiIdentity?| ((|Boolean|)))
         (SIGNATURE |lieAdmissible?| ((|Boolean|)))
         (SIGNATURE |jordanAdmissible?| ((|Boolean|)))
         (SIGNATURE |noncommutativeJordanAlgebra?| ((|Boolean|)))
         (SIGNATURE |jordanAlgebra?| ((|Boolean|)))
         (SIGNATURE |lieAlgebra?| ((|Boolean|)))
         (IF (|has| |t#1| (|IntegralDomain|))
             (PROGN
              (SIGNATURE |recip| ((|Union| $ "failed") $))
              (SIGNATURE |leftRecip| ((|Union| $ "failed") $))
              (SIGNATURE |rightRecip| ((|Union| $ "failed") $))
              (SIGNATURE |associatorDependence| ((|List| (|Vector| |t#1|))))
              (SIGNATURE |leftMinimalPolynomial|
               ((|SparseUnivariatePolynomial| |t#1|) $))
              (SIGNATURE |rightMinimalPolynomial|
               ((|SparseUnivariatePolynomial| |t#1|) $))
              (SIGNATURE |leftUnits|
               ((|Union|
                 (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
                 "failed")))
              (SIGNATURE |rightUnits|
               ((|Union|
                 (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
                 "failed")))
              (SIGNATURE |leftUnit| ((|Union| $ "failed")))
              (SIGNATURE |rightUnit| ((|Union| $ "failed")))
              (SIGNATURE |unit| ((|Union| $ "failed")))
              (ATTRIBUTE (|unitsKnown|)))
             |noBranch|)))
"/git/fricas/src/algebra/FINAALG.spad"
((|someBasis| (*1 *2)
  (AND (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Vector| *1))
       (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))))
 (|rank| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|))
       (|isDomain| *2 (|PositiveInteger|))))
 (|conditionsForIdempotents| (*1 *2 *3)
  (AND (|isDomain| *3 (|Vector| *1))
       (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *4))
       (|ofCategory| *4 (|CommutativeRing|))
       (|isDomain| *2 (|List| (|Polynomial| *4)))))
 (|structuralConstants| (*1 *2 *3)
  (AND (|isDomain| *3 (|Vector| *1))
       (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *4))
       (|ofCategory| *4 (|CommutativeRing|))
       (|isDomain| *2 (|Vector| (|Matrix| *4)))))
 (|leftRegularRepresentation| (*1 *2 *1 *3)
  (AND (|isDomain| *3 (|Vector| *1))
       (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *4))
       (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Matrix| *4))))
 (|rightRegularRepresentation| (*1 *2 *1 *3)
  (AND (|isDomain| *3 (|Vector| *1))
       (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *4))
       (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Matrix| *4))))
 (|leftTrace| (*1 *2 *1)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *2))
       (|ofCategory| *2 (|CommutativeRing|))))
 (|rightTrace| (*1 *2 *1)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *2))
       (|ofCategory| *2 (|CommutativeRing|))))
 (|leftNorm| (*1 *2 *1)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *2))
       (|ofCategory| *2 (|CommutativeRing|))))
 (|rightNorm| (*1 *2 *1)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *2))
       (|ofCategory| *2 (|CommutativeRing|))))
 (|coordinates| (*1 *2 *1 *3)
  (AND (|isDomain| *3 (|Vector| *1))
       (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *4))
       (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Vector| *4))))
 (|coordinates| (*1 *2 *3 *3)
  (AND (|isDomain| *3 (|Vector| *1))
       (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *4))
       (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Matrix| *4))))
 (|represents| (*1 *1 *2 *3)
  (AND (|isDomain| *2 (|Vector| *4)) (|isDomain| *3 (|Vector| *1))
       (|ofCategory| *4 (|CommutativeRing|))
       (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *4))))
 (|leftDiscriminant| (*1 *2 *3)
  (AND (|isDomain| *3 (|Vector| *1))
       (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *2))
       (|ofCategory| *2 (|CommutativeRing|))))
 (|rightDiscriminant| (*1 *2 *3)
  (AND (|isDomain| *3 (|Vector| *1))
       (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *2))
       (|ofCategory| *2 (|CommutativeRing|))))
 (|leftTraceMatrix| (*1 *2 *3)
  (AND (|isDomain| *3 (|Vector| *1))
       (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *4))
       (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Matrix| *4))))
 (|rightTraceMatrix| (*1 *2 *3)
  (AND (|isDomain| *3 (|Vector| *1))
       (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *4))
       (|ofCategory| *4 (|CommutativeRing|)) (|isDomain| *2 (|Matrix| *4))))
 (|leftCharacteristicPolynomial| (*1 *2 *1)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|))
       (|isDomain| *2 (|SparseUnivariatePolynomial| *3))))
 (|rightCharacteristicPolynomial| (*1 *2 *1)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|))
       (|isDomain| *2 (|SparseUnivariatePolynomial| *3))))
 (|commutative?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|antiCommutative?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|associative?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|antiAssociative?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|leftAlternative?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|rightAlternative?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|flexible?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|alternative?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|powerAssociative?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|jacobiIdentity?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|lieAdmissible?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|jordanAdmissible?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|noncommutativeJordanAlgebra?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|jordanAlgebra?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|lieAlgebra?| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|)) (|isDomain| *2 (|Boolean|))))
 (|recip| (*1 *1 *1)
  (|partial| AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *2))
   (|ofCategory| *2 (|CommutativeRing|)) (|ofCategory| *2 (|IntegralDomain|))))
 (|leftRecip| (*1 *1 *1)
  (|partial| AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *2))
   (|ofCategory| *2 (|CommutativeRing|)) (|ofCategory| *2 (|IntegralDomain|))))
 (|rightRecip| (*1 *1 *1)
  (|partial| AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *2))
   (|ofCategory| *2 (|CommutativeRing|)) (|ofCategory| *2 (|IntegralDomain|))))
 (|associatorDependence| (*1 *2)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|))
       (|ofCategory| *3 (|IntegralDomain|))
       (|isDomain| *2 (|List| (|Vector| *3)))))
 (|leftMinimalPolynomial| (*1 *2 *1)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|))
       (|ofCategory| *3 (|IntegralDomain|))
       (|isDomain| *2 (|SparseUnivariatePolynomial| *3))))
 (|rightMinimalPolynomial| (*1 *2 *1)
  (AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))
       (|ofCategory| *3 (|CommutativeRing|))
       (|ofCategory| *3 (|IntegralDomain|))
       (|isDomain| *2 (|SparseUnivariatePolynomial| *3))))
 (|leftUnits| (*1 *2)
  (|partial| AND (|ofCategory| *3 (|IntegralDomain|))
   (|ofCategory| *3 (|CommutativeRing|))
   (|isDomain| *2 (|Record| (|:| |particular| *1) (|:| |basis| (|List| *1))))
   (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))))
 (|rightUnits| (*1 *2)
  (|partial| AND (|ofCategory| *3 (|IntegralDomain|))
   (|ofCategory| *3 (|CommutativeRing|))
   (|isDomain| *2 (|Record| (|:| |particular| *1) (|:| |basis| (|List| *1))))
   (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *3))))
 (|leftUnit| (*1 *1)
  (|partial| AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *2))
   (|ofCategory| *2 (|IntegralDomain|)) (|ofCategory| *2 (|CommutativeRing|))))
 (|rightUnit| (*1 *1)
  (|partial| AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *2))
   (|ofCategory| *2 (|IntegralDomain|)) (|ofCategory| *2 (|CommutativeRing|))))
 (|unit| (*1 *1)
  (|partial| AND (|ofCategory| *1 (|FiniteRankNonAssociativeAlgebra| *2))
   (|ofCategory| *2 (|IntegralDomain|)) (|ofCategory| *2 (|CommutativeRing|)))))
((~= (((|Boolean|) $ $) 6)) (|zero?| (((|Boolean|) $) 6))
 (|unit| (((|Union| $ "failed")) 6 (|has| |#1| (|IntegralDomain|))))
 (|subtractIfCan| (((|Union| $ "failed") $ $) 6))
 (|structuralConstants| (((|Vector| (|Matrix| |#1|)) (|Vector| $)) 6))
 (|someBasis| (((|Vector| $)) 6)) (|sample| (($) 6 T CONST))
 (|rightUnits|
  (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
             "failed"))
   6 (|has| |#1| (|IntegralDomain|))))
 (|rightUnit| (((|Union| $ "failed")) 6 (|has| |#1| (|IntegralDomain|))))
 (|rightTraceMatrix| (((|Matrix| |#1|) (|Vector| $)) 6))
 (|rightTrace| ((|#1| $) 6))
 (|rightRegularRepresentation| (((|Matrix| |#1|) $ (|Vector| $)) 6))
 (|rightRecip| (((|Union| $ "failed") $) 6 (|has| |#1| (|IntegralDomain|))))
 (|rightPower| (($ $ (|PositiveInteger|)) 6)) (|rightNorm| ((|#1| $) 6))
 (|rightMinimalPolynomial|
  (((|SparseUnivariatePolynomial| |#1|) $) 6 (|has| |#1| (|IntegralDomain|))))
 (|rightDiscriminant| ((|#1| (|Vector| $)) 6))
 (|rightCharacteristicPolynomial| (((|SparseUnivariatePolynomial| |#1|) $) 6))
 (|rightAlternative?| (((|Boolean|)) 6))
 (|represents| (($ (|Vector| |#1|) (|Vector| $)) 6))
 (|recip| (((|Union| $ "failed") $) 6 (|has| |#1| (|IntegralDomain|))))
 (|rank| (((|PositiveInteger|)) 6)) (|powerAssociative?| (((|Boolean|)) 6))
 (|plenaryPower| (($ $ (|PositiveInteger|)) 6))
 (|opposite?| (((|Boolean|) $ $) 6))
 (|noncommutativeJordanAlgebra?| (((|Boolean|)) 6))
 (|lieAlgebra?| (((|Boolean|)) 6)) (|lieAdmissible?| (((|Boolean|)) 6))
 (|leftUnits|
  (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
             "failed"))
   6 (|has| |#1| (|IntegralDomain|))))
 (|leftUnit| (((|Union| $ "failed")) 6 (|has| |#1| (|IntegralDomain|))))
 (|leftTraceMatrix| (((|Matrix| |#1|) (|Vector| $)) 6))
 (|leftTrace| ((|#1| $) 6))
 (|leftRegularRepresentation| (((|Matrix| |#1|) $ (|Vector| $)) 6))
 (|leftRecip| (((|Union| $ "failed") $) 6 (|has| |#1| (|IntegralDomain|))))
 (|leftPower| (($ $ (|PositiveInteger|)) 6)) (|leftNorm| ((|#1| $) 6))
 (|leftMinimalPolynomial|
  (((|SparseUnivariatePolynomial| |#1|) $) 6 (|has| |#1| (|IntegralDomain|))))
 (|leftDiscriminant| ((|#1| (|Vector| $)) 6))
 (|leftCharacteristicPolynomial| (((|SparseUnivariatePolynomial| |#1|) $) 6))
 (|leftAlternative?| (((|Boolean|)) 6)) (|latex| (((|String|) $) 6))
 (|jordanAlgebra?| (((|Boolean|)) 6)) (|jordanAdmissible?| (((|Boolean|)) 6))
 (|jacobiIdentity?| (((|Boolean|)) 6))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) 6))
 (|hash| (((|SingleInteger|) $) 6)) (|flexible?| (((|Boolean|)) 6))
 (|coordinates| (((|Vector| |#1|) $ (|Vector| $)) 6)
  (((|Matrix| |#1|) (|Vector| $) (|Vector| $)) 6))
 (|conditionsForIdempotents| (((|List| (|Polynomial| |#1|)) (|Vector| $)) 6))
 (|commutator| (($ $ $) 6)) (|commutative?| (((|Boolean|)) 6))
 (|coerce| (((|OutputForm|) $) 6))
 (|associatorDependence|
  (((|List| (|Vector| |#1|))) 6 (|has| |#1| (|IntegralDomain|))))
 (|associator| (($ $ $ $) 6)) (|associative?| (((|Boolean|)) 6))
 (|antiCommutator| (($ $ $) 6)) (|antiCommutative?| (((|Boolean|)) 6))
 (|antiAssociative?| (((|Boolean|)) 6)) (|alternative?| (((|Boolean|)) 6))
 (^ (($ $ (|PositiveInteger|)) 6)) (|Zero| (($) 6 T CONST))
 (= (((|Boolean|) $ $) 6)) (- (($ $ $) 6) (($ $) 6)) (+ (($ $ $) 6))
 (* (($ (|PositiveInteger|) $) 6) (($ $ $) 6) (($ (|Integer|) $) 6)
    (($ (|NonNegativeInteger|) $) 6) (($ $ |#1|) 6) (($ |#1| $) 6)))
FINAALG
(((|NonAssociativeAlgebra| |#1|) . T)
 ((|unitsKnown|) |has| |#1| (|IntegralDomain|)))
(((|AbelianGroup|) . T) ((|AbelianMonoid|) . T) ((|AbelianSemiGroup|) . T)
 ((|BasicType|) . T) ((|BiModule| |t#1| |t#1|) . T)
 ((|CancellationAbelianMonoid|) . T) ((|CoercibleTo| (|OutputForm|)) . T)
 ((|LeftModule| |t#1|) . T) ((|Magma|) . T) ((|Module| |t#1|) . T)
 ((|NonAssociativeAlgebra| |#1|) . T) ((|NonAssociativeRng|) . T)
 ((|NonAssociativeSemiRng|) . T) ((|RightModule| |t#2|) . T)
 ((|SetCategory|) . T) ((|unitsKnown|) |has| |#1| (|IntegralDomain|)))
((|constructor|
  (NIL
   "A FiniteRankNonAssociativeAlgebra is a non associative algebra over a commutative ring \\spad{R} which is a free \\spad{R}-module of finite rank."))
 (|unit|
  (((|Union| $ "failed"))
   "\\spad{unit()} returns a unit of the algebra (necessarily unique),{} or \\spad{\"failed\"} if there is none."))
 (|rightUnit|
  (((|Union| $ "failed"))
   "\\spad{rightUnit()} returns a right unit of the algebra (not necessarily unique),{} or \\spad{\"failed\"} if there is none."))
 (|leftUnit|
  (((|Union| $ "failed"))
   "\\spad{leftUnit()} returns a left unit of the algebra (not necessarily unique),{} or \\spad{\"failed\"} if there is none."))
 (|rightUnits|
  (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
             "failed"))
   "\\spad{rightUnits()} returns the affine space of all right units of the algebra,{} or \\spad{\"failed\"} if there is none."))
 (|leftUnits|
  (((|Union| (|Record| (|:| |particular| $) (|:| |basis| (|List| $)))
             "failed"))
   "\\spad{leftUnits()} returns the affine space of all left units of the algebra,{} or \\spad{\"failed\"} if there is none."))
 (|rightMinimalPolynomial|
  (((|SparseUnivariatePolynomial| |#1|) $)
   "\\spad{rightMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of right powers of \\spad{a}. Note: the polynomial never has a constant term as in general the algebra has no unit."))
 (|leftMinimalPolynomial|
  (((|SparseUnivariatePolynomial| |#1|) $)
   "\\spad{leftMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of left powers of \\spad{a}. Note: the polynomial never has a constant term as in general the algebra has no unit."))
 (|associatorDependence|
  (((|List| (|Vector| |#1|)))
   "\\spad{associatorDependence()} looks for the associator identities,{} \\spadignore{i.e.} finds a basis of the solutions of the linear combinations of the six permutations of \\spad{associator(a,{} b,{} c)} which yield 0,{} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra. The order of the permutations is \\spad{123 231 312 132 321 213}."))
 (|rightRecip|
  (((|Union| $ "failed") $)
   "\\spad{rightRecip(a)} returns an element,{} which is a right inverse of \\spad{a},{} or \\spad{\"failed\"} if there is no unit element,{} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|leftRecip|
  (((|Union| $ "failed") $)
   "\\spad{leftRecip(a)} returns an element,{} which is a left inverse of \\spad{a},{} or \\spad{\"failed\"} if there is no unit element,{} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|recip|
  (((|Union| $ "failed") $)
   "\\spad{recip(a)} returns an element,{} which is both a left and a right inverse of \\spad{a},{} or \\spad{\"failed\"} if there is no unit element,{} if such an element doesn\\spad{'t} exist or cannot be determined (see unitsKnown)."))
 (|lieAlgebra?|
  (((|Boolean|))
   "\\spad{lieAlgebra?()} tests if the algebra is anticommutative and \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra (Jacobi identity). Example: for every associative algebra \\spad{(A,{} +,{} @)} we can construct a Lie algebra \\spad{(A,{} +,{} *)},{} where \\spad{a*b := a@b-b@a}."))
 (|jordanAlgebra?|
  (((|Boolean|))
   "\\spad{jordanAlgebra?()} tests if the algebra is commutative,{} characteristic is not 2,{} and \\spad{(a*b)*a^2 - a*(b*a^2) = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra (Jordan identity). Example: for every associative algebra \\spad{(A,{} +,{} @)} we can construct a Jordan algebra \\spad{(A,{} +,{} *)},{} where \\spad{a*b := (a@b+b@a)/2}."))
 (|noncommutativeJordanAlgebra?|
  (((|Boolean|))
   "\\spad{noncommutativeJordanAlgebra?()} tests if the algebra is flexible and Jordan admissible."))
 (|jordanAdmissible?|
  (((|Boolean|))
   "\\spad{jordanAdmissible?()} tests if 2 is invertible in the coefficient domain and the multiplication defined by \\spad{(1/2)(a*b+b*a)} determines a Jordan algebra,{} \\spadignore{i.e.} satisfies the Jordan identity. The property of \\spadatt{CommutativeStar} follows from by definition."))
 (|lieAdmissible?|
  (((|Boolean|))
   "\\spad{lieAdmissible?()} tests if the algebra defined by the commutators is a Lie algebra,{} \\spadignore{i.e.} satisfies the Jacobi identity. The property of anticommutativity follows from definition."))
 (|jacobiIdentity?|
  (((|Boolean|))
   "\\spad{jacobiIdentity?()} tests if \\spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra. For example,{} this holds for crossed products of 3-dimensional vectors."))
 (|powerAssociative?|
  (((|Boolean|))
   "\\spad{powerAssociative?()} tests if all subalgebras generated by a single element are associative."))
 (|alternative?|
  (((|Boolean|))
   "\\spad{alternative?()} tests if \\spad{2*associator(a,{} a,{} b) = 0 = 2*associator(a,{} b,{} b)} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|flexible?|
  (((|Boolean|))
   "\\spad{flexible?()} tests if \\spad{2*associator(a,{} b,{} a) = 0} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|rightAlternative?|
  (((|Boolean|))
   "\\spad{rightAlternative?()} tests if \\spad{2*associator(a,{} b,{} b) = 0} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|leftAlternative?|
  (((|Boolean|))
   "\\spad{leftAlternative?()} tests if \\spad{2*associator(a,{} a,{} b) = 0} for all \\spad{a},{} \\spad{b} in the algebra. Note: we only can test this; in general we don\\spad{'t} know whether \\spad{2*a=0} implies \\spad{a=0}."))
 (|antiAssociative?|
  (((|Boolean|))
   "\\spad{antiAssociative?()} tests if multiplication in algebra is anti-associative,{} \\spadignore{i.e.} \\spad{(a*b)*c + a*(b*c) = 0} for all \\spad{a},{} \\spad{b},{} \\spad{c} in the algebra."))
 (|associative?|
  (((|Boolean|))
   "\\spad{associative?()} tests if multiplication in algebra is associative."))
 (|antiCommutative?|
  (((|Boolean|))
   "\\spad{antiCommutative?()} tests if \\spad{a*a = 0} for all \\spad{a} in the algebra. Note: this implies \\spad{a*b + b*a = 0} for all \\spad{a} and \\spad{b}."))
 (|commutative?|
  (((|Boolean|))
   "\\spad{commutative?()} tests if multiplication in the algebra is commutative."))
 (|rightCharacteristicPolynomial|
  (((|SparseUnivariatePolynomial| |#1|) $)
   "\\spad{rightCharacteristicPolynomial(a)} returns the characteristic polynomial of the right regular representation of \\spad{a} with respect to any basis."))
 (|leftCharacteristicPolynomial|
  (((|SparseUnivariatePolynomial| |#1|) $)
   "\\spad{leftCharacteristicPolynomial(a)} returns the characteristic polynomial of the left regular representation of \\spad{a} with respect to any basis."))
 (|rightTraceMatrix|
  (((|Matrix| |#1|) (|Vector| $))
   "\\spad{rightTraceMatrix([v1,{} ...,{} vn])} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the right trace of the product \\spad{vi*vj}."))
 (|leftTraceMatrix|
  (((|Matrix| |#1|) (|Vector| $))
   "\\spad{leftTraceMatrix([v1,{} ...,{} vn])} is the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the left trace of the product \\spad{vi*vj}."))
 (|rightDiscriminant|
  ((|#1| (|Vector| $))
   "\\spad{rightDiscriminant([v1,{} ...,{} vn])} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the right trace of the product \\spad{vi*vj}. Note: the same as \\spad{determinant(rightTraceMatrix([v1,{} ...,{} vn]))}."))
 (|leftDiscriminant|
  ((|#1| (|Vector| $))
   "\\spad{leftDiscriminant([v1,{} ...,{} vn])} returns the determinant of the \\spad{n}-by-\\spad{n} matrix whose element at the \\spad{i}\\spad{-}th row and \\spad{j}\\spad{-}th column is given by the left trace of the product \\spad{vi*vj}. Note: the same as \\spad{determinant(leftTraceMatrix([v1,{} ...,{} vn]))}."))
 (|represents|
  (($ (|Vector| |#1|) (|Vector| $))
   "\\spad{represents([a1,{} ...,{} am],{} [v1,{} ...,{} vm])} returns the linear combination \\spad{a1*vm + ... + an*vm}."))
 (|coordinates|
  (((|Matrix| |#1|) (|Vector| $) (|Vector| $))
   "\\spad{coordinates([a1,{} ...,{} am],{} [v1,{} ...,{} vn])} returns a matrix whose \\spad{i}-th row is formed by the coordinates of \\spad{\\spad{ai}} with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}.")
  (((|Vector| |#1|) $ (|Vector| $))
   "\\spad{coordinates(a,{} [v1,{} ...,{} vn])} returns the coordinates of \\spad{a} with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}."))
 (|rightNorm|
  ((|#1| $)
   "\\spad{rightNorm(a)} returns the determinant of the right regular representation of \\spad{a}."))
 (|leftNorm|
  ((|#1| $)
   "\\spad{leftNorm(a)} returns the determinant of the left regular representation of \\spad{a}."))
 (|rightTrace|
  ((|#1| $)
   "\\spad{rightTrace(a)} returns the trace of the right regular representation of \\spad{a}."))
 (|leftTrace|
  ((|#1| $)
   "\\spad{leftTrace(a)} returns the trace of the left regular representation of \\spad{a}."))
 (|rightRegularRepresentation|
  (((|Matrix| |#1|) $ (|Vector| $))
   "\\spad{rightRegularRepresentation(a,{} [v1,{} ...,{} vn])} returns the matrix \\spad{m} of the linear map defined by right multiplication by \\spad{a} with respect to the \\spad{R}-module basis \\spad{b = [v1,{} ...,{} vn]}. That is for all \\spad{x} \\spad{coordinates(x*a,{} b) = m*coordinates(x,{} b)}."))
 (|leftRegularRepresentation|
  (((|Matrix| |#1|) $ (|Vector| $))
   "\\spad{leftRegularRepresentation(a,{} [v1,{} ...,{} vn])} returns the matrix \\spad{m} of the linear map defined by left multiplication by \\spad{a} with respect to the \\spad{R}-module basis \\spad{b = [v1,{} ...,{} vn]}. That is for all \\spad{x} \\spad{coordinates(a*x,{} b) = m*coordinates(x,{} b)}."))
 (|structuralConstants|
  (((|Vector| (|Matrix| |#1|)) (|Vector| $))
   "\\spad{structuralConstants([v1,{} v2,{} ...,{} vm])} calculates the structural constants \\spad{[(gammaijk) for k in 1..m]} defined by \\spad{\\spad{vi} * vj = gammaij1 * v1 + ... + gammaijm * vm},{} where \\spad{[v1,{} ...,{} vm]} is an \\spad{R}-module basis of a subalgebra."))
 (|conditionsForIdempotents|
  (((|List| (|Polynomial| |#1|)) (|Vector| $))
   "\\spad{conditionsForIdempotents([v1,{} ...,{} vn])} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the \\spad{R}-module basis \\spad{v1},{} ...,{} \\spad{vn}."))
 (|rank|
  (((|PositiveInteger|))
   "\\spad{rank()} returns the rank of the algebra as \\spad{R}-module."))
 (|someBasis|
  (((|Vector| $)) "\\spad{someBasis()} returns some \\spad{R}-module basis."))
 (|unitsKnown|
  ((|attribute|)
   "unitsKnown means that \\spadfun{recip} truly yields reciprocal or \\spad{\"failed\"} if not a unit,{} similarly for \\spadfun{leftRecip} and \\spadfun{rightRecip}. The reason is that we use left,{} respectively right,{} minimal polynomials to decide this question.")))
(("documentation" 0 15940) ("ancestors" 0 15474) ("parents" 0 15387)
 ("abbreviation" 0 15379) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 11957) ("modemaps" 0 3526) ("sourceFile" 0 3487)
 ("constructorCategory" 0 186) ("constructorModemap" 0 69)
 ("constructorKind" 0 58) ("constructorForm" 0 20))