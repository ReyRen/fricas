)abbrev package RDEPAR ParametricRischDE
ParametricRischDE(R, F) : Exports == Implementation where
  R : Join(GcdDomain, Comparable, CharacteristicZero,
           RetractableTo Integer, LinearlyExplicitOver Integer)
  F :  Join(TranscendentalFunctionCategory, AlgebraicallyClosedField,
           FunctionSpace R)
  N   ==> NonNegativeInteger
  Z   ==> Integer
  Q   ==> Fraction(Integer)
  SE  ==> Symbol
  LF  ==> List F
  K   ==> Kernel F
  LK  ==> List K
  Param_Rec_F ==> Record(ratpart : F, coeffs : Vector F)
  L_Param_F ==> List Param_Rec_F
  Partial_F ==>  Union(Param_Rec_F, "failed")
  Both_F ==> Record(particular : Partial_F, basis : L_Param_F)
  UP ==> SparseUnivariatePolynomial F
  GP  ==> LaurentPolynomial(F, UP)
  Param_Rec_UP ==> Record(ratpart : UP, coeffs : Vector F)
  L_Param_UP ==> List Param_Rec_UP
  Param_Rec_QF ==> Record(logands : List F, basis : List Vector Q)


  Exports ==> with

    param_rde : (Z, F, LF, SE, LK, (LK, LF) -> L_Param_F,
                (LK, LF) -> Param_Rec_QF) -> L_Param_F
      ++ param_rde(n, f, lg, x, lk, ext, logi) finds basis of
      ++ solution to the equation
      ++ dy/dx + n df/dx y + c1 g1 + ... cn gn = 0  where
      ++ y is in field generated by lk and ci are
      ++ constants.
    param_rde : (Z, F, F, LF, SE, LK, (LK, LF) -> L_Param_F,
                (LK, LF) -> Param_Rec_QF) -> Both_F
      ++ param_rde(n, f, h, lg, x, lk, ext, logi) finds a particular
      ++ solution and basis of solutions to homogeneous
      ++ equation for  equation
      ++ dy/dx + n df/dx y + c1 g1 + ... cn gn = h where
      ++ y is in field generated by lk and ci are
      ++ constants.
    param_rde2 : (F, LF, SE, LK, (LK, LF) -> L_Param_F,
                    (LK, LF) -> Param_Rec_QF) -> L_Param_F
      ++ param_rde2(fp, lg, x, lk, ext, logi) finds basis of
      ++ solution to the equation
      ++ dy/dx + fp y + c1 g1 + ... cn gn = 0  where
      ++ y is in field generated by lk and ci are
      ++ constants.
    exp_lower_bound : (UP, GP, Z, Z, LK, F, (LK, LF) -> Param_Rec_QF) -> Z
      ++ exp_lower_bound(a, b, ob, nc0, lk, eta, logi) computes
      ++ lower degree bound for solution of \spad{a*D(y) + b*y = c}
      ++ in exponential case.  ob is order of b, nc0 is lower
      ++ bound on order of c, eta is derivative of the argument
      ++ of exponential.

  Implementation ==> add

    MET ==> MonomialExtensionTools(F, UP)
    RF ==> Fraction UP
    Param_Rec_Q ==> Record(ratpart : RF, coeffs : Vector F)
    L_Param_Q ==> List Param_Rec_Q
    RSOL ==> Record(ans : UP, remainder : UP)
    DSOL ==> Record(ans : List(UP), acoeff : UP, eegen : UP, bpar : UP,
                  lcpar : List UP, dpar : Z)
    P ==> SparseMultivariatePolynomial(R, K)

    import from Integer
    import from List(Integer)
    import from IntegrationTools(R, F)
    import from PolynomialCategoryQuotientFunctions(IndexedExponents K,
                                                             K, R, P, F)
    import from LinearCombinationUtilities(F, UP)

    ALGOP ==> '%alg
    PRIM ==> 'prim
    OPDIFF ==> '%diff

    do_spde1 : (UP, List(UP), Z, UP -> UP, Matrix(F) -> Matrix(F))
                 -> L_Param_UP

    do_param_rde : (F, Boolean, LF, SE, K, LK, (LK, LF) -> L_Param_F,
                    (LK, LF) -> Param_Rec_QF) -> L_Param_F

    do_alg_rde : (F, List F, SE, K, LK, (LK, LF) -> L_Param_F,
                  (LK, LF) -> Param_Rec_QF) -> L_Param_F

    do_diff_rde : (F, List F, SE, K, LK, (LK, LF) -> L_Param_F,
                  (LK, LF) -> Param_Rec_QF) -> L_Param_F

    get_denom(f : RF, lg : List RF, der : UP -> UP) : List(UP) ==
        d := normalDenom(f, der)$MET
        e0 := lcm [denom(g) for g in lg]$List(UP)
        (e, s) := split(e0, der)$MET
        gg := gcd(d, e)
        h := (gcd(e, differentiate e) exquo gcd(gg, differentiate gg))::UP
        [d, h]

    Frec ==> Record(fctr : UP, xpnt : Z)

    normalize(f : RF, der : UP -> UP) : List(Frec) ==
        d := normalDenom(f, der)$MET
        g := gcd(d, differentiate(d))
        d0 := (d exquo g)::UP
        dd := gcd(d0, g)
        d1 := (d0 exquo dd)::UP
        d2 := (denom(f) exquo d1)::UP
        eeu := extendedEuclidean(d2, d1, numer(f))
        (a, b) := eeu::Record(coef1 : UP, coef2 : UP)
        zk := kernel(new()$Symbol)$K
        dd1 := der(d1)
        r := resultant(a - zk::F*dd1, d1)
        rql := get_rational_roots(r, zk
                 )$FunctionSpaceRationalRoots(R, F)
        rl : List Frec := []
        for rq in rql repeat
            if (mu := retractIfCan(rq)@Union(Z, "failed")) case Z then
                m := mu::Z
                if m > 0 then
                    pi := gcd(a - m::F*dd1, d1)
                    rl := cons([pi, m], rl)
        rl

    RF_to_GP(f : RF) : GP == (numer(f)::GP exquo denom(f)::GP)::GP

    do_spde1(b : UP, lc : List(UP), der : UP -> UP,
             get_rs : Matrix(F) -> Matrix(F)) : L_Param_UP ==
        lar := [SPDE1(b, c, der)$RDEaux(F) for c in lc]
        la := [ar.ans for ar in lar]
        lrem := [ar.remainder for ar in lar]
        rs1 : Matrix(F) := reducedSystem(matrix([lrem]))
        rs2 := get_rs(rs1)
        lkv := nullSpace(rs2)
        [[lin_comb(kv, la), kv] for kv in lkv]

    param_SPDE(a : UP, b : UP, lc : List(UP), d : Z, der : UP -> UP,
               get_rs : Matrix(F) -> Matrix(F),
               do_degrad : (RF, List(RF)) -> L_Param_Q,
               x : SE) : L_Param_UP ==
        dt := der monomial(1, 1)
        degree(a) = 0 =>
            a ~= 1 => error "param_SPDE: degree(a) = 0 but a ~= 1"
            degt := degree(dt) - 1
            base_case := dt = 1
            (b ~= 0) and (base_case or degree(b) > max(0, degt)) =>
                do_spde1(b, lc, der, get_rs)
            lcr := [c::RF for c in lc]
            res1 := do_degrad(b::RF, lcr)
            [[retract(re.ratpart)@UP, re.coeffs] for re in res1]
        n1 := #lc
        s1 := multi_SPDE(a, b, lc, d, der)$RDEaux(F)
        s1 case List(RSOL) =>
            lrs := s1::List(RSOL)
            m1 := matrix([[rsol.remainder for rsol in lrs]])$Matrix(UP)
            rs1 : Matrix(F) := reducedSystem(m1)
            rs2 := get_rs(rs1)
            lkv := nullSpace(rs2)
            a1l := [rsol.ans for rsol in lrs]
            [[lin_comb(kv, a1l), kv] for kv in lkv]
        dres := s1::DSOL
        g := dres.eegen
        a := (a exquo g)::UP
        b := (dres.bpar exquo g)::UP
        aa := dres.acoeff
        oans := dres.ans
        lq := [divide(c, g) for c in dres.lcpar]
        lr := [q.remainder for q in lq]
        rs1 : Matrix(F) := reducedSystem(matrix([lr])$Matrix(UP))
        rs2 := get_rs(rs1)
        lkv := nullSpace(rs2)
        empty?(lkv) => []
        lc := [q.quotient for q in lq]
        nlc : List(UP) := []
        for kv in lkv repeat
            nlc := cons(lin_comb(kv, lc), nlc)
        nlc := reverse!(nlc)
        n2 := #lkv
        s2 := param_SPDE(a, b, nlc, dres.dpar, der, get_rs, do_degrad, x)
        nres : L_Param_UP := []
        for be in s2 repeat
            bv := lin_comb(be.coeffs, lkv)
            ans1 := lin_comb(bv, oans) + aa*be.ratpart
            nres := cons([ans1, bv], nres)
        reverse!(nres)

    integer_vector(v : Vector(Q)) : Union(Vector(Integer), "failed") ==
        (nv, d) := splitDenominator(v)$CommonDenominator(Integer, Q, Vector(Q))
        d ~= 1 => "failed"
        nv(1) ~= 1 => "failed"
        vector([retract(nv(i))@Integer for i in 1..#nv])

    do_SPDE_prim0(b : F, lc : List(UP), lk : LK,
                 ext : (LK, LF) -> L_Param_F,
                 logi : (LK, LF) -> Param_Rec_QF, der : UP -> UP,
                 get_rs : Matrix(F) -> Matrix(F), x : SE
                ) :  L_Param_Q ==
        n := #lc
        vg2 := vector([lc])$Vector(UP)
        cb := [new(n, 0)$Vector(F) for i in 1..n]
        for i in 1..n for bv in cb repeat
            bv(i) := 1
        d := reduce(max, [degree(c) for c in lc], 0)
        dk := retract(der(monomial(1, 1)$UP))@F
        lba : List(RF) := [0 for bv in cb]
        cba := [0$F for bv in cb]
        for j in d..0 by -1 repeat
            n1 := #cb
            lgj : List(F) := []
            for i in 1..n repeat
                gi := vg2(i)
                gij : F := 0
                if degree(gi) = j then
                    gij := leadingCoefficient(gi)
                    vg2(i) := reductum(gi)
                lgj := cons(-gij, lgj)
            lgj := reverse!(lgj)
            lgj1 : List(F) := []
            for bv in cb for aa in cba repeat
                ff := lin_comb(bv, lgj) + (j + 1)::F*dk*aa
                lgj1 := cons(ff, lgj1)
            lgj1 := reverse!(lgj1)
            s2f := param_rde2(b, lgj1, x, lk, ext, logi)
            ncb := [lin_comb(be.coeffs, cb) for be in s2f]
            cba := [be.ratpart for be in s2f]
            nlba := [lin_comb(be.coeffs, lba) +
                   monomial(be.ratpart, j::N)$UP::RF for be in s2f]
            cb := ncb
            lba := nlba
        [[ba, bv] for ba in lba for bv in cb]

    do_ext(ext : (LK, LF) -> L_Param_F, lcr : List RF, k : K,
           lk : LK) : L_Param_Q ==
        lc := [multivariate(cr, k) for cr in lcr]
        res1 := ext(lk, lc)
        [[univariate(be.ratpart, k), be.coeffs] for be in res1]


    do_SPDE_prim(a : UP, bbr : RF, is_der : Boolean,
                lcr : List RF, k: K, lk : LK,
                ext : (LK, LF) -> L_Param_F,
                logi : (LK, LF) -> Param_Rec_QF, der : UP -> UP,
                get_rs : Matrix(F) -> Matrix(F), x : SE
               ) : L_Param_Q ==
        fp := retract(der(monomial(1, 1)))@F
        base_case : Boolean := fp = 1
        b := retract(bbr)@UP
        lc : List(UP) := [retract(cr)@UP for cr in lcr]
        da := degree(a)
        db := degree(b)
        dc := reduce(max, [degree(c) for c in lc]$List(Z))
        not(base_case) and da = 0 and db = 0 =>
            b1 := retract(b)@F/retract(a)@F
            b1 = 0 => do_ext(ext, lcr, k, lk)
            if not(is_der) then
                (ll, bl) := logi(lk, [b1])
                if not(empty?(bl)) then
                    bv := first(bl)
                    bvu := integer_vector(bv)
                    if bvu case Vector(Integer) then
                             error "need transform and call ext"
            do_SPDE_prim0(b1, lc, lk, ext, logi, der, get_rs, x)
        n :=
            db > da => max(0, dc - db)
            max(0, dc - da + 1)
        if da = db + 1 then
            f0 := -leadingCoefficient(b)/leadingCoefficient(a)
            base_case =>
                if (mu := retractIfCan(f0)@Union(Z, "failed")) case Z then
                    n := max(n, mu::Z)
            r0 := dehomogenize(ext(lk, [-f0, fp])).particular
            if not(r0 case "failed") then
                mf : F := ((r0::Param_Rec_F).coeffs)(1)
                if (mu := retractIfCan(mf)@Union(Z, "failed")) case Z then
                    n := max(n, mu::Z)
        if not base_case and da = db then
            f0 := -leadingCoefficient(b)/leadingCoefficient(a)
            b1 := f0*a + b
            if degree(b1) + 1 = da then
                f1 := -leadingCoefficient(b1)/leadingCoefficient(a)
                r0 := dehomogenize(ext(lk, [-f1, fp])).particular
                if not(r0 case "failed") then
                    mf : F := ((r0::Param_Rec_F).coeffs)(1)
                    if (mu := retractIfCan(mf)@Union(Z, "failed")) case Z then
                        n := max(n, mu::Z)
        do_degrad := (bb : RF, lc1 : List(RF)) : L_Param_Q +->
            do_SPDE_prim(1, bb, is_der, lc1, k, lk, ext, logi, der, get_rs, x)
        res1 := param_SPDE(a, b, lc, n, der, get_rs, do_degrad, x)
        [[re.ratpart::RF, re.coeffs] for re in res1]

    do_SPDE_exp0(a : F, b : F, lcr : List(GP), lk : LK, eta : F,
                 ext : (LK, LF) -> L_Param_F,
                 logi : (LK, LF) -> Param_Rec_QF, x : SE
                ) : L_Param_Q ==
        n := #lcr
        vg2 := vector([lcr])$Vector(GP)
        cb := [new(n, 0)$Vector(F) for cr in lcr]
        for i in 1..n for bv in cb repeat
            bv(i) := 1
        lba : List(GP) := [0 for cr in lcr]
        d := reduce(max, [degree(cr) for cr in lcr])
        j := d
        f0 := b/a
        repeat
            last_iter : Boolean := true
            n1 := #cb
            lgj : List(F) := []
            for i in 1..n repeat
                gi := vg2(i)
                gij : F := 0
                if gi ~= 0 then
                    last_iter := false
                    if degree(gi) = j then
                        gij := leadingCoefficient(gi)
                        vg2(i) := reductum(gi)
                lgj := cons(gij, lgj)
            last_iter => break
            lgj := reverse!(lgj)
            lgj1 : List(F) := []
            for bv in cb repeat
                ff := lin_comb(bv, lgj)
                lgj1 := cons(-ff, lgj1)
            lgj1 := reverse!(lgj1)
            s2f := param_rde2(f0 + j::F*eta, lgj1, x, lk, ext, logi)
            ncb := [lin_comb(be.coeffs, cb) for be in s2f]
            nlba := [lin_comb(be.coeffs, lba) +
                   monomial(be.ratpart, j)$GP for be in s2f]
            cb := ncb
            lba := nlba
            j := j - 1
        [[convert(re)@RF, bv] for re in lba for bv in cb]

    exp_lower_bound(a : UP, b : GP, ob : Z, nc0 : Z, lk : LK,
                   eta : F, logi : (LK, LF) -> Param_Rec_QF) : Z ==
        ob < 0 => min(0, nc0 - ob)
        n0 := min(0, nc0)
        0 < ob => n0
        c0 := coefficient(b, 0)/coefficient(a, 0)
        (ll, bl) := logi(lk, [c0, eta])
        empty?(bl) => n0
        bv := first(bl)
        nu := retractIfCan(bv(2)/bv(1))@Union(Integer, "failed")
        nu case "failed" => n0
        min(nu::Integer, n0)

    exp_upper_bound(a : UP, b : UP, nc1 : Z, lk : LK, eta : F,
                   logi : (LK, LF) -> Param_Rec_QF) : Z ==
        da := degree(a)
        db := degree(b)
        da < db => nc1 - db
        n0 := max(0, nc1 - da)
        db < da => n0
        c1 := leadingCoefficient(b)/leadingCoefficient(a)
        (ll, bl) := logi(lk, [c1, eta])
        empty?(bl) => n0
        bv := first(bl)
        nu := retractIfCan(bv(2)/bv(1))@Union(Integer, "failed")
        nu case "failed" => n0
        max(nu::Integer, n0)

    do_SPDE_exp(a : UP, bbr : RF, lcr : List RF, lk : LK,
                ext : (LK, LF) -> L_Param_F,
                logi : (LK, LF) -> Param_Rec_QF, der : UP -> UP,
                get_rs : Matrix(F) -> Matrix(F), x : SE) : L_Param_Q ==
        b := RF_to_GP(bbr)
        lc := [RF_to_GP(cr) for cr in lcr]
        nb0 := order(b)
        nc0 := reduce(min, [order(c) for c in lc])
        eta := retract((der(monomial(1, 1)) exquo monomial(1, 1))::UP)@F
        degree(a) = 0 and degree(b) = 0 and nb0 = 0 =>
            do_SPDE_exp0(retract(a), retract(b), lc, lk, eta, ext, logi, x)
        n0 := exp_lower_bound(a, b, nb0, nc0, lk, eta, logi)
        if n0 < 0 then
            b := b + (n0::F*eta)::GP*a::GP
        if nb0 < 0 then
            t1 := monomial(1, (-nb0)::N)$UP
            b := t1::GP*b
            a := t1*a
        bu := retract(b)@UP
        m0 := min(0, n0) + min(0, nb0)
        if m0 < 0 then
            t1 := monomial(1, (-m0)::N)$GP
            lc := [t1::GP*c for c in lc]
        lcu := [retract(c)@UP for c in lc]
        nc1 := reduce(max, [degree(cu) for cu in lcu])
        n1 := exp_upper_bound(a, bu, nc1, lk, eta, logi)
        do_degrad := (bb : RF, lc1 : List(RF)) : L_Param_Q +->
            do_SPDE_exp0(1, retract(numer(bb)), [RF_to_GP(c1) for c1 in lc1],
                         lk, eta, ext, logi, x)
        res1 := param_SPDE(a, bu, lcu, n1, der, get_rs, do_degrad, x)
        tt : RF :=
            n0 < 0 => (monomial(1, (-n0)::N)$UP)::RF
            1
        [[re.ratpart::RF/tt, re.coeffs] for re in res1]

    param_rde(m, f, g0, lg, x, lk, ext, logi) ==
        lg1 := cons(-g0, lg)
        res1 := param_rde(m, f, lg1, x, lk, ext, logi)
        dehomogenize(res1)

    param_rde2(fp, lg, x, lk, ext, logi) ==
        k := kmax(lk)
        lk := [k1 for k1 in lk | k1 ~= k]
        has?(operator k, ALGOP)$BasicOperator =>
            do_alg_rde(fp, lg, x, k, lk, ext, logi)
        is?(k, OPDIFF) =>
            do_diff_rde(fp, lg, x, k, lk, ext, logi)
        dku := univariate(differentiate(k::F, x), k)
        denom(dku) ~= 1 =>
            []
        dk := numer(dku)
        fpu := univariate(fp, k)
        denfp := denom(fpu)
        der1 : UP -> UP := z1 +-> differentiate(z1,
               (z2 : F) : F +-> differentiate(z2, x), dk)
        rl := normalize(fpu, der1)
        p : UP := 1
        for re in rl repeat
            (pii, ni) := re
            fpu := fpu - ni::F*der1(pii)/pii
            p := pii^(ni::NonNegativeInteger)*p
        fp := multivariate(fpu, k)
        pf := multivariate(p::RF, k)
        lg1 := [pf*g for g in lg]
        res1 := do_param_rde(fp, false, lg1, x, k, lk, ext, logi)
        [[rs.ratpart/pf, rs.coeffs] for rs in res1]

    csolve1(m : Matrix F, d1 : F -> F) : List Vector(F) ==
        nullSpaceOverConstants(m, [d1])$ConstantLinearDependence(R, F)

    do_diff_rde1(lg : List UP, fp0 : F, fp1 : F, x : SE, k : K, lk : LK,
                ext : (LK, LF) -> L_Param_F,
                logi : (LK, LF) -> Param_Rec_QF) : L_Param_F ==
        args := argument(k)
        #args ~= 3 => error "internal error, k is not a diff"
        arg3 := args(3)
        (da3 := differentiate(arg3, x)) = 0 => []
        lg0 := [coefficient(up, 0) for up in lg]
        lg1 := [coefficient(up, 1) for up in lg]
        k1 := eval(args(1), retract(args(2))@K, arg3)
        dv := new()$Symbol
        dvf := dv::F
        lg2 := [eval(g/da3, k1, dvf) for g in lg1]
        fp2 := eval(fp1/da3, k1, dvf)
        lek := [eval(ki::F, k1, dvf) for ki in lk]
        lk1 := varselect(tower(cons(dvf, append(lg2, lek))), dv)
        ext1 := (x4 : List K, x3 : List F) : L_Param_F +->
                 extendedint(dv, x4, x3
                            )$ParametricIntegration(R, F)
        logi1 := (x2 : List K, x3 : List F) : Param_Rec_QF +->
                  logextint(dv, x2, x3
                           )$ParametricIntegration(R, F)
        kk1 := kmax(lk1)
        lk2 := [ki for ki in lk1 | ki ~= kk1]
        res1 : L_Param_F :=
            fp2 = 0 => ext1(lk1, lg2)
            do_param_rde(fp2, true, lg2, dv, kk1, lk2,  ext1, logi1)
        empty?(res1) => []
        cb0 := [be.coeffs for be in res1]
        d1 := (x1 : F) : F +-> differentiate(x1, x)
        (m2, cb) := constant_subspace(cb0, [d1]
                                      )$ConstantLinearDependence(R, F)
        empty?(cb) => []
        v2 := vector([be.ratpart for be in res1])$Vector(F)
        v3 := m2*v2
        lca := entries(v3)
        lg3 := [lin_comb(bv, lg1) for bv in cb]
        nlg0 := [lin_comb(bv, lg0) for bv in cb]
        lca := map((x1 : F) : F+->eval(x1, kernel(dv), k1::F), lca)
        nlg : List(F) := []
        for ca in lca for g1 in lg3 for g0 in nlg0 repeat
            du := univariate(differentiate(ca, x), k)
            nu := numer(du)
            denom(du) ~= 1 or degree(nu) > 1 => return []
            g1 + fp1*ca + coefficient(nu, 1) ~= 0 => return []
            ng := g0 + fp0*ca + coefficient(nu, 0)
            nlg := cons(ng, nlg)
        nlg := reverse!(nlg)
        cb1 : List(Vector(F))
        elca : List(F)
        if fp1 ~= 0 then
            m3 := matrix([nlg])$Matrix(F)
            cb1 := csolve1(m3, d1)
            elca := [0 for bv in cb1]
        else
            kk3 := kmax(lk)
            lk3 := [ki for ki in lk | ki ~= kk3]
            res2 := do_param_rde(fp0, true, nlg, x, kk3, lk1, ext, logi)
            cb1 := [be.coeffs for be in res2]
            elca := [be.ratpart for be in res2]
        ncb := [lin_comb(bv, cb) for bv in cb1]
        nlca := [ca + lin_comb(bv, lca) for bv in cb1 for ca in elca]
        [[ba, bv] for ba in nlca for bv in ncb]

    do_diff_rde(fp : F, lg : List F, x : SE, k : K, lk : LK,
                ext : (LK, LF) -> L_Param_F,
                logi : (LK, LF) -> Param_Rec_QF) : L_Param_F ==
        -- FIXME check that fp contains no extra kernels
        fpu := univariate(fp, k)
        denom(fpu) ~= 1 or degree(nfpu := numer(fpu)) > 1 => []
        fp1 := coefficient(nfpu, 1)
        fp0 := coefficient(nfpu, 0)
        d1 := (x1 : F) : F +-> differentiate(x1, x)
        cs1 := (x4 : Matrix F) : List Vector F +->
                      csolve1(x4, d1)
        diff_rde1 := (x1 : List UP) : L_Param_F +->
                 do_diff_rde1(x1, fp0, fp1, x, k, lk, ext, logi)
        diffextint(diff_rde1, cs1, [univariate(u, k) for u in lg]
                  )$ParametricTranscendentalIntegration(F, UP)

    do_alg_rde0(fp : F, lg : List F, x : SE, k : K, lk : LK,
                ext : (LK, LF) -> L_Param_F,
                logi : (LK, LF) -> Param_Rec_QF) : L_Param_F ==
        ak := argument(k)
        ak2 := ak(2)
        n := retract(ak2)@Integer
        ak1 := ak(1)
        dlk := D(ak1, x)/(ak2*ak1)
        kf := k::F
        kfi : F := 1
        llv := vector([alg_split_root0(g, k, n)$RootFSSplit(R, F)
                        for g in lg])$Vector(List(F))
        m := #lg
        cb := [new(m, 0)$Vector(F) for i in 1..m]
        for i in 1..m for bv in cb repeat
            bv(i) := 1
        lba : List(F) := [0 for bv in cb]
        nlba : List(F)
        for i in 0..(n-1) repeat
            lgi : List F := []
            for j in 1..m repeat
                lgi := cons(first(llv(j)), lgi)
                llv(j) := rest(llv(j))
            lgi := reverse!(lgi)
            lgi1 := [lin_comb(bv, lgi) for bv in cb]
            s1 := param_rde2(fp + i::F*dlk, lgi1, x, lk, ext, logi)
            ncb := [lin_comb(be.coeffs, cb) for be in s1]
            nlba := [lin_comb(be.coeffs, lba) + be.ratpart*kfi for be in s1]
            cb := ncb
            lba := nlba
            kfi := kf*kfi
        [[ba, bv] for ba in lba for bv in cb]

    do_alg_rde(fp : F, lg : List F, x : SE, k : K, lk : LK,
               ext : (LK, LF) -> L_Param_F,
               logi : (LK, LF) -> Param_Rec_QF) : L_Param_F ==
        is?(k, 'nthRoot) and not(member?(k, kernels(fp))) =>
            do_alg_rde0(fp, lg, x, k, lk, ext, logi)
        k1 := kmax(lk)
        symbolIfCan(k1) case SE =>
            res1 := param_RDE(fp, lg, k1, k)$PureAlgebraicIntegration(R, F, F)
            n := #lg
            part1 : L_Param_F := [[-be.ratpart, be.coeffs]
                                    for be in res1.particular]
            part2 : L_Param_F := [[f, new(n, 0)$Vector(F)] for f in res1.basis]
            concat(part1, part2)
        has?(operator k1, ALGOP) =>
            rec := primitiveElement(k1::F, k::F
                    )$FunctionSpacePrimitiveElement(R, F)
            y   := rootOf(rec.prim)
            ky := retract(y)@K
            fp1 := eval(fp, [k1, k], [(rec.pol1) y, (rec.pol2) y])
            lg1 := [eval(g, [k1, k], [(rec.pol1) y, (rec.pol2) y]) for g in lg]
            res1 := do_alg_rde(fp1, lg1, x, ky, [kk for kk in lk | kk ~= k1],
                               ext, logi)
            [[eval(be.ratpart, ky, rec.primelt), be.coeffs] for be in res1]
        error "do_alg_rde: unimplemented kernel"

    param_rde(m, f, lg, x, lk, ext, logi) ==
        (fp := D(m*f, x)) = 0 => ext(lk, lg)
        k := kmax(lk)
        lk := [k1 for k1 in lk | k1 ~= k]
        do_param_rde(fp, true, lg, x, k, lk, ext, logi)

    -- assumes fp is weakly normalized
    do_param_rde(fp, is_der, lg, x, k, lk, ext, logi) ==
        has?(operator k, ALGOP)$BasicOperator =>
            do_alg_rde(fp, lg, x, k, lk, ext, logi)
        is?(k, OPDIFF) =>
            do_diff_rde(fp, lg, x, k, lk, ext, logi)
        -- below we assume that main kernel k
        -- is a monomial
        dku := univariate(differentiate(k::F, x), k)
        denom(dku) ~= 1 => []
        dk := numer(dku)
        fpu := univariate(fp, k)
        denfp := denom(fpu)
        nfp := numer(fpu)
        lgu := [univariate(g, k) for g in lg]
        der1 : UP -> UP := z1 +-> differentiate(z1,
               (z2 : F) : F +-> differentiate(z2, x), dk)
        (d, h) := get_denom(fpu, lgu, der1)
        aa := d*h
        bbr := aa*fpu - (d*der1(h))::RF
        aa1 := aa*h
        lgu := [aa1*gu for gu in lgu]
        lgd := [decompose(gu, der1)$MET for gu in lgu]
        lnor1 := [dr.normal for dr in lgd]
        rs1 : Matrix(UP) := reducedSystem(matrix([lnor1])$Matrix(RF))
        rs2 : Matrix(F) := reducedSystem(rs1)
        get_rs := (m : Matrix(F)) : Matrix(F) +->
              reducedSystem(m, [(ff : F) : F +-> differentiate(ff, x)]
                           )$ConstantLinearDependence(R, F)
        rs3 := get_rs(rs2)
        lker := nullSpace(rs3)
        empty?(lker) => []
        lgu := [dr.poly::RF + dr.special for dr in lgd]
        n1 := #lgu
        n2 := #lker
        lgu1 : List(RF) := []
        for kv in lker repeat
            lgu1 := cons(lin_comb(kv, lgu), lgu1)
        lgu1 := reverse!(lgu1)
        res1 :=
            symbolIfCan(k) case SE or is?(k, 'log)
              or has?(operator k, PRIM)$BasicOperator =>
                do_SPDE_prim(aa, bbr, is_der, lgu1, k, lk, ext,
                             logi, der1, get_rs, x)
            is?(k, 'exp) =>
                do_SPDE_exp(aa, bbr, lgu1, lk, ext, logi, der1, get_rs, x)
            return []
        res2 : L_Param_F := []
        for re in res1 repeat
            bv := lin_comb(re.coeffs, lker)
            ans1 : RF := -re.ratpart/h::RF
            anf : F := multivariate(ans1, k)
            res2 := cons([anf, bv], res2)
        reverse!(res2)


