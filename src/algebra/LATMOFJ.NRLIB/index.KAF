8118                (MAKEPROP '|LatticeMeetOfJoins| 'NILADIC T)
(|LatticeMeetOfJoins|)
|domain|
(((|LatticeMeetOfJoins|)
  (|Join| (|BoundedDistributiveLattice|)
          (CATEGORY |domain| (SIGNATURE |logicT| ($)) (SIGNATURE |logicF| ($))
           (SIGNATURE |variable| ($ (|String|)))
           (SIGNATURE |latticeMeetOfJoins|
            ($
             (|Union| (|:| |const| (|Record| (|:| |val| (|Symbol|))))
                      (|:| |var| (|Record| (|:| |str| (|String|)))))))
           (SIGNATURE |emptyLattice| ($)) (SIGNATURE |empty?| ((|Boolean|) $))
           (SIGNATURE |meet| ($ (|List| $))) (SIGNATURE |join| ($ (|List| $)))
           (SIGNATURE |redux| ($ $)) (SIGNATURE |factor| ((|List| $) $))
           (SIGNATURE |deductions| ((|List| $) (|List| $)))
           (SIGNATURE = ((|Boolean|) $ $)) (SIGNATURE |opType| ((|Symbol|) $))
           (SIGNATURE |getChildren| ((|List| $) $))
           (SIGNATURE |atom?| ((|Boolean|) $))
           (SIGNATURE |value| ((|Symbol|) $))
           (SIGNATURE |toString| ((|String|) $))
           (SIGNATURE |toStringUnwrapped| ((|String|) $)))))
 (T |LatticeMeetOfJoins|))
(|Join| (|BoundedDistributiveLattice|)
        (CATEGORY |domain| (SIGNATURE |logicT| ($)) (SIGNATURE |logicF| ($))
         (SIGNATURE |variable| ($ (|String|)))
         (SIGNATURE |latticeMeetOfJoins|
          ($
           (|Union| (|:| |const| (|Record| (|:| |val| (|Symbol|))))
                    (|:| |var| (|Record| (|:| |str| (|String|)))))))
         (SIGNATURE |emptyLattice| ($)) (SIGNATURE |empty?| ((|Boolean|) $))
         (SIGNATURE |meet| ($ (|List| $))) (SIGNATURE |join| ($ (|List| $)))
         (SIGNATURE |redux| ($ $)) (SIGNATURE |factor| ((|List| $) $))
         (SIGNATURE |deductions| ((|List| $) (|List| $)))
         (SIGNATURE = ((|Boolean|) $ $)) (SIGNATURE |opType| ((|Symbol|) $))
         (SIGNATURE |getChildren| ((|List| $) $))
         (SIGNATURE |atom?| ((|Boolean|) $)) (SIGNATURE |value| ((|Symbol|) $))
         (SIGNATURE |toString| ((|String|) $))
         (SIGNATURE |toStringUnwrapped| ((|String|) $))))
"/git/fricas/src/algebra/LATMOFJ.spad"
((= (*1 *2 *1 *1)
    (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|LatticeMeetOfJoins|))))
 (|logicT| (*1 *1) (|isDomain| *1 (|LatticeMeetOfJoins|)))
 (|logicF| (*1 *1) (|isDomain| *1 (|LatticeMeetOfJoins|)))
 (|variable| (*1 *1 *2)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *1 (|LatticeMeetOfJoins|))))
 (|latticeMeetOfJoins| (*1 *1 *2)
  (AND
   (|isDomain| *2
               (|Union| (|:| |const| (|Record| (|:| |val| (|Symbol|))))
                        (|:| |var| (|Record| (|:| |str| (|String|))))))
   (|isDomain| *1 (|LatticeMeetOfJoins|))))
 (|emptyLattice| (*1 *1) (|isDomain| *1 (|LatticeMeetOfJoins|)))
 (|empty?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|LatticeMeetOfJoins|))))
 (|meet| (*1 *1 *2)
  (AND (|isDomain| *2 (|List| (|LatticeMeetOfJoins|)))
       (|isDomain| *1 (|LatticeMeetOfJoins|))))
 (|join| (*1 *1 *2)
  (AND (|isDomain| *2 (|List| (|LatticeMeetOfJoins|)))
       (|isDomain| *1 (|LatticeMeetOfJoins|))))
 (|redux| (*1 *1 *1) (|isDomain| *1 (|LatticeMeetOfJoins|)))
 (|factor| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|LatticeMeetOfJoins|)))
       (|isDomain| *1 (|LatticeMeetOfJoins|))))
 (|deductions| (*1 *2 *2)
  (AND (|isDomain| *2 (|List| (|LatticeMeetOfJoins|)))
       (|isDomain| *1 (|LatticeMeetOfJoins|))))
 (|opType| (*1 *2 *1)
  (AND (|isDomain| *2 (|Symbol|)) (|isDomain| *1 (|LatticeMeetOfJoins|))))
 (|getChildren| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|LatticeMeetOfJoins|)))
       (|isDomain| *1 (|LatticeMeetOfJoins|))))
 (|atom?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|LatticeMeetOfJoins|))))
 (|value| (*1 *2 *1)
  (AND (|isDomain| *2 (|Symbol|)) (|isDomain| *1 (|LatticeMeetOfJoins|))))
 (|toString| (*1 *2 *1)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *1 (|LatticeMeetOfJoins|))))
 (|toStringUnwrapped| (*1 *2 *1)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *1 (|LatticeMeetOfJoins|)))))
((~= (((|Boolean|) $ $) NIL)) (|variable| (($ (|String|)) 10))
 (|value| (((|Symbol|) $) 38)) (|toStringUnwrapped| (((|String|) $) 41))
 (|toString| (((|String|) $) 43)) (|redux| (($ $) 20))
 (|opType| (((|Symbol|) $) 36)) (|meet| (($ (|List| $)) 27)) (|logicT| (($) 7))
 (|logicF| (($) 8))
 (|latticeMeetOfJoins|
  (($
    (|Union| (|:| |const| (|Record| (|:| |val| (|Symbol|))))
             (|:| |var| (|Record| (|:| |str| (|String|))))))
   14))
 (|latex| (((|String|) $) NIL)) (|join| (($ (|List| $)) 28))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) NIL))
 (|hash| (((|SingleInteger|) $) NIL)) (|getChildren| (((|List| $) $) 39))
 (|factor| (((|List| $) $) 33)) (|emptyLattice| (($) 15))
 (|empty?| (((|Boolean|) $) 17)) (|deductions| (((|List| $) (|List| $)) 34))
 (|coerce| (((|OutputForm|) $) 49)) (|atom?| (((|Boolean|) $) 37))
 (|_\|_| (($) NIL T CONST)) (|\\/| (($ $ $) 25)) (T$ (($) NIL T CONST))
 (= (((|Boolean|) $ $) 40)) (|/\\| (($ $ $) 21)))
LATMOFJ
(((|BoundedDistributiveLattice|) . T))
(((|BasicType|) . T) ((|BoundedDistributiveLattice|) . T)
 ((|BoundedJoinSemilattice|) . T) ((|BoundedLattice|) . T)
 ((|BoundedMeetSemilattice|) . T) ((|CoercibleTo| (|OutputForm|)) . T)
 ((|DistributiveLattice|) . T) ((|JoinSemilattice|) . T) ((|Lattice|) . T)
 ((|MeetSemilattice|) . T) ((|SetCategory|) . T))
((|constructor| (NIL "parse result includes term returned and new index"))
 (|toStringUnwrapped|
  (((|String|) $)
   "similar to 'toString' but does not put outer compound terms in brackets"))
 (|toString|
  (((|String|) $)
   "creates a string representation of this term and its sub-terms"))
 (|value|
  (((|Symbol|) $)
   "returns: \\indented{2}{\"T\"::Symbol = \\spad{T}} \\indented{2}{\"F\"::Symbol = \\spad{_|_}} \\indented{2}{\"E\"::Symbol = error} \\indented{2}{\"P\"::Symbol = proposition} \\indented{2}{\"C\"::Symbol = compound} Constructs lambda term and bind any variables with the name provided"))
 (|atom?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is an atom,{} that is a leaf node otherwise return \\spad{false} if this is a compound term"))
 (|getChildren|
  (((|List| $) $)
   "returns child nodes if this is a compound term otherwise returns []"))
 (|opType|
  (((|Symbol|) $)
   "if this is a compound op then opType returns the type of that op: \"IMPLY\"::Symbol =implies \"AND\"::Symbol=/\\ \"OR\"::Symbol=\\spad{\\/} \"NOT\"::Symbol=~ \"OTHER\"::Symbol=not compound op"))
 (=
  (((|Boolean|) $ $)
   "returns \\spad{true} (boolean \\spad{true}) if intuitionisticLogic values are the same. Translates from Intuitionistic Logic to Boolean Logic"))
 (|deductions|
  (((|List| $) (|List| $))
   "assumes \\spad{ln} contains a list of factors which must be \\spad{true} for the whole to be \\spad{true} (such as the list produced by factor). From this deductions attempts to produce a list of other proposition that must also be \\spad{true} by using modus ponens. This is used to determine the returned type when converting ILogic to types by using the Curry-Howard isomorphism."))
 (|factor|
  (((|List| $) $)
   "splits \\spad{n} into a list of factors which must be \\spad{true} for the whole to be \\spad{true}. This assumes that the top level is already a set of factors separated by \\spad{/\\} otherwise the result will just be a list with one entry: \\spad{'n'}. This is used when converting ILogic to types by using the Curry-Howard isomorphism."))
 (|redux| (($ $) "attempt to simplify terms"))
 (|join| (($ (|List| $)) "\\spad{join of} set of elements"))
 (|meet| (($ (|List| $)) "\\spad{meet of} set of elements"))
 (|empty?| (((|Boolean|) $) "\\spad{true} if empty"))
 (|emptyLattice| (($) "construct an empty lattice"))
 (|latticeMeetOfJoins|
  (($
    (|Union| (|:| |const| (|Record| (|:| |val| (|Symbol|))))
             (|:| |var| (|Record| (|:| |str| (|String|))))))
   "construct a lattice with one element"))
 (|variable| (($ (|String|)) "construct a variable"))
 (|logicF|
  (($) "construct \\spad{false} (contradiction): a logical constant."))
 (|logicT| (($) "construct true: a logical constant.")))
(("documentation" 0 5365) ("ancestors" 0 5052) ("parents" 0 5013)
 ("abbreviation" 0 5005) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 4041) ("modemaps" 0 2129) ("sourceFile" 0 2090)
 ("constructorCategory" 0 1141) ("constructorModemap" 0 96)
 ("constructorKind" 0 87) ("constructorForm" 0 64) ("NILADIC" 0 20))