3194                (|SegmentExpansionCategory| S L)
|category|
(((|SegmentExpansionCategory| |#1| |#2|) (|Category|) (|OrderedRing|)
  (|StreamAggregate| |t#1|))
 (T |SegmentExpansionCategory|))
(|Join| (|SegmentCategory| |t#1|)
        (CATEGORY |domain| (SIGNATURE |expand| (|t#2| (|List| $)))
         (SIGNATURE |expand| (|t#2| $))
         (SIGNATURE |map| (|t#2| (|Mapping| |t#1| |t#1|) $))))
"/git/fricas/src/algebra/SEGXCAT.spad"
((|expand| (*1 *2 *3)
  (AND (|isDomain| *3 (|List| *1))
       (|ofCategory| *1 (|SegmentExpansionCategory| *4 *2))
       (|ofCategory| *4 (|OrderedRing|))
       (|ofCategory| *2 (|StreamAggregate| *4))))
 (|expand| (*1 *2 *1)
  (AND (|ofCategory| *1 (|SegmentExpansionCategory| *3 *2))
       (|ofCategory| *3 (|OrderedRing|))
       (|ofCategory| *2 (|StreamAggregate| *3))))
 (|map| (*1 *2 *3 *1)
  (AND (|isDomain| *3 (|Mapping| *4 *4))
       (|ofCategory| *1 (|SegmentExpansionCategory| *4 *2))
       (|ofCategory| *4 (|OrderedRing|))
       (|ofCategory| *2 (|StreamAggregate| *4)))))
((~= (((|Boolean|) $ $) 6 (|has| |#1| (|SetCategory|))))
 (|segment| (($ |#1| |#1|) 6))
 (|reverse| (($ $) 6 (|has| |#1| (|OrderedRing|))))
 (|map| ((|#2| (|Mapping| |#1| |#1|) $) 6)) (|low| ((|#1| $) 6))
 (|latex| (((|String|) $) 6 (|has| |#1| (|SetCategory|))))
 (|incr| (((|Integer|) $) 6)) (|high| ((|#1| $) 6))
 (|hashUpdate!|
  (((|HashState|) (|HashState|) $) 6 (|has| |#1| (|SetCategory|))))
 (|hash| (((|SingleInteger|) $) 6 (|has| |#1| (|SetCategory|))))
 (|expand| ((|#2| (|List| $)) 6) ((|#2| $) 6))
 (|convert| (($ |#1|) 6)
            (((|InputForm|) $) 6 (|has| |#1| (|ConvertibleTo| (|InputForm|)))))
 (|coerce| (((|OutputForm|) $) 6 (|has| |#1| (|SetCategory|))))
 (SEGMENT (($ |#1| |#1|) 6)) (BY (($ $ (|Integer|)) 6))
 (= (((|Boolean|) $ $) 6 (|has| |#1| (|SetCategory|))))
 (- (($ $ |#1|) 6 (|has| |#1| (|AbelianGroup|))))
 (+ (($ |#1| $) 6 (|has| |#1| (|AbelianSemiGroup|)))
    (($ $ |#1|) 6 (|has| |#1| (|AbelianSemiGroup|)))))
SEGXCAT
(((|SegmentCategory| |#1|) . T))
(((|BasicType|) |has| |t#1| (|SetCategory|))
 ((|CoercibleTo| (|OutputForm|)) |has| |t#1| (|SetCategory|))
 ((|ConvertibleTo| (|InputForm|)) |has| |t#1| (|ConvertibleTo| (|InputForm|)))
 ((|SegmentCategory| |#1|) . T) ((|SetCategory|) |has| |t#1| (|SetCategory|))
 ((|Type|) . T))
((|constructor|
  (NIL
   "This category provides an interface for expanding segments to a stream of elements."))
 (|map|
  ((|#2| (|Mapping| |#1| |#1|) $)
   "\\spad{map(f,{} l..h by k)} produces a value of type \\spad{L} by applying \\spad{f} to each of the successive elements of the segment,{} that is,{} \\spad{[f(l),{} f(l+k),{} ...,{} f(lN)]},{} where \\spad{lN <= h < lN+k}."))
 (|expand|
  ((|#2| $)
   "\\spad{expand(l..h by k)} creates value of type \\spad{L} with elements \\spad{l,{} l+k,{} ... lN} where \\spad{lN <= h < lN+k}. For example,{} \\spad{expand(1..5 by 2) = [1,{} 3,{} 5]}.")
  ((|#2| (|List| $))
   "\\spad{expand(l)} creates a new value of type \\spad{L} in which each segment \\spad{l..h by k} is replaced with \\spad{l,{} l+k,{} ... lN},{} where \\spad{lN <= h < lN+k}. For example,{} \\spad{expand [1..4,{} 7..9] = [1,{} 2,{} 3,{} 4,{} 7,{} 8,{} 9]}.")))
(("documentation" 0 2308) ("ancestors" 0 2027) ("parents" 0 1994)
 ("abbreviation" 0 1986) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 1035) ("modemaps" 0 439) ("sourceFile" 0 400)
 ("constructorCategory" 0 196) ("constructorModemap" 0 64)
 ("constructorKind" 0 53) ("constructorForm" 0 20))