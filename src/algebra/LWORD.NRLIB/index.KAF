8586                (|LyndonWord| |VarSet|)
|domain|
(((|LyndonWord| |#1|)
  (|Join| (|OrderedSet|) (|RetractableTo| |#1|)
          (CATEGORY |domain| (SIGNATURE |retractable?| ((|Boolean|) $))
           (SIGNATURE |left| ($ $)) (SIGNATURE |right| ($ $))
           (SIGNATURE |length| ((|PositiveInteger|) $))
           (SIGNATURE |lexico| ((|Boolean|) $ $))
           (SIGNATURE |coerce| ((|FreeMonoid| |#1|) $))
           (SIGNATURE |coerce| ((|FreeMagma| |#1|) $))
           (SIGNATURE |factor| ((|List| $) (|FreeMonoid| |#1|)))
           (SIGNATURE |lyndon?| ((|Boolean|) (|FreeMonoid| |#1|)))
           (SIGNATURE |lyndon| ($ (|FreeMonoid| |#1|)))
           (SIGNATURE |lyndonIfCan| ((|Union| $ "failed") (|FreeMonoid| |#1|)))
           (SIGNATURE |varList| ((|List| |#1|) $))
           (SIGNATURE |LyndonWordsList1|
            ((|OneDimensionalArray| (|List| $)) (|List| |#1|)
             (|PositiveInteger|)))
           (SIGNATURE |LyndonWordsList|
            ((|List| $) (|List| |#1|) (|PositiveInteger|)))))
  (|OrderedSet|))
 (T |LyndonWord|))
(|Join| (|OrderedSet|) (|RetractableTo| |#1|)
        (CATEGORY |domain| (SIGNATURE |retractable?| ((|Boolean|) $))
         (SIGNATURE |left| ($ $)) (SIGNATURE |right| ($ $))
         (SIGNATURE |length| ((|PositiveInteger|) $))
         (SIGNATURE |lexico| ((|Boolean|) $ $))
         (SIGNATURE |coerce| ((|FreeMonoid| |#1|) $))
         (SIGNATURE |coerce| ((|FreeMagma| |#1|) $))
         (SIGNATURE |factor| ((|List| $) (|FreeMonoid| |#1|)))
         (SIGNATURE |lyndon?| ((|Boolean|) (|FreeMonoid| |#1|)))
         (SIGNATURE |lyndon| ($ (|FreeMonoid| |#1|)))
         (SIGNATURE |lyndonIfCan| ((|Union| $ "failed") (|FreeMonoid| |#1|)))
         (SIGNATURE |varList| ((|List| |#1|) $))
         (SIGNATURE |LyndonWordsList1|
          ((|OneDimensionalArray| (|List| $)) (|List| |#1|)
           (|PositiveInteger|)))
         (SIGNATURE |LyndonWordsList|
          ((|List| $) (|List| |#1|) (|PositiveInteger|)))))
"/git/fricas/src/algebra/LWORD.spad"
((|retractable?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|LyndonWord| *3))
       (|ofCategory| *3 (|OrderedSet|))))
 (|left| (*1 *1 *1)
  (AND (|isDomain| *1 (|LyndonWord| *2)) (|ofCategory| *2 (|OrderedSet|))))
 (|right| (*1 *1 *1)
  (AND (|isDomain| *1 (|LyndonWord| *2)) (|ofCategory| *2 (|OrderedSet|))))
 (|length| (*1 *2 *1)
  (AND (|isDomain| *2 (|PositiveInteger|)) (|isDomain| *1 (|LyndonWord| *3))
       (|ofCategory| *3 (|OrderedSet|))))
 (|lexico| (*1 *2 *1 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|LyndonWord| *3))
       (|ofCategory| *3 (|OrderedSet|))))
 (|coerce| (*1 *2 *1)
           (AND (|isDomain| *2 (|FreeMonoid| *3))
                (|isDomain| *1 (|LyndonWord| *3))
                (|ofCategory| *3 (|OrderedSet|))))
 (|coerce| (*1 *2 *1)
           (AND (|isDomain| *2 (|FreeMagma| *3))
                (|isDomain| *1 (|LyndonWord| *3))
                (|ofCategory| *3 (|OrderedSet|))))
 (|factor| (*1 *2 *3)
  (AND (|isDomain| *3 (|FreeMonoid| *4)) (|ofCategory| *4 (|OrderedSet|))
       (|isDomain| *2 (|List| (|LyndonWord| *4)))
       (|isDomain| *1 (|LyndonWord| *4))))
 (|lyndon?| (*1 *2 *3)
  (AND (|isDomain| *3 (|FreeMonoid| *4)) (|ofCategory| *4 (|OrderedSet|))
       (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|LyndonWord| *4))))
 (|lyndon| (*1 *1 *2)
  (AND (|isDomain| *2 (|FreeMonoid| *3)) (|ofCategory| *3 (|OrderedSet|))
       (|isDomain| *1 (|LyndonWord| *3))))
 (|lyndonIfCan| (*1 *1 *2)
  (|partial| AND (|isDomain| *2 (|FreeMonoid| *3))
   (|ofCategory| *3 (|OrderedSet|)) (|isDomain| *1 (|LyndonWord| *3))))
 (|varList| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| *3)) (|isDomain| *1 (|LyndonWord| *3))
       (|ofCategory| *3 (|OrderedSet|))))
 (|LyndonWordsList1| (*1 *2 *3 *4)
  (AND (|isDomain| *3 (|List| *5)) (|isDomain| *4 (|PositiveInteger|))
       (|ofCategory| *5 (|OrderedSet|))
       (|isDomain| *2 (|OneDimensionalArray| (|List| (|LyndonWord| *5))))
       (|isDomain| *1 (|LyndonWord| *5))))
 (|LyndonWordsList| (*1 *2 *3 *4)
  (AND (|isDomain| *3 (|List| *5)) (|isDomain| *4 (|PositiveInteger|))
       (|ofCategory| *5 (|OrderedSet|))
       (|isDomain| *2 (|List| (|LyndonWord| *5)))
       (|isDomain| *1 (|LyndonWord| *5)))))
((~= (((|Boolean|) $ $) NIL)) (|varList| (((|List| |#1|) $) NIL))
 (|smaller?| (((|Boolean|) $ $) NIL)) (|right| (($ $) 51))
 (|retractable?| (((|Boolean|) $) NIL))
 (|retractIfCan| (((|Union| |#1| "failed") $) NIL)) (|retract| ((|#1| $) NIL))
 (|min| (($ $ $) NIL)) (|max| (($ $ $) NIL))
 (|lyndonIfCan| (((|Union| $ "failed") (|FreeMonoid| |#1|)) 23))
 (|lyndon?| (((|Boolean|) (|FreeMonoid| |#1|)) 15))
 (|lyndon| (($ (|FreeMonoid| |#1|)) 24)) (|lexico| (((|Boolean|) $ $) 29))
 (|length| (((|PositiveInteger|) $) 36)) (|left| (($ $) NIL))
 (|latex| (((|String|) $) NIL))
 (|hashUpdate!| (((|HashState|) (|HashState|) $) NIL))
 (|hash| (((|SingleInteger|) $) NIL))
 (|factor| (((|List| $) (|FreeMonoid| |#1|)) 17))
 (|coerce| (((|OutputForm|) $) 42) (($ |#1|) 33) (((|FreeMonoid| |#1|) $) 38)
           (((|FreeMagma| |#1|) $) 43))
 (|LyndonWordsList1|
  (((|OneDimensionalArray| (|List| $)) (|List| |#1|) (|PositiveInteger|)) 56))
 (|LyndonWordsList| (((|List| $) (|List| |#1|) (|PositiveInteger|)) 58))
 (>= (((|Boolean|) $ $) NIL)) (> (((|Boolean|) $ $) NIL))
 (= (((|Boolean|) $ $) 52)) (<= (((|Boolean|) $ $) NIL))
 (< (((|Boolean|) $ $) 37)))
LWORD
(((|OrderedSet|) . T) ((|RetractableTo| |#1|) . T))
(((|BasicType|) . T) ((|CoercibleTo| (|OutputForm|)) . T) ((|Comparable|) . T)
 ((|OrderedSet|) . T) ((|PartialOrder|) . T) ((|RetractableTo| |#1|) . T)
 ((|SetCategory|) . T))
((|constructor|
  (NIL
   "Lyndon words over arbitrary (ordered) symbols: see Free Lie Algebras by \\spad{C}. Reutenauer (Oxford science publications). A Lyndon word is a word which is smaller than any of its right factors \\spad{w}.\\spad{r}.\\spad{t}. the pure lexicographical ordering. If \\spad{a} and \\spad{b} are two Lyndon words such that \\spad{a < b} holds \\spad{w}.\\spad{r}.\\spad{t} lexicographical ordering then \\spad{a*b} is a Lyndon word. Parenthesized Lyndon words can be generated from symbols by using the following rule: \\spad{[[a,{} b],{} c]} is a Lyndon word iff \\spad{a*b < c <= b} holds. Lyndon words are internally represented by binary trees using the \\spadtype{FreeMagma} domain constructor. Two ordering are provided: lexicographic and length-lexicographic. \\newline Author : Michel Petitot (petitot@lifl.\\spad{fr})."))
 (|LyndonWordsList|
  (((|List| $) (|List| |#1|) (|PositiveInteger|))
   "\\spad{LyndonWordsList(vl,{} n)} returns the list of Lyndon words over the alphabet \\spad{vl},{} up to order \\spad{n}."))
 (|LyndonWordsList1|
  (((|OneDimensionalArray| (|List| $)) (|List| |#1|) (|PositiveInteger|))
   "\\spad{LyndonWordsList1(vl,{} n)} returns an array of lists of Lyndon words over the alphabet \\spad{vl},{} up to order \\spad{n}."))
 (|varList|
  (((|List| |#1|) $)
   "\\spad{varList(x)} returns the list of distinct entries of \\spad{x}."))
 (|lyndonIfCan|
  (((|Union| $ "failed") (|FreeMonoid| |#1|))
   "\\spad{lyndonIfCan(w)} convert \\spad{w} into a Lyndon word."))
 (|lyndon|
  (($ (|FreeMonoid| |#1|))
   "\\spad{lyndon(w)} convert \\spad{w} into a Lyndon word,{} error if \\spad{w} is not a Lyndon word."))
 (|lyndon?|
  (((|Boolean|) (|FreeMonoid| |#1|))
   "\\spad{lyndon?(w)} test if \\spad{w} is a Lyndon word."))
 (|factor|
  (((|List| $) (|FreeMonoid| |#1|))
   "\\spad{factor(x)} returns the decreasing factorization into Lyndon words."))
 (|coerce|
  (((|FreeMagma| |#1|) $)
   "\\spad{coerce(x)} returns the element of \\spadtype{FreeMagma}(VarSet) corresponding to \\spad{x}.")
  (((|FreeMonoid| |#1|) $)
   "\\spad{coerce(x)} returns the element of \\spadtype{FreeMonoid}(VarSet) corresponding to \\spad{x}."))
 (|lexico|
  (((|Boolean|) $ $)
   "\\spad{lexico(x,{} y)} returns \\spad{true} iff \\spad{x} is smaller than \\spad{y} \\spad{w}.\\spad{r}.\\spad{t}. the lexicographical ordering induced by \\spad{VarSet}."))
 (|length|
  (((|PositiveInteger|) $)
   "\\spad{length(x)} returns the number of entries in \\spad{x}."))
 (|right|
  (($ $)
   "\\spad{right(x)} returns right subtree of \\spad{x} or error if \\spadopFrom{retractable?}{LyndonWord}(\\spad{x}) is \\spad{true}."))
 (|left|
  (($ $)
   "\\spad{left(x)} returns left subtree of \\spad{x} or error if \\spadopFrom{retractable?}{LyndonWord}(\\spad{x}) is \\spad{true}."))
 (|retractable?|
  (((|Boolean|) $)
   "\\spad{retractable?(x)} tests if \\spad{x} is a tree with only one entry.")))
(("documentation" 0 5655) ("ancestors" 0 5478) ("parents" 0 5426)
 ("abbreviation" 0 5420) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 4267) ("modemaps" 0 2031) ("sourceFile" 0 1994)
 ("constructorCategory" 0 1070) ("constructorModemap" 0 53)
 ("constructorKind" 0 44) ("constructorForm" 0 20))