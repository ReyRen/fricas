)abbrev package MOMPKG MomentPackage
++ Author: Franz Lehner lehner@math.tugraz.at
++ Date Created: 2008
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   An auxiliary package for various moment and cumulant transformations
++   used in \spad{Distribution}.
MomentPackage(R : CommutativeRing) : Exports == Implementation where
  JAC2 ==> Record(an : R, bn : R)
  JAC2SEQ ==> Stream JAC2
  JACSEQ2 ==> Record(an : Stream R, bn : Stream R)
  JACLIST ==> Record(an : List R, bn : List R)
  STSOR ==> StreamTaylorSeriesOperations R
  STESOR ==> StreamExponentialSeriesOperations R
  STRREC ==> Record(puiseux : Fraction Integer, laurent : Fraction Integer,
                    coef : Sequence R)
  SUPR ==> SparseUnivariatePolynomial R
  SUPRpq ==> Record(first : SUPR, second : SUPR)
  RECSRM ==> Record(momt : List SUPR, cum : List R, mom : Stream R)

  Exports ==> with

    cumulant2moment : Sequence R -> Sequence R
      ++ \spad{cumulant2moment(cc)} computes the sequence of moments
      ++ from the sequence of classical cumulants cc
    moment2cumulant : Sequence R -> Sequence R
      ++ \spad{moment2cumulant(mm)} computes the sequence of classical
      ++ cumulants from the sequence of moments mm
    if R has Field then
      moment2nthJacobi : List R -> JACLIST
        ++ \spad{moment2nthJacobi(mm)} computes the list of Jacobi parameters
        ++ from the list of moments mm as far as possible.
      moment2jacobi : Sequence R -> JACSEQ2
        ++ \spad{moment2jacobi(mm)} computes the Jacobi parameters
        ++ as pair of streams.
      moment2jacobi2 : Sequence R -> JAC2SEQ
        ++ \spad{moment2jacobi2(mm)} computes the Jacobi parameters
        ++ as stream of pairs $(an, bn)$.
    freeCumulant2moment : Sequence R -> Sequence R
      ++ \spad{freeCumulant2moment(cc)} computes the sequence of moments
      ++ from the sequence of free cumulants cc
    moment2freeCumulant : Sequence R -> Sequence R
      ++ \spad{moment2freeCumulant(mm)} computes the sequence of free
      ++ cumulants from the sequence of moments mm
    booleanCumulant2moment : Sequence R -> Sequence R
      ++ \spad{booleanCumulant2moment(cc)} computes the sequence of moments
      ++ from the sequence of boolean cumulants cc
    moment2booleanCumulant : Sequence R -> Sequence R
      ++ \spad{moment2booleanCumulant(mm)} computes the sequence of boolean
      ++ cumulants from the sequence of moments mm
    monotoneCumulant2moment : Sequence R -> Sequence R
      ++ \spad{monotoneCumulant2moment(hh)} computes the sequence of moments
      ++ from the sequence of monotone cumulants hh
    monotoneCumulant2momentPoly : Sequence R -> Sequence SUPR
      ++ \spad{monotoneCumulant2momentPoly(hh)} computes the sequence
      ++ of moment polynomials $m_n(t)$ from the sequence of monotone
      ++ cumulants hh
    moment2monotoneCumulant : Sequence R -> Sequence R
      ++ \spad{moment2monotoneCumulant(mm)} computes the sequence of
      ++ monotone cumulants from the sequence of moments mm
    qcumulant2nthmoment : (R, Sequence R, NonNegativeInteger) -> R
      ++ \spad{qcumulant2nthmoment(q, cc, n)} computes the nth moment
      ++ from the sequence of reduced q-cumulants cc
    hankelDeterminant : (Sequence R, NonNegativeInteger) -> R
      ++ \spad{hankelDeterminant(x, n)} returns the nth Hankel determinant
      ++ of the sequence \spad{x}.
    jacobi2poly : (Stream R, Stream R) -> Stream SUPR
      ++ \spad{jacobi2poly(aa, bb)} returns the stream
      ++ of orthogonal polynomials corresponding to the
      ++ Jacobi parameters \spad{a_n} and \spad{b_n}.

    if R has Algebra Fraction Integer then

      moment2Stransform : Sequence R -> STRREC
        ++ \spad{moment2Stransform(x)} returns the Puiseux and Laurent order
        ++ and coefficients of the S transform of x
      moment2monotoneCumulant : Sequence R -> Sequence R
        ++ \spad{moment2monotoneCumulant(x)} returns the sequence
        ++ of monotone cumulants of the moment sequence x
  Implementation ==> add

)if false

\subsection{MomentPackage Classical cumulants}
Moments and cumulants are related via their exponential generating functions
$$
  \sum_{n=0}^\infty \frac{m_n}{n!} z^n =
  \exp \sum_{n=1}^\infty \frac{\kappa_n}{n!} z^n
  .
$$
This is more convenient than the recursion
$$
\kappa_n = \mu_n - \sum_{k=1}^{n-1} \binom{n-1}{k-1} \kappa_k \mu_{n-k}
.
$$
)endif

    cumulant2moment(cum : Sequence R) : Sequence R ==
        sequence rest exp0$STESOR stream cum

)if false
    The equivalent form of the recursion is
    $$
    \mu_n = \kappa_n + \sum_{k=1}^{n-1} \binom{n-1}{k} \mu_k \kappa_{n-k}
    $$
    but we rather use the logarithm of exponential power series.
)endif

    moment2cumulant(mom : Sequence R) : Sequence R ==
        sequence rest log1$STESOR stream mom

)if false

    \subsection{MomentPackage Free Cumulants}
    Free cumulants can be defined via their generating function.
    Given the ordinary moment generating function
    $$
    M(z) = 1 + \sum_{n=1}^\infty m_n z^n
    $$
    the free cumulant series
    $$
    C(z) = 1 + \sum_{n=1}^\infty c_n z^n
    .
    $$
    satisfies the equations
    $$
    C(zM(z))= M(z)
    \qquad
    M(z/C(z))=C(z)
    .
    $$
    In the first case the function $f(z) = zM(z)$ satisfies
    $$
    C(f(z))=1/z f(z)
    $$
    and can be directly translated into a call to [[lagrange]]
    from [[StreamTaylorSeriesOperations]],
    which can solve solve the general equation
    $$
    f(z) =z\, g(f(z))
    $$
    with function $g(z) = C(z)$.

)endif

    freeCumulant2moment(cum : Sequence R) : Sequence R ==
        import from STSOR
        coerce(rest rest lagrange concat(1@R, stream cum))

)if false

    In the other case, we can write
    $$
    \frac{z}{M(z/C(z))} = \frac{z}{C(z)}
    $$
    and take $f(z) = \frac{z}{C(z)}$ and $g(z)=\frac{1}{M(z)}$.

)endif

    moment2freeCumulant(mom : Sequence R) : Sequence R ==
        -- first divide
        g : Stream R := cons(1$R, stream mom)
        g1:Union(Stream R, "failed") := recip(g)$STSOR -- value1 --$
        -- g1 case "failed" => "failed"
        f : Stream R := lagrange(g1::Stream R)
        -- now we have f=z/C(z)
        f1:Union(Stream R, "failed") := recip rest f
        -- f1 case "failed" => "failed"
        coerce rest (f1::Stream R)

)if false

    \subsection{MomentPackage Boolean cumulants}
    The boolean cumulant generating function $B(z)$ and the
    moment generating function $M(z)$ are related by
    $$
    B(z) = 1-\frac{1}{M(z)}
    $$

)endif

    booleanCumulant2moment(x : Sequence R) : Sequence R ==
        rec : Stream R := cons(1$R, stream(-x))
        boo:Union(Stream R, "failed") :=
            recip(rec)$(StreamTaylorSeriesOperations R)
        rest sequence (boo::Stream R)

    moment2booleanCumulant(x : Sequence R) : Sequence R ==
        boo : Stream R := cons(1$R, stream x)
        mom : Union(Stream R, "failed") :=
            recip(boo)$(StreamTaylorSeriesOperations R)
        rest (- sequence (mom::Stream R))

    -- \subsection{MomentPackage Jacobi Parameters and Orthogonal Polynomials}

    hankelDeterminant(x : Sequence R, n : NonNegativeInteger) : R ==
    --    odd? n=> error "n must be even"
        import from HankelPackage R
        determinant HankelMatrix cons(1, firstn(x, 2*n))

    -- The Jacobi parameters are only available in the case of a Field.
    if R has Field then

)if false

    The Jacobi parameters are defined by
    $$
    x P_n(x) = P_{n+1}(x) + a_n P_n(x) + b_n P_{n-1}(x)
    $$
    they are computed via the recursion...

    %JACOBI3
    First a finite version using lists.

)endif

        moment2nthJacobi(mom : List R) : JACLIST ==
            N : Integer := (#mom)::Integer
            G : List R := mom -- add 1 to the moments
            aa : List R := empty()
            bb : List R := empty()
            while N>1 repeat
                -- assign the new coefficients
                ak : R := first G
                bk : R := second G - ak*ak
                aa := concat(aa, ak)
                bb := concat(bb, bk)
                -- invert G and store it in H.
                -- the first three entries are clear
                H : List R := [-ak, -bk]
                k, l : Integer
                for k in 3..N repeat
                    Hk : R := -G k
                    for l in 1..k-1 repeat
                        Hk := Hk - (G l) * H(k-l)
                    H := concat(H, Hk)
                if R has Field then
                    h : R
                    G := [-h/bk for h in  H ]
                    G := rest rest G
                N := N-2
            [aa, bb]

)if false

    Here is a recursive version.
    The algorithm is very simple:
    if
    $$
    F(z) = 1 + \sum_{n=1}^\infty c_n z^n
    = \cfrac{1}{1-a_1z-\cfrac{b_1z^2}{1-a_2z-\dots}}
    $$
    then
    $$
    \frac{1}{F(z)} = 1 - a_1z-b_1z^2G_2(z)
    $$
    and this can be recursively applied to $G_2(z)$.

)endif

        moment2jacobi2(mom : Sequence R) : JAC2SEQ == delay
            gseries : Stream R := cons(1, (stream$(Sequence R)) mom)
            -- first divide
            gseries1 := recip(gseries)$(StreamTaylorSeriesOperations R
                                       )::Stream R
            gseries1 := rest gseries1
            a : R := - first gseries1
            gseries1 := rest gseries1
            b : R := - first gseries1
            b1 : R := - inv b
            cons([a, b]$JAC2, moment2jacobi2( - inv b* sequence rst gseries1)
                )$JAC2SEQ

        moment2jacobi(mom : Sequence R) : JACSEQ2 ==
            res : JAC2SEQ := moment2jacobi2 mom
            [map(y+->y an, res)$(StreamFunctions2(JAC2, R)),
                map(y+->y bn, res)$(StreamFunctions2(JAC2, R))]$JACSEQ2

)if false

    The orthogonal polynomials satisfy the recursion
    $$
    xP_k(x) = P_{k+1}(x) + a_{k} P_k(x) + b_{k-1} P_{k-1}(x)
    $$
    where per definitionem we set $b_{-1}=0$ and we
    assume that the sequences of Jacobi coefficients both start
    with index $0$.
    In an auxiliary function we carry pairs of subsequent polynomials
    $P_n$, $P_{n-1}$ from which we obtain the pair $P_{n+1}$
    $$
    P_{n+1} = (x-a_n)P_n - b_{n-1}P_{n-1}
    $$
)endif

    xsup := monomial(1, 1)$SUPR

    jacobi2polypq(aa : Stream R, bb : Stream R, p : SUPR, q : SUPR
                 ) : Stream SUPRpq == delay
        q1 : SUPR := (xsup - (first aa)*1$SUPR)*q - first bb*p
        pq1 : SUPRpq := [q, q1]
        cons(pq1, jacobi2polypq(rest aa, rest bb, q, q1))
    -- From the stream of pairs we extract the first elements.

    jacobi2poly(aa : Stream R, bb : Stream R) : Stream SUPR ==
        p0 : SUPR := 1
        p1 : SUPR := xsup - (first aa)*p0
        res : Stream SUPRpq := jacobi2polypq(rest aa, bb, p0, p1)
        map( (pp : SUPRpq) : SUPR +-> pp.first, res
           )$StreamFunctions2(SUPRpq, SUPR)
)if false

\subsection{MomentPackage S-transform}
\label{ssec:mompackStrans}
Let $\psi(z) = \sum_{n=1}^\infty m_nz^n$ be the moment generating
function and $\chi(z)$ its compositional inverse,
then $S(z)=\chi(z)\frac{1+z}{z}$ is called \emph{$S$-transform}.
If $X$ and $Y$ are free with nonvanishing first moment, then
$S_{XY}(z) = S_X(z)S_Y(z)$.
If both have vanishing first moments, then the resulting distribution is
trivial.

If one of them has vanishing first moment, we have the following modification
\cite{RaoSpeicher:2007:multiplication}.
Assume that $X$ has vanishing first moment and $\psi(z) = \sum_{n=2}^\infty m_n
z^n$,
then $\psi(z)$ has two inverses (Puiseux series in $\pm\sqrt{z}$).
Let $\tilde{\psi}(z) = \sqrt{\psi(z)} =
z\sqrt{m_2}\sqrt{1+\frac{m_3}{m_2}z+\dots}$,
then $\tilde{\psi}$ has a compositional inverse $\tilde{\chi}(z)$, i.e.,
$\tilde{\psi}(\tilde{\chi}(z))=z$ and this means that
$\psi(\tilde{\chi}(z)) = z^2$, therefore $\tilde{\chi}(z) = \chi(z^2)$.

For the S-transform and monotone cumulants we need Puiseux series and therefore
the ring underlies restrictions.

A record containing the Puiseux exponent, the Laurent exponent
suitable for Puiseux series operations in the S-transform package
in section~\ref{sec:STRANS}.

)endif

    if R has Algebra Fraction Integer then

      moment2Stransform(x : Sequence R) : STRREC ==
          mom := stream x
          if zero? first mom then
              -- case of zero mean: take square root
              mom2 : Stream R := cons(0, powern(1/2, rest mom)$STSOR)
              -- invert
              chi2 : Stream R := revert(mom2)$STSOR
              chi2s : Sequence R := sequence chi2
              -- S2 = chi2+chi2/z^2
              S2 : Sequence R := cons(0, chi2s) + rest chi2s
              [1/2, -1, S2]$STRREC
            else
              -- case of nonzero mean
              mom := cons(0, mom)
              chi : Stream R := revert(mom)$STSOR
              -- S = chi + chi/z
              S : Sequence R := sequence chi + sequence rest chi
              [1, 0, S]$STRREC

)if false

\subsection{Monotone cumulants}
The monotone cumulants were defined by Hasebe
and are determined by the infinite system of differential equations
\begin{align*}
  m_n(0) &=0\\
  \frac{d m_n(t)}{dt}
  &= \sum_{k=1}^n kr_{n-k+1} m_{k-1}(t)\\
  &= r_n + \sum_{k=2}^n kr_{n-k+1} m_{k-1}(t)
\end{align*}
for $n\geq 1$, where $m_0(t) = 1$.

\subsubsection{From moments to monotone cumulants}
Given a moment sequence $m_n$,
the monotone cumulants can be computed inductively as follows.
Given $r_k$ and the polynomials $m_k(t)$ for $k\leq n-1$,
we integrate the equation on the interval $[0, 1]$ and obtain
$$
r_n = m_n - \int_0^1 \sum_{k=2}^n kr_{n-k+1} m_{k-1}(t)\, dt
$$
and then
\begin{equation}
  \label{mnt=trn}
m_n(t) = t r_n + \int_0^t \sum_{k=2}^n kr_{n-k+1} m_{k-1}(s) \,ds
.
\end{equation}
The ring must be an \spad{Algebra Fraction Integer}
in order for integration to work.
We keep the information in a record
\spad{RECSRM} with entries
\begin{description}
 \item[momt] the list of moment polynomials computed so far in reverse order
 \item[cum] the list of cumulants computed so far in reverse order
 \item[mom] the stream of remaining moments
\end{description}
The function \spad{moment2monotoneCumulantGenerator}
then implements the two steps above.

)endif

    -- monotone cumulants
      t := monomial(1, 1)$SUPR
      moment2monotoneCumulantGenerator(srm : RECSRM) : RECSRM ==
          mt : List SUPR := srm.momt
          rr : List R := srm.cum
          mm : Stream R := srm.mom
          n : Integer := #rr + 1
          tmp : SUPR := 0
          for k in 2..n for r in rr for m in reverse mt repeat
              tmp := tmp + k*m*r
          mnt : SUPR := integrate tmp
          rn : R := first mm - mnt 1
          mnt := mnt + t*rn
          rrnew : List R := cons(rn, rr)
          mtnew : List SUPR := cons(mnt, mt)
          return [mtnew, rrnew, rest mm]

      moment2monotoneCumulant(mm : Sequence R) : Sequence R ==
          m1t : SUPR := monomial(first mm, 1)$SUPR
          r1 := first mm
          mtr1 : RECSRM := [[m1t], [r1], rest stream mm]$RECSRM
          res : Stream RECSRM :=
              stream(moment2monotoneCumulantGenerator, mtr1)
          res1 : Stream R := map( (s : RECSRM) : R +-> first (s.cum), res
                                )$StreamFunctions2(RECSRM, R)
          sequence res1

)if false

    \subsubsection{From monotone cumulants to moments}
    For the converse direction we simply iterate the integral formula
    \eqref{mnt=trn}.
    We compute the stream of $m_n(t)$ and
    finally evaluate it at $t=1$.

)endif

    -- monotone cumulants
      RECMM ==> Record(cum : Stream R, momt : List SUPR)
      t := monomial(1, 1)$SUPR
      monotoneCumulant2momentGenerator(srm : RECMM) : RECMM ==
          mt : List SUPR := srm.momt
          rr : Stream R := srm.cum
          n : Integer := #mt + 1
          NNI==> NonNegativeInteger
          tmp : SUPR := 0
          for k in 1..n-1 for m in mt repeat
              tmp := tmp + (n+1-k)*m*first rr
              rr := rest rr
          mnt : SUPR := t*first rr + integrate tmp
          mtnew : List SUPR := cons(mnt, mt)
          return [srm.cum, mtnew]

      monotoneCumulant2moment(rr : Sequence R) : Sequence R ==
          m1t : SUPR := monomial(first rr, 1)$SUPR
          mtr1: RECMM := [stream rr, [m1t]]$RECMM
          res : Stream RECMM := stream(monotoneCumulant2momentGenerator, mtr1)
          res1 : Stream R := map( (s : RECMM) : R +-> (first (s.momt)).(1),
                                  res)$StreamFunctions2(RECMM, R)
          sequence res1

      monotoneCumulant2momentPoly(rr : Sequence R) : Sequence SUPR ==
          m1t : SUPR := monomial(first rr, 1)$SUPR
          mtr1 : RECMM := [stream rr, [m1t]]$RECMM
          res : Stream RECMM := stream(monotoneCumulant2momentGenerator, mtr1)
          res1 : Stream SUPR := map( (s : RECMM) : SUPR +-> (first (s.momt)),
                                     res)$StreamFunctions2(RECMM, SUPR)
          sequence res1


)if false
\section{package STRANS STransformPackage}
\label{sec:STRANS}
In the case of a field we can also do the $S$-transform.
As discussed above (Section~\ref{ssec:mompackStrans},
there are cases where the $S$-transform is a Puiseux series.
)endif

