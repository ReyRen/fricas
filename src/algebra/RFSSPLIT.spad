)abbrev package RFSSPLIT RootFSSplit
RootFSSplit(R, F) : Exports == Implementation where
  R : Join(IntegralDomain, RetractableTo Integer, Comparable)
  F : FunctionSpace(R)
  K ==> Kernel(F)
  Alg_Rec ==> Record(funs : List F, nroot : F, npow1 : Integer,
                     npow2 : Integer)
  Exports ==> with
      alg_split_roots : (List F, r1 : K, r2 : K) -> List(Alg_Rec)
        ++ alg_split_roots(lf, r1, r2) splits each f in lf into
        ++ linear combination of product of powers of r1 and r2
        ++ which must be independent roots.
      alg_split_root0 : (F, K, Integer) -> List F

  Implementation == add

    P ==> SparseMultivariatePolynomial(R, K)

    alg_split_root0(f : F, r : K, n : Integer) : List F ==
        n = 2 =>
            ef := eval(f, r, -(r::F))
            f0 := (f + ef)/(2::F)
            f1 := (f - ef)/(2::F)
            member?(r, kernels(f0)) =>
                print(f0::OutputForm)
                error "alg_split_root0: roots did not cancel 1"
            f1 := f1/(r::F)
            member?(r, kernels(f1)) =>
                print(f1::OutputForm)
                error "alg_split_root0: roots did not cancel 2"
            [f0, f1]
        q := univariate(f, r, minPoly r
                      )$PolynomialCategoryQuotientFunctions(IndexedExponents K,
                          K, R, P, F)
        [coefficient(q, i) for i in 0..(n-1)]

    alg_split_root2(lf : List F, r : K, n : Integer) :  List List F ==
        nlf0 : List List F := [alg_split_root0(f, r, n) for f in lf]
        res : List List F := []
        for pow1 in (0$Integer)..(n - 1) repeat
            nlf1 := nlf0
            resi : List(F) := []
            while not(empty?(nlf1)) repeat
                lf1 := first(nlf1)
                resi := cons(first(lf1), resi)
                setfirst!(nlf1, rest(lf1))
                nlf1 := rest(nlf1)
            resi := reverse!(resi)
            res := cons(resi, res)
        reverse!(res)

    alg_split_roots(lf : List F, r1 : K, r2 : K) : List(Alg_Rec) ==
        a1 := argument(r1)
        a2 := argument(r2)
        n1 : Integer := retract(a1(2))@Integer
        b1 := a1(1)
        n2 : Integer := retract(a2(2))@Integer
        b2 := a2(1)
        ll1 : List List F := alg_split_root2(lf, r1, n1)
        res : List(Alg_Rec) := []
        pow1 : Integer
        rop := operator(r1)
        for l1 in ll1 for pow1 in (0$Integer)..(n1 - 1) repeat
            every?((f1 : F) : Boolean +-> f1 = 0, l1) => "iterate"
            ll2 := alg_split_root2(l1, r2, n2)
            g1 := gcd(n1, pow1)$Integer
            nn1 := (n1 exquo g1)::Integer
            np1 := (pow1 exquo g1)::Integer
            for l2 in ll2 for pow2 in 0..(n2 - 1) repeat
                every?((f1 : F) : Boolean +-> f1 = 0, l2) => "iterate"
                g2 := gcd(n2, pow2)
                nn2 := (n2 exquo g2)::Integer
                np2 := (pow2 exquo g2)::Integer
                nn := lcm(nn1, nn2)
                bb1 := b1^(np1*(nn exquo nn1)::Integer)
                bb2 := b2^(np2*(nn exquo nn2)::Integer)
                nrr :=
                    pow1 + pow2 > 0 =>
                        kernel(rop, [bb1*bb2, nn::F])::F
                    1$F
                nl := [f1*nrr for f1 in l2]
                res := cons([nl, nrr, pow1, pow2]$Alg_Rec, res)
        res

