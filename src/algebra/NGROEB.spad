)abbrev package NGROEB NGroebnerPackage

++ Description:
++   This is package computes noncommutative Groebner basis.
++   Based on commutative version.  Note that this package
++   accepts rings as base domain, however computed basis
++   is over left fraction field.  Computations are done
++   in fraction free way (coefficients stay in base ring).

NGroebnerPackage(Dom, Expon, Dpol) : T == C where

  Dom : LeftOreRing
  Expon : OrderedAbelianMonoidSup
  Dpol :  SolvableSkewPolynomialCategory(Dom, Expon)
  NNI    ==> NonNegativeInteger
  critPair ==> Record( lcmfij : Expon, totdeg : NonNegativeInteger,
                      poli : Dpol, polj : Dpol )
  sugarPol ==> Record( totdeg : NonNegativeInteger, pol : Dpol)

  T == with
     groebner : List(Dpol) -> List(Dpol)
       ++ groebner(lp) computes a groebner basis for a polynomial ideal
       ++ generated by the list of polynomials lp.

     redPol : (Dpol, List(Dpol))  -> Dpol
       ++ normalForm(poly, gb) reduces the polynomial poly modulo the
       ++ precomputed groebner basis gb giving up to a constant factor
       ++ a canonical representative of the residue class.

     hMonic : Dpol  -> Dpol
       ++ hMonic(p) tries to remove content from p
     virtualDegree : Dpol -> NonNegativeInteger
       ++ virtualDegree
     sPol : critPair  -> Dpol
       ++ sPol

  C == add

   import from OutputForm

   credPol : (Dpol, List(Dpol))  -> Dpol
   critM : (Expon, Expon) -> Boolean
   redPo : (Dpol, List(Dpol) )  ->  Record(poly : Dpol, mult : Dom)
   -- hMonic:  Dpol  -> Dpol
   updatF : (Dpol, NNI, List(sugarPol) ) -> List(sugarPol)
   -- sPol:  critPair  -> Dpol
   updatD : (List(critPair), List(critPair)) -> List(critPair)
   critpOrder : (critPair, critPair) -> Boolean
   makeCrit : (sugarPol, Dpol, NonNegativeInteger) -> critPair
   -- virtualDegree : Dpol -> NonNegativeInteger
   lcmCo : (Dom, Dom) -> Record(co1 : Dom, co2 : Dom)

   lcmCo(c1, c2) ==
       lcc := lcmCoef(c1, c2)
       [lcc.coeff1, lcc.coeff2]

   ------  Definition of intermediate functions
   if Dpol has totalDegree : Dpol -> NonNegativeInteger then
     virtualDegree p == totalDegree p
   else
     virtualDegree p == 0

   ------  ordering of critpairs

   critpOrder(cp1, cp2) ==
     cp1.totdeg < cp2.totdeg => true
     cp2.totdeg < cp1.totdeg => false
     cp1.lcmfij < cp2.lcmfij

   ------    creating a critical pair

   makeCrit(sp1, p2, totdeg2) ==
     p1 := sp1.pol
     deg := sup(degree(p1), degree(p2))
     e1 := subtractIfCan(deg, degree(p1))::Expon
     e2 := subtractIfCan(deg, degree(p2))::Expon
     tdeg := max(sp1.totdeg + virtualDegree(monomial(1, e1)),
                 totdeg2 + virtualDegree(monomial(1, e2)))
     [deg, tdeg, p1, p2]$critPair

   ------    calculate basis

   gbasis(Pol : List(Dpol)) : List(Dpol) ==
     D, D1 : List(critPair)
     ---------   create D and Pol

     Pol1 := sort((z1, z2) +-> degree z1 > degree z2, Pol)
     basPols := updatF(hMonic(first Pol1), virtualDegree(first Pol1), [])
     Pol1 := rest(Pol1)
     D := []
     while not(empty?(Pol1)) repeat
        h := hMonic(first(Pol1))
        Pol1 := rest(Pol1)
        toth := virtualDegree h
        D1 := [makeCrit(x, h, toth) for x in basPols]
        D := updatD(sort(critpOrder, D1), D)
        basPols := updatF(h, toth, basPols)
     D := sort(critpOrder, D)

     redPols := [x.pol for x in basPols]
     while not(empty?(D)) repeat
         D0 := first D
         s := hMonic(sPol(D0))
         D := rest(D)
         h := hMonic(redPol(s, redPols))
         h = 0  => "iterate"
         degree(h) = 0 =>
           D := []
           basPols := updatF(h, 0, [])
           break

         D1 := [makeCrit(x, h, D0.totdeg) for x in basPols]
         D := updatD(sort(critpOrder, D1), D)

         basPols := updatF(h, D0.totdeg, basPols)
         redPols := concat(redPols, h)
     Pol := [x.pol for x in basPols]
     Pol

            ----  calculate minimal basis for ordered F

   minGbasis(F : List(Dpol)) : List(Dpol) ==
       empty?(F) => []
       newbas := minGbasis rest F
       cons(hMonic credPol( first(F), newbas), newbas)

   groebner(F) ==
       minGbasis(sort((x, y) +-> degree x > degree y, gbasis(F)))

            --- calculate S-polynomial of a critical pair

   sPol(p : critPair)==
      Tij := p.lcmfij
      fi := p.poli
      fj := p.polj
      fi := monomial(1, subtractIfCan(Tij, degree fi)::Expon)*fi
      fj := monomial(1, subtractIfCan(Tij, degree fj)::Expon)*fj
      cc := lcmCo(leadingCoefficient fi, leadingCoefficient fj)
      cc.co1*fi - cc.co2*fj

   redPo(s : Dpol, F : List(Dpol)) ==
      m : Dom := 1
      Fh := F
      while not(s = 0 or empty?(F)) repeat
        f1 := first(F)
        s1 := degree(s)
        e : Union(Expon, "failed")
        d1 := degree(f1)
        (e := subtractIfCan(s1, d1)) case Expon  =>
           f2 := monomial(1, e)*f1
           cc := lcmCo(leadingCoefficient s, leadingCoefficient f2)
           s := cc.co1*s - cc.co2*f2
           if degree(s) = s1 then
               print(message("no progress in reduction"))
               print(s1::OutputForm)
               print(d1::OutputForm)
               print(e::OutputForm)
               print(degree(f2)::OutputForm)
               print(cc::OutputForm)
               print(s::OutputForm)
               error "no progress in reduction"
           m := m*cc.co1
           F := Fh
        F := rest F
      [s, m]

   redPol(s : Dpol, F : List(Dpol)) ==
      credPol(redPo(s, F).poly, F)

   if Dpol has primitivePart : Dpol -> Dpol then
       hMonic(p) == primitivePart p
   else
       hMonic(p) == p

            ---  reduce all terms of h mod F  (iterative version )

   credPol(h : Dpol, F : List(Dpol) ) ==
        empty?(F) => h
        h0 : Dpol := monomial(leadingCoefficient h, degree h)
        while (h := reductum h) ~= 0 repeat
           hred := redPo(h, F)
           h := hred.poly
           h0 := (hred.mult)*h0 + monomial(leadingCoefficient(h), degree h)
        h0

             --- concat ordered critical pair lists D1 and D2

   updatD(D1 : List(critPair), D2 : List(critPair)) ==
      empty?(D1) => D2
      empty?(D2) => D1
      dl1 := first(D1)
      dl2 := first(D2)
      critpOrder(dl1, dl2) => cons(dl1, updatD(D1.rest, D2))
      cons(dl2, updatD(D1, D2.rest))

            --- crit M - true, if lexp#2 multiple of lexp#1

   critM(e1 : Expon, e2 : Expon) ==
         en : Union(Expon, "failed")
         (en := subtractIfCan(e2, e1)) case Expon

   --- concat F and h and erase polys in F with lexp
   --- beeing multiple of lexp h
   --- Can do this because such poly can be recoverd
   --- from critical pair

   updatF(h : Dpol, deg : NNI, F : List(sugarPol)) ==
       empty?(F) => [[deg, h]]
       f1:= first(F)
       critM(degree(h), degree(f1.pol))  => updatF(h, deg, rest(F))
       cons(f1, updatF(h, deg, rest(F)))



