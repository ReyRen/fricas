9177                (MAKEPROP '|ILogic| 'NILADIC T)
(|ILogic|)
|domain|
(((|ILogic|)
  (|Join| (|BoundedLattice|)
          (CATEGORY |domain| (SIGNATURE |logicT| ($)) (SIGNATURE |logicF| ($))
           (SIGNATURE |proposition| ($ (|String|)))
           (SIGNATURE |implies| ($ $ $)) (SIGNATURE |redux| ($ $))
           (SIGNATURE |factor| ((|List| $) $))
           (SIGNATURE |deductions| ((|List| $) (|List| $)))
           (SIGNATURE = ((|Boolean|) $ $)) (SIGNATURE ~ ($ $))
           (SIGNATURE |opType| ((|Symbol|) $))
           (SIGNATURE |getChildren| ((|List| $) $))
           (SIGNATURE |atom?| ((|Boolean|) $))
           (SIGNATURE |value| ((|Symbol|) $))
           (SIGNATURE |parseIL| ($ (|String|)))
           (SIGNATURE |parseIL2|
            ((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|)))
             (|String|) (|NonNegativeInteger|)))
           (SIGNATURE |parseILTerm|
            ((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|)))
             (|String|) (|NonNegativeInteger|)))
           (SIGNATURE |toString| ((|String|) $))
           (SIGNATURE |toStringUnwrapped| ((|String|) $)))))
 (T |ILogic|))
(|Join| (|BoundedLattice|)
        (CATEGORY |domain| (SIGNATURE |logicT| ($)) (SIGNATURE |logicF| ($))
         (SIGNATURE |proposition| ($ (|String|))) (SIGNATURE |implies| ($ $ $))
         (SIGNATURE |redux| ($ $)) (SIGNATURE |factor| ((|List| $) $))
         (SIGNATURE |deductions| ((|List| $) (|List| $)))
         (SIGNATURE = ((|Boolean|) $ $)) (SIGNATURE ~ ($ $))
         (SIGNATURE |opType| ((|Symbol|) $))
         (SIGNATURE |getChildren| ((|List| $) $))
         (SIGNATURE |atom?| ((|Boolean|) $)) (SIGNATURE |value| ((|Symbol|) $))
         (SIGNATURE |parseIL| ($ (|String|)))
         (SIGNATURE |parseIL2|
          ((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|)))
           (|String|) (|NonNegativeInteger|)))
         (SIGNATURE |parseILTerm|
          ((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|)))
           (|String|) (|NonNegativeInteger|)))
         (SIGNATURE |toString| ((|String|) $))
         (SIGNATURE |toStringUnwrapped| ((|String|) $))))
"/git/fricas/src/algebra/ILOGIC.spad"
((= (*1 *2 *1 *1) (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|ILogic|))))
 (|logicT| (*1 *1) (|isDomain| *1 (|ILogic|)))
 (|logicF| (*1 *1) (|isDomain| *1 (|ILogic|)))
 (|proposition| (*1 *1 *2)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *1 (|ILogic|))))
 (|implies| (*1 *1 *1 *1) (|isDomain| *1 (|ILogic|)))
 (|redux| (*1 *1 *1) (|isDomain| *1 (|ILogic|)))
 (|factor| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|ILogic|))) (|isDomain| *1 (|ILogic|))))
 (|deductions| (*1 *2 *2)
  (AND (|isDomain| *2 (|List| (|ILogic|))) (|isDomain| *1 (|ILogic|))))
 (~ (*1 *1 *1) (|isDomain| *1 (|ILogic|)))
 (|opType| (*1 *2 *1)
  (AND (|isDomain| *2 (|Symbol|)) (|isDomain| *1 (|ILogic|))))
 (|getChildren| (*1 *2 *1)
  (AND (|isDomain| *2 (|List| (|ILogic|))) (|isDomain| *1 (|ILogic|))))
 (|atom?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|ILogic|))))
 (|value| (*1 *2 *1)
  (AND (|isDomain| *2 (|Symbol|)) (|isDomain| *1 (|ILogic|))))
 (|parseIL| (*1 *1 *2)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *1 (|ILogic|))))
 (|parseIL2| (*1 *2 *3 *4)
  (AND (|isDomain| *3 (|String|)) (|isDomain| *4 (|NonNegativeInteger|))
       (|isDomain| *2
                   (|Record| (|:| |rft| (|ILogic|))
                             (|:| |pout| (|NonNegativeInteger|))))
       (|isDomain| *1 (|ILogic|))))
 (|parseILTerm| (*1 *2 *3 *4)
  (AND (|isDomain| *3 (|String|)) (|isDomain| *4 (|NonNegativeInteger|))
       (|isDomain| *2
                   (|Record| (|:| |rft| (|ILogic|))
                             (|:| |pout| (|NonNegativeInteger|))))
       (|isDomain| *1 (|ILogic|))))
 (|toString| (*1 *2 *1)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *1 (|ILogic|))))
 (|toStringUnwrapped| (*1 *2 *1)
  (AND (|isDomain| *2 (|String|)) (|isDomain| *1 (|ILogic|)))))
((~= (((|Boolean|) $ $) NIL)) (~ (($ $) 11)) (|value| (((|Symbol|) $) 32))
 (|toStringUnwrapped| (((|String|) $) 48)) (|toString| (((|String|) $) 46))
 (|redux| (($ $) 19)) (|proposition| (($ (|String|)) 8))
 (|parseILTerm|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   38))
 (|parseIL2|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   43))
 (|parseIL| (($ (|String|)) 45)) (|opType| (((|Symbol|) $) 30))
 (|logicT| (($) 9)) (|logicF| (($) 10)) (|latex| (((|String|) $) NIL))
 (|implies| (($ $ $) 18)) (|hashUpdate!| (((|HashState|) (|HashState|) $) NIL))
 (|hash| (((|SingleInteger|) $) NIL)) (|getChildren| (((|List| $) $) 21))
 (|factor| (((|List| $) $) 24)) (|deductions| (((|List| $) (|List| $)) 29))
 (|coerce| (((|OutputForm|) $) 51)) (|atom?| (((|Boolean|) $) 31))
 (|_\|_| (($) NIL T CONST)) (|\\/| (($ $ $) 15)) (T$ (($) NIL T CONST))
 (= (((|Boolean|) $ $) 13)) (|/\\| (($ $ $) 14)))
ILOGIC
(((|BoundedLattice|) . T))
(((|BasicType|) . T) ((|BoundedJoinSemilattice|) . T) ((|BoundedLattice|) . T)
 ((|BoundedMeetSemilattice|) . T) ((|CoercibleTo| (|OutputForm|)) . T)
 ((|JoinSemilattice|) . T) ((|MeetSemilattice|) . T) ((|SetCategory|) . T))
((|constructor| (NIL "parse result includes term returned and new index"))
 (|toStringUnwrapped|
  (((|String|) $)
   "similar to 'toString' but does not put outer compound terms in brackets"))
 (|toString|
  (((|String|) $)
   "creates a string representation of this term and its sub-terms"))
 (|parseILTerm|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   "parseTerm is used by parseIL. It would rarely be called externally but it is here to allow it to call parseIL that is to allow circular calls"))
 (|parseIL2|
  (((|Record| (|:| |rft| $) (|:| |pout| (|NonNegativeInteger|))) (|String|)
    (|NonNegativeInteger|))
   "Constructs intuitionistic logic terms from a string notation assumes format like this: <term2> : \\spad{:=} var | \"(\"<term>\")\" <term> : \\spad{:=} var | <term>/\\spad{\\<}term> | <term>\\spad{\\/}<term> | \\indented{11}{<term>-><term> | \"(\"<term>\")\"}"))
 (|parseIL|
  (($ (|String|))
   "Constructs intuitionistic logic terms from a string notation assumes format like this: <term> : \\spad{:=} var | <term>/\\spad{\\<}term> | <term>\\spad{\\/}<term> | \\indented{11}{<term>-><term> | \"(\"<term>\")\"}"))
 (|value|
  (((|Symbol|) $)
   "returns: \\indented{2}{\"T\"::Symbol = \\spad{T}} \\indented{2}{\"F\"::Symbol = \\spad{_|_}} \\indented{2}{\"E\"::Symbol = error} \\indented{2}{\"P\"::Symbol = proposition} \\indented{2}{\"C\"::Symbol = compound} Constructs lambda term and bind any variables with the name provided"))
 (|atom?|
  (((|Boolean|) $)
   "returns \\spad{true} if this is an atom,{} that is a leaf node otherwise return \\spad{false} if this is a compound term"))
 (|getChildren|
  (((|List| $) $)
   "returns child nodes if this is a compound term otherwise returns []"))
 (|opType|
  (((|Symbol|) $)
   "if this is a compound op then opType returns the type of that op: \"IMPLY\"::Symbol =implies \"AND\"::Symbol=/\\ \"OR\"::Symbol=\\spad{\\/} \"NOT\"::Symbol=~ \"OTHER\"::Symbol=not compound op"))
 (~
  (($ $)
   "\\spad{~(x)} returns the logical complement of \\spad{x}. TODO not sure if complement should be included here? intuitionistic logic can have complement but has different axioms to complement in Boolean algebra. Equivalent capability can be provided by implication."))
 (=
  (((|Boolean|) $ $)
   "returns \\spad{true} (boolean \\spad{true}) if intuitionisticLogic values are the same. Translates from Intuitionistic Logic to Boolean Logic"))
 (|deductions|
  (((|List| $) (|List| $))
   "assumes \\spad{ln} contains a list of factors which must be \\spad{true} for the whole to be \\spad{true} (such as the list produced by factor). From this deductions attempts to produce a list of other proposition that must also be \\spad{true} by using modus ponens. This is used to determine the returned type when converting ILogic to types by using the Curry-Howard isomorphism."))
 (|factor|
  (((|List| $) $)
   "splits \\spad{n} into a list of factors which must be \\spad{true} for the whole to be \\spad{true}. This assumes that the top level is already a set of factors separated by \\spad{/\\} otherwise the result will just be a list with one entry: \\spad{'n'}. This is used when converting ILogic to types by using the Curry-Howard isomorphism."))
 (|redux|
  (($ $)
   "attempt to simplify theory apply recursively to subnodes normally this should not be necessary since logic values are interpreted when constructed"))
 (|implies|
  (($ $ $)
   "\\spad{implies(a,{} b)} returns the logical implication of ILogic a and \\spad{b}. a is premise,{} \\spad{b} is conclusion,{} result is \\spad{false} (contradiction) if premise=true and conclusion=false does not mean there is a causal connection"))
 (|proposition| (($ (|String|)) "Constructs a proposition"))
 (|logicF| (($) "\\spad{false} (contradiction) is a logical constant."))
 (|logicT| (($) "\\spad{true} is a logical constant.")))
(("documentation" 0 5260) ("ancestors" 0 5034) ("parents" 0 5007)
 ("abbreviation" 0 5000) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 3985) ("modemaps" 0 2203) ("sourceFile" 0 2165)
 ("constructorCategory" 0 1162) ("constructorModemap" 0 72)
 ("constructorKind" 0 63) ("constructorForm" 0 52) ("NILADIC" 0 20))