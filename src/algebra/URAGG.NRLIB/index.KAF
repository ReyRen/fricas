15976               (|UnaryRecursiveAggregate| S)
|category|
(((|UnaryRecursiveAggregate| |#1|) (|Category|) (|Type|))
 (T |UnaryRecursiveAggregate|))
(|Join| (|RecursiveAggregate| |t#1|)
        (CATEGORY |domain| (SIGNATURE |concat| ($ $ $))
         (SIGNATURE |concat| ($ |t#1| $)) (SIGNATURE |first| (|t#1| $))
         (SIGNATURE |elt| (|t#1| $ "first"))
         (SIGNATURE |first| ($ $ (|NonNegativeInteger|)))
         (SIGNATURE |rest| ($ $)) (SIGNATURE |elt| ($ $ "rest"))
         (SIGNATURE |rest| ($ $ (|NonNegativeInteger|)))
         (SIGNATURE |last| (|t#1| $)) (SIGNATURE |elt| (|t#1| $ "last"))
         (SIGNATURE |last| ($ $ (|NonNegativeInteger|)))
         (SIGNATURE |tail| ($ $)) (SIGNATURE |second| (|t#1| $))
         (SIGNATURE |third| (|t#1| $)) (SIGNATURE |cycleEntry| ($ $))
         (SIGNATURE |cycleLength| ((|NonNegativeInteger|) $))
         (SIGNATURE |cycleTail| ($ $))
         (IF (|has| $ (|shallowlyMutable|))
             (PROGN
              (SIGNATURE |concat!| ($ $ $))
              (SIGNATURE |concat!| ($ $ |t#1|))
              (SIGNATURE |cycleSplit!| ($ $))
              (SIGNATURE |setfirst!| (|t#1| $ |t#1|))
              (SIGNATURE |qsetfirst!| (|t#1| $ |t#1|))
              (SIGNATURE |setelt!| (|t#1| $ "first" |t#1|))
              (SIGNATURE |setrest!| ($ $ $))
              (SIGNATURE |qsetrest!| ($ $ $))
              (SIGNATURE |setelt!| ($ $ "rest" $))
              (SIGNATURE |setlast!| (|t#1| $ |t#1|))
              (SIGNATURE |setelt!| (|t#1| $ "last" |t#1|))
              (SIGNATURE |split!| ($ $ (|NonNegativeInteger|))))
             |noBranch|)))
"/git/fricas/src/algebra/URAGG.spad"
((|concat| (*1 *1 *1 *1)
           (AND (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
                (|ofCategory| *2 (|Type|))))
 (|concat| (*1 *1 *2 *1)
           (AND (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
                (|ofCategory| *2 (|Type|))))
 (|first| (*1 *2 *1)
  (AND (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|elt| (*1 *2 *1 *3)
  (AND (|isDomain| *3 "first") (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|first| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|NonNegativeInteger|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *3))
       (|ofCategory| *3 (|Type|))))
 (|rest| (*1 *1 *1)
  (AND (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|elt| (*1 *1 *1 *2)
  (AND (|isDomain| *2 "rest") (|ofCategory| *1 (|UnaryRecursiveAggregate| *3))
       (|ofCategory| *3 (|Type|))))
 (|rest| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|NonNegativeInteger|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *3))
       (|ofCategory| *3 (|Type|))))
 (|last| (*1 *2 *1)
         (AND (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
              (|ofCategory| *2 (|Type|))))
 (|elt| (*1 *2 *1 *3)
  (AND (|isDomain| *3 "last") (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|last| (*1 *1 *1 *2)
         (AND (|isDomain| *2 (|NonNegativeInteger|))
              (|ofCategory| *1 (|UnaryRecursiveAggregate| *3))
              (|ofCategory| *3 (|Type|))))
 (|tail| (*1 *1 *1)
  (AND (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|second| (*1 *2 *1)
  (AND (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|third| (*1 *2 *1)
  (AND (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|cycleEntry| (*1 *1 *1)
  (AND (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|cycleLength| (*1 *2 *1)
  (AND (|ofCategory| *1 (|UnaryRecursiveAggregate| *3))
       (|ofCategory| *3 (|Type|)) (|isDomain| *2 (|NonNegativeInteger|))))
 (|cycleTail| (*1 *1 *1)
  (AND (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|concat!| (*1 *1 *1 *1)
  (AND (|ofCategory| *1 (|shallowlyMutable|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|concat!| (*1 *1 *1 *2)
  (AND (|ofCategory| *1 (|shallowlyMutable|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|cycleSplit!| (*1 *1 *1)
  (AND (|ofCategory| *1 (|shallowlyMutable|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|setfirst!| (*1 *2 *1 *2)
  (AND (|ofCategory| *1 (|shallowlyMutable|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|qsetfirst!| (*1 *2 *1 *2)
  (AND (|ofCategory| *1 (|shallowlyMutable|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|setelt!| (*1 *2 *1 *3 *2)
  (AND (|isDomain| *3 "first") (|ofCategory| *1 (|shallowlyMutable|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|setrest!| (*1 *1 *1 *1)
  (AND (|ofCategory| *1 (|shallowlyMutable|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|qsetrest!| (*1 *1 *1 *1)
  (AND (|ofCategory| *1 (|shallowlyMutable|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|setelt!| (*1 *1 *1 *2 *1)
  (AND (|isDomain| *2 "rest") (|ofCategory| *1 (|shallowlyMutable|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *3))
       (|ofCategory| *3 (|Type|))))
 (|setlast!| (*1 *2 *1 *2)
  (AND (|ofCategory| *1 (|shallowlyMutable|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|setelt!| (*1 *2 *1 *3 *2)
  (AND (|isDomain| *3 "last") (|ofCategory| *1 (|shallowlyMutable|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *2))
       (|ofCategory| *2 (|Type|))))
 (|split!| (*1 *1 *1 *2)
  (AND (|isDomain| *2 (|NonNegativeInteger|))
       (|ofCategory| *1 (|shallowlyMutable|))
       (|ofCategory| *1 (|UnaryRecursiveAggregate| *3))
       (|ofCategory| *3 (|Type|)))))
((~=
  (((|Boolean|) $ $) 6
   (OR (|has| |#1| (|SetCategory|))
       (AND (|has| |#1| (|BasicType|)) (|has| $ (|finiteAggregate|))))))
 (|value| ((|#1| $) 6)) (|third| ((|#1| $) 6)) (|tail| (($ $) 6))
 (|split!| (($ $ (|NonNegativeInteger|)) 6 (|has| $ (|shallowlyMutable|))))
 (|size?| (((|Boolean|) $ (|NonNegativeInteger|)) 6))
 (|setvalue!| ((|#1| $ |#1|) 6 (|has| $ (|shallowlyMutable|))))
 (|setrest!| (($ $ $) 6 (|has| $ (|shallowlyMutable|))))
 (|setlast!| ((|#1| $ |#1|) 6 (|has| $ (|shallowlyMutable|))))
 (|setfirst!| ((|#1| $ |#1|) 6 (|has| $ (|shallowlyMutable|))))
 (|setelt!| ((|#1| $ #1="value" |#1|) 6 (|has| $ (|shallowlyMutable|)))
  ((|#1| $ "first" |#1|) 6 (|has| $ (|shallowlyMutable|)))
  (($ $ "rest" $) 6 (|has| $ (|shallowlyMutable|)))
  ((|#1| $ "last" |#1|) 6 (|has| $ (|shallowlyMutable|))))
 (|setchildren!| (($ $ (|List| $)) 6 (|has| $ (|shallowlyMutable|))))
 (|second| ((|#1| $) 6)) (|sample| (($) 6 T CONST))
 (|rest| (($ $) 6) (($ $ (|NonNegativeInteger|)) 6))
 (|qsetrest!| (($ $ $) 6 (|has| $ (|shallowlyMutable|))))
 (|qsetfirst!| ((|#1| $ |#1|) 6 (|has| $ (|shallowlyMutable|))))
 (|parts| (((|List| |#1|) $) 6 (|has| $ (|finiteAggregate|))))
 (|nodes| (((|List| $) $) 6))
 (|node?| (((|Boolean|) $ $) 6 (|has| |#1| (|BasicType|))))
 (|more?| (((|Boolean|) $ (|NonNegativeInteger|)) 6))
 (|min|
  ((|#1| $) 6 (AND (|has| |#1| (|OrderedSet|)) (|has| $ (|finiteAggregate|)))))
 (|members| (((|List| |#1|) $) 6 (|has| $ (|finiteAggregate|))))
 (|member?|
  (((|Boolean|) |#1| $) 6
   (AND (|has| |#1| (|BasicType|)) (|has| $ (|finiteAggregate|)))))
 (|max|
  ((|#1| (|Mapping| (|Boolean|) |#1| |#1|) $) 6 (|has| $ (|finiteAggregate|)))
  ((|#1| $) 6 (AND (|has| |#1| (|OrderedSet|)) (|has| $ (|finiteAggregate|)))))
 (|map!| (($ (|Mapping| |#1| |#1|) $) 6 (|has| $ (|shallowlyMutable|))))
 (|map| (($ (|Mapping| |#1| |#1|) $) 6))
 (|less?| (((|Boolean|) $ (|NonNegativeInteger|)) 6))
 (|leaves| (((|List| |#1|) $) 6)) (|leaf?| (((|Boolean|) $) 6))
 (|latex| (((|String|) $) 6 (|has| |#1| (|SetCategory|))))
 (|last| ((|#1| $) 6) (($ $ (|NonNegativeInteger|)) 6))
 (|hashUpdate!|
  (((|HashState|) (|HashState|) $) 6 (|has| |#1| (|SetCategory|))))
 (|hash| (((|SingleInteger|) $) 6 (|has| |#1| (|SetCategory|))))
 (|first| ((|#1| $) 6) (($ $ (|NonNegativeInteger|)) 6))
 (|every?|
  (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) 6
   (|has| $ (|finiteAggregate|))))
 (|eval|
  (($ $ (|List| (|Equation| |#1|))) 6
   (AND (|has| |#1| (|Evalable| |#1|)) (|has| |#1| (|SetCategory|))))
  (($ $ (|Equation| |#1|)) 6
   (AND (|has| |#1| (|Evalable| |#1|)) (|has| |#1| (|SetCategory|))))
  (($ $ |#1| |#1|) 6
   (AND (|has| |#1| (|Evalable| |#1|)) (|has| |#1| (|SetCategory|))))
  (($ $ (|List| |#1|) (|List| |#1|)) 6
   (AND (|has| |#1| (|Evalable| |#1|)) (|has| |#1| (|SetCategory|)))))
 (|eq?| (((|Boolean|) $ $) 6)) (|empty?| (((|Boolean|) $) 6)) (|empty| (($) 6))
 (|elt| ((|#1| $ #1#) 6) ((|#1| $ "first") 6) (($ $ "rest") 6)
  ((|#1| $ "last") 6))
 (|distance| (((|Integer|) $ $) 6)) (|cyclic?| (((|Boolean|) $) 6))
 (|cycleTail| (($ $) 6))
 (|cycleSplit!| (($ $) 6 (|has| $ (|shallowlyMutable|))))
 (|cycleLength| (((|NonNegativeInteger|) $) 6)) (|cycleEntry| (($ $) 6))
 (|count|
  (((|NonNegativeInteger|) (|Mapping| (|Boolean|) |#1|) $) 6
   (|has| $ (|finiteAggregate|)))
  (((|NonNegativeInteger|) |#1| $) 6
   (AND (|has| |#1| (|BasicType|)) (|has| $ (|finiteAggregate|)))))
 (|copy| (($ $) 6))
 (|concat!| (($ $ $) 6 (|has| $ (|shallowlyMutable|)))
  (($ $ |#1|) 6 (|has| $ (|shallowlyMutable|))))
 (|concat| (($ $ $) 6) (($ |#1| $) 6))
 (|coerce| (((|OutputForm|) $) 6 (|has| |#1| (|CoercibleTo| (|OutputForm|)))))
 (|children| (((|List| $) $) 6))
 (|child?| (((|Boolean|) $ $) 6 (|has| |#1| (|BasicType|))))
 (|any?|
  (((|Boolean|) (|Mapping| (|Boolean|) |#1|) $) 6
   (|has| $ (|finiteAggregate|))))
 (=
  (((|Boolean|) $ $) 6
   (OR (|has| |#1| (|SetCategory|))
       (AND (|has| |#1| (|BasicType|)) (|has| $ (|finiteAggregate|))))))
 (|#| (((|NonNegativeInteger|) $) 6 (|has| $ (|finiteAggregate|)))))
URAGG
(((|RecursiveAggregate| |#1|) . T))
(((|Aggregate|) . T)
 ((|BasicType|) OR (|has| |t#1| (|SetCategory|))
  (AND (|has| $ (|finiteAggregate|)) (|has| |t#1| (|BasicType|))))
 ((|CoercibleTo| (|OutputForm|)) |has| |t#1| (|CoercibleTo| (|OutputForm|)))
 ((|Evalable| |t#1|) AND (|has| |t#1| (|Evalable| |t#1|))
  (|has| |t#1| (|SetCategory|)))
 ((|HomogeneousAggregate| |t#1|) . T)
 ((|InnerEvalable| |t#1| |t#1|) AND (|has| |t#1| (|Evalable| |t#1|))
  (|has| |t#1| (|SetCategory|)))
 ((|RecursiveAggregate| |#1|) . T)
 ((|SetCategory|) |has| |t#1| (|SetCategory|)) ((|Type|) . T))
((|constructor|
  (NIL
   "A unary-recursive aggregate is an aggregate where nodes may have either 0 or 1 children. This aggregate models,{} though not precisely,{} a linked list possibly with a single cycle. A node with one children models a non-empty list,{} with the \\spadfun{value} of the list designating the head,{} or \\spadfun{first},{} of the list,{} and the child designating the tail,{} or \\spadfun{rest},{} of the list. A node with no child then designates the empty list. Since these aggregates are recursive aggregates,{} they may be cyclic."))
 (|split!|
  (($ $ (|NonNegativeInteger|))
   "\\spad{split!(u,{} n)} splits \\spad{u} into two aggregates: \\spad{v = rest(u,{} n)} and \\spad{w = first(u,{} n)},{} returning \\spad{v} and setting \\spad{u} to \\spad{w}. If \\spad{n} is 0,{} split! currently only works for Stream and gives error for List. Note: afterwards \\spad{rest(u,{} n)} returns \\spad{empty()}."))
 (|setlast!|
  ((|#1| $ |#1|)
   "\\spad{setlast!(u,{} x)} destructively changes the last element of \\spad{u} to \\spad{x}. Error if \\spad{u} is empty."))
 (|qsetrest!|
  (($ $ $)
   "\\spad{qsetrest!(u,{} v)} destructively changes the rest of \\spad{u} to \\spad{v} without checking for errors."))
 (|setrest!|
  (($ $ $)
   "\\spad{setrest!(u,{} v)} destructively changes the rest of \\spad{u} to \\spad{v}. Error if \\spad{u} is empty."))
 (|setelt!|
  ((|#1| $ "last" |#1|)
   "\\spad{setelt!(u,{} \"last\",{} x)} (also written: \\spad{u.last := x}) is equivalent to \\spad{setlast!(u,{} x)}.")
  (($ $ "rest" $)
   "\\spad{setelt!(u,{} \"rest\",{} v)} (also written: \\spad{u.rest := v}) is equivalent to \\spad{setrest!(u,{} v)}.")
  ((|#1| $ "first" |#1|)
   "\\spad{setelt!(u,{} \"first\",{} x)} (also written: \\spad{u.first := x}) is equivalent to \\spad{setfirst!(u,{} x)}."))
 (|qsetfirst!|
  ((|#1| $ |#1|)
   "\\spad{qsetfirst!(u,{} x)} destructively changes the first element of \\spad{u} to \\spad{x} without checking for errors."))
 (|setfirst!|
  ((|#1| $ |#1|)
   "\\spad{setfirst!(u,{} x)} destructively changes the first element of \\spad{u} to \\spad{x}. Error if \\spad{u} is empty."))
 (|cycleSplit!|
  (($ $)
   "\\spad{cycleSplit!(u)} splits the aggregate by dropping off the cycle. The value returned is the cycle entry,{} or empty() if none exists. For example,{} if \\spad{w = concat(u,{} v)} is the cyclic list where \\spad{v} is the head of the cycle,{} \\spad{cycleSplit!(w)} will drop \\spad{v} off \\spad{w} thus destructively changing \\spad{w} to \\spad{u},{} and returning \\spad{v}."))
 (|concat!|
  (($ $ |#1|)
   "\\spad{concat!(u,{} x)} destructively adds element \\spad{x} to the end of \\spad{u}. Note: \\spad{concat!(a,{} x) = concat!(a,{} [x])}.")
  (($ $ $)
   "\\spad{concat!(u,{} v)} destructively concatenates \\spad{v} to the end of \\spad{u}."))
 (|cycleTail|
  (($ $)
   "\\spad{cycleTail(u)} returns the last node in the cycle,{} or empty() if none exists."))
 (|cycleLength|
  (((|NonNegativeInteger|) $)
   "\\spad{cycleLength(u)} returns the length of a top-level cycle contained in aggregate \\spad{u},{} or 0 if \\spad{u} has no such cycle."))
 (|cycleEntry|
  (($ $)
   "\\spad{cycleEntry(u)} returns the head of a top-level cycle contained in aggregate \\spad{u},{} or \\spad{empty()} if none exists."))
 (|third|
  ((|#1| $)
   "\\spad{third(u)} returns the third element of \\spad{u}. Note: \\spad{third(u) = first(rest(rest(u)))}."))
 (|second|
  ((|#1| $)
   "\\spad{second(u)} returns the second element of \\spad{u}. Note: \\spad{second(u) = first(rest(u))}."))
 (|tail|
  (($ $)
   "\\spad{tail(u)} returns the last node of \\spad{u}. Error if \\spad{u} is empty."))
 (|last|
  (($ $ (|NonNegativeInteger|))
   "\\spad{last(u,{} n)} returns a copy of the last \\spad{n} nodes of \\spad{u}. Note: \\spad{last(u,{} n)} is a list of \\spad{n} elements.")
  ((|#1| $)
   "\\spad{last(u)} returns the last element of \\spad{u}. Note: for lists,{} \\spad{last(u) = u.(maxIndex u)}."))
 (|rest|
  (($ $ (|NonNegativeInteger|))
   "\\spad{rest(u,{} n)} returns the \\spad{n}th node of \\spad{u}. Note: \\spad{rest(u,{} 0) = u}.")
  (($ $)
   "\\spad{rest(u)} returns an aggregate consisting of all but the first element of \\spad{u} (equivalently,{} the next node of \\spad{u})."))
 (|elt|
  ((|#1| $ "last")
   "\\spad{elt(u,{} \"last\")} (also written: \\spad{u.last}) is equivalent to last(\\spad{u}).")
  (($ $ "rest")
   "\\spad{elt(\\%,{} \"rest\")} (also written: \\spad{u.rest}) is equivalent to \\spad{rest u}.")
  ((|#1| $ "first")
   "\\spad{elt(u,{} \"first\")} (also written: \\spad{u.first}) is equivalent to first(\\spad{u})."))
 (|first|
  (($ $ (|NonNegativeInteger|))
   "\\spad{first(u,{} n)} returns a copy of the first \\spad{n} elements of \\spad{u}.")
  ((|#1| $)
   "\\spad{first(u)} returns the first element of \\spad{u} (equivalently,{} the value at the current node)."))
 (|concat|
  (($ |#1| $)
   "\\spad{concat(x,{} u)} returns aggregate consisting of \\spad{x} followed by the elements of \\spad{u}. Note: if \\spad{v = concat(x,{} u)} then \\spad{x = first v} and \\spad{u = rest v}.")
  (($ $ $)
   "\\spad{concat(u,{} v)} returns an aggregate \\spad{w} consisting of the elements of \\spad{u} followed by the elements of \\spad{v}. Note: \\spad{v = rest(w,{} \\#u)}.")))
(("documentation" 0 10674) ("ancestors" 0 10131) ("parents" 0 10095)
 ("abbreviation" 0 10089) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 6034) ("modemaps" 0 1661) ("sourceFile" 0 1624)
 ("constructorCategory" 0 151) ("constructorModemap" 0 61)
 ("constructorKind" 0 50) ("constructorForm" 0 20))