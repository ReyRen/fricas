)abbrev domain SQMATRIX SquareMatrix
++ Author: Grabmeier, Gschnitzer, Williamson
++ Date Created: 1987
++ Basic Operations:
++ Related Domains: IndexedMatrix, Matrix, RectangularMatrix
++ Also See:
++ AMS Classifications:
++ Keywords: matrix, linear algebra
++ Examples:
++ References:
++ Description:
++   \spadtype{SquareMatrix} is a matrix domain of square matrices, where the
++   number of rows (= number of columns) is a parameter of the type.
SquareMatrix(ndim, R) : Exports == Implementation where
  ndim : NonNegativeInteger
  R    : Join(SemiRng, AbelianMonoid)
  Row ==> DirectProduct(ndim, R)
  Col ==> DirectProduct(ndim, R)
  MATLIN ==> MatrixLinearAlgebraFunctions(R, Row, Col, %)

  Exports ==> Join(SquareMatrixCategory(ndim, R, Row, Col), _
                   CoercibleTo Matrix R) with

    transpose : % -> %
      ++ \spad{transpose(m)} returns the transpose of the matrix m.
    squareMatrix : Matrix R -> %
      ++ \spad{squareMatrix(m)} converts a matrix of type \spadtype{Matrix}
      ++ to a matrix of type \spadtype{SquareMatrix}.
    coerce : % -> Matrix R
      ++ \spad{coerce(m)} converts a matrix of type \spadtype{SquareMatrix}
      ++ to a matrix of type \spadtype{Matrix}.
--  symdecomp : % -> Record(sym: %, antisym: %)
--    ++ \spad{symdecomp(m)} decomposes the matrix m as a sum of a symmetric
--    ++ matrix \spad{m1} and an antisymmetric matrix \spad{m2}. The object
--    ++ returned is the Record \spad{[m1, m2]}
--  if R has CommutativeStar then
--    minorsVect: -> Vector(Union(R,"uncomputed")) --range: 1..2^n-1
--      ++ \spad{minorsVect(m)} returns a vector of the minors of the matrix m
    if R has CommutativeStar and R has unitsKnown then unitsKnown
      ++ the invertible matrices are simply the matrices whose determinants
      ++ are units in the Ring R.
    if R has ConvertibleTo InputForm then ConvertibleTo InputForm

  Implementation ==> Matrix R add
    minr ==> minRowIndex
    maxr ==> maxRowIndex
    minc ==> minColIndex
    maxc ==> maxColIndex
    mini ==> minIndex
    maxi ==> maxIndex

    ZERO := scalarMatrix 0
    0    == ZERO

    if R has Monoid then

        ONE  := scalarMatrix 1
        1    == ONE

    if R has Ring then

        characteristic() == characteristic()$R

    matrix(l : List List R) ==
      -- error check: this is a top level function
      #l ~= ndim => error "matrix: wrong number of rows"
      for ll in l repeat
        #ll ~= ndim => error "matrix: wrong number of columns"
      ans : Matrix R := new(ndim, ndim, 0)
      for i in minr(ans)..maxr(ans) for ll in l repeat
        for j in minc(ans)..maxc(ans) for r in ll repeat
          qsetelt!(ans, i, j, r)
      ans pretend %

    row(x, i)    == directProduct row(x pretend Matrix(R), i)
    column(x, j) == directProduct column(x pretend Matrix(R), j)
    coerce(x : %) : OutputForm == coerce(x pretend Matrix R)$Matrix(R)

    scalarMatrix r == scalarMatrix(ndim, r)$Matrix(R) pretend %

    diagonalMatrix l ==
      #l ~= ndim =>
        error "diagonalMatrix: wrong number of entries in list"
      diagonalMatrix(l)$Matrix(R) pretend %

    coerce(x : %) : Matrix(R) == copy(x pretend Matrix(R))

    squareMatrix x ==
      (nrows(x) ~= ndim) or (ncols(x) ~= ndim) =>
        error "squareMatrix: matrix of bad dimensions"
      copy(x) pretend %

    x : % * v : Col ==
      directProduct((x pretend Matrix(R)) * (v :: Vector(R)))

    v : Row * x : % ==
      directProduct((v :: Vector(R)) * (x pretend Matrix(R)))

    if R has CommutativeRing then

      determinant x == determinant(x pretend Matrix(R))
      minordet x    == minordet(x pretend Matrix(R))
      Pfaffian x    == Pfaffian(x pretend Matrix(R))

    if R has EuclideanDomain then

      rowEchelon x == rowEchelon(x pretend Matrix(R)) pretend %

      columnSpace x ==
          [directProduct c for c in columnSpace(x pretend Matrix R)]

    if R has IntegralDomain then

      rank x    == rank(x pretend Matrix(R))
      nullity x == nullity(x pretend Matrix(R))
      nullSpace x ==
        [directProduct c for c in nullSpace(x pretend Matrix(R))]
      recip(x) ==
          (u := invertIfCan(x pretend Matrix(R))) case "failed" => "failed"
          (u :: Matrix(R)) pretend %

    if R has Field then

      -- dimension() == (m * n) :: CardinalNumber

      inverse x ==
        (u := inverse(x pretend Matrix(R))) case "failed" => "failed"
        (u :: Matrix(R)) pretend %

      x : % ^ n : Integer ==
        ((x pretend Matrix(R)) ^ n) pretend %

      recip x == inverse x

    if R has ConvertibleTo InputForm then
      convert(x : %) : InputForm ==
         convert [convert('squareMatrix)@InputForm,
                  convert(x::Matrix(R))]$List(InputForm)


--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
