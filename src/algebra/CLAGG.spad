)abbrev category CLAGG Collection
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A collection is a homogeneous aggregate which can be built from a
++ list of members. The operation used to build the aggregate is
++ generically named \spadfun{construct}. However, each collection
++ provides its own special function with the same name as the
++ data type, except with an initial lower case letter, e.g.
++ \spadfun{list} for \spadtype{List},
++ \spadfun{flexibleArray} for \spadtype{FlexibleArray}, and so on.
Collection(S : Type) : Category == HomogeneousAggregate(S) with
   construct : List S -> %
     ++ \spad{construct([x, y, ..., z])} returns the collection of elements \spad{x, y, ..., z}
     ++ ordered as given. Equivalently written as \spad{[x, y, ..., z]$D}, where
     ++ D is the domain. D may be omitted for those of type List.
   find : (S -> Boolean, %) -> Union(S, "failed")
     ++ find(p, u) returns the first x in u such that \spad{p(x)} is true, and
     ++ "failed" otherwise.
   if % has finiteAggregate then
      reduce : ((S, S) -> S, %) -> S
        ++ reduce(f, u) reduces the binary operation f across u. For example,
        ++ if u is \spad{[x, y, ..., z]} then \spad{reduce(f, u)} returns \spad{f(..f(f(x, y), ...), z)}.
        ++ Note: if u has one element x, \spad{reduce(f, u)} returns x.
        ++ Error: if u is empty.
      reduce : ((S, S) -> S, %, S) -> S
        ++ reduce(f, u, x) reduces the binary operation f across u, where x is
        ++ the identity operation of f.
        ++ Same as \spad{reduce(f, u)} if u has 2 or more elements.
        ++ Returns \spad{f(y, x)} if u has one element y.
        ++ Returns x if u is empty.
        ++ For example, \spad{reduce(+, u, 0)} returns the
        ++ sum of the elements of u.
      remove : (S -> Boolean, %) -> %
        ++ remove(p, u) returns a copy of u removing all elements x such that
        ++ \spad{p(x)} is true.
        ++ Note: \spad{remove(p, u) = [x for x in u | not p(x)]}.
      select : (S -> Boolean, %) -> %
        ++ select(p, u) returns a copy of u containing only those elements such
        ++ \spad{p(x)} is true.
        ++ Note: \spad{select(p, u) = [x for x in u | p(x)]}.
      if S has BasicType then
        reduce : ((S, S) -> S, %, S, S) -> S
          ++ reduce(f, u, x, z) reduces the binary operation f across u, stopping
          ++ when an "absorbing element" z is encountered.
          ++ As for \spad{reduce(f, u, x)}, x is the identity element of f.
          ++ Same as \spad{reduce(f, u, x)} when u contains no element z.
          ++ Thus the third argument x is returned when u is empty.
        remove : (S, %) -> %
          ++ remove(x, u) returns a copy of u with all
          ++ elements equal to x removed.
          ++ Note: \spad{remove(x, u) = [y for y in u | y ~= x]}.
        removeDuplicates : % -> %
          ++ removeDuplicates(u) returns a copy of u with all duplicates removed.
   if S has ConvertibleTo InputForm then ConvertibleTo InputForm
 add
   if % has finiteAggregate then

       import from List(S)

       find(f : S -> Boolean, c : %) == find(f, parts c)
       reduce(f : (S, S) -> S, x : %) == reduce(f, parts x)
       reduce(f : (S, S) -> S, x : %, s : S) == reduce(f, parts x, s)
       remove(f : S -> Boolean, x : %) ==
           construct remove(f, parts x)
       select(f : S -> Boolean, x : %) ==
           construct select(f, parts x)

       if S has BasicType then
           remove(s : S, x : %) == remove(y +-> y = s, x)
           reduce(f : (S, S) -> S, x : %, s1 : S, s2 : S) ==
               reduce(f, parts x, s1, s2)
           removeDuplicates(x) == construct removeDuplicates parts x

       if S has ConvertibleTo InputForm then

           convert(x : %) : InputForm ==
               p_form : List(InputForm) :=
                   [convert(el)@InputForm for el in parts(x)]
               l_form := cons(convert('construct)@InputForm, p_form)
               a_form := convert(l_form)@InputForm
               packageCall('construct, [a_form])$InputFormFunctions1(%)


