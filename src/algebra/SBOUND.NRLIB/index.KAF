9099                (|SBoundary| PT)
|domain|
(((|SBoundary| |#1|)
  (CATEGORY |domain| (SIGNATURE |nullBoundary| ($))
   (SIGNATURE |boxBoundary| ($ |#1| |#1|))
   (SIGNATURE |ellipseBoundary| ($ |#1| |#1|))
   (SIGNATURE |union| ($ (|List| $))) (SIGNATURE |intersection| ($ (|List| $)))
   (SIGNATURE |sunion| ($ $ $)) (SIGNATURE |extendToPoint| ($ $ |#1|))
   (SIGNATURE |containsPoint?| ((|Boolean|) $ |#1|))
   (SIGNATURE |lineIntersect| (|#1| $ |#1|))
   (SIGNATURE |isNull?| ((|Boolean|) $))
   (SIGNATURE |isEllipse?| ((|Boolean|) $))
   (SIGNATURE |isBox?| ((|Boolean|) $)) (SIGNATURE |getMin| (|#1| $))
   (SIGNATURE |getMax| (|#1| $)) (SIGNATURE |getCentre| (|#1| $))
   (SIGNATURE |link| ((|List| |#1|) $ $))
   (SIGNATURE |coerce| ((|OutputForm|) $)))
  (|SPointCategory|))
 (T |SBoundary|))
(CATEGORY |domain| (SIGNATURE |nullBoundary| ($))
 (SIGNATURE |boxBoundary| ($ |#1| |#1|))
 (SIGNATURE |ellipseBoundary| ($ |#1| |#1|)) (SIGNATURE |union| ($ (|List| $)))
 (SIGNATURE |intersection| ($ (|List| $))) (SIGNATURE |sunion| ($ $ $))
 (SIGNATURE |extendToPoint| ($ $ |#1|))
 (SIGNATURE |containsPoint?| ((|Boolean|) $ |#1|))
 (SIGNATURE |lineIntersect| (|#1| $ |#1|))
 (SIGNATURE |isNull?| ((|Boolean|) $)) (SIGNATURE |isEllipse?| ((|Boolean|) $))
 (SIGNATURE |isBox?| ((|Boolean|) $)) (SIGNATURE |getMin| (|#1| $))
 (SIGNATURE |getMax| (|#1| $)) (SIGNATURE |getCentre| (|#1| $))
 (SIGNATURE |link| ((|List| |#1|) $ $)) (SIGNATURE |coerce| ((|OutputForm|) $)))
"/git/fricas/src/algebra/SBOUND.spad"
((|coerce| (*1 *2 *1)
           (AND (|isDomain| *2 (|OutputForm|)) (|isDomain| *1 (|SBoundary| *3))
                (|ofCategory| *3 (|SPointCategory|))))
 (|link| (*1 *2 *1 *1)
  (AND (|isDomain| *2 (|List| *3)) (|isDomain| *1 (|SBoundary| *3))
       (|ofCategory| *3 (|SPointCategory|))))
 (|getCentre| (*1 *2 *1)
  (AND (|isDomain| *1 (|SBoundary| *2)) (|ofCategory| *2 (|SPointCategory|))))
 (|getMax| (*1 *2 *1)
  (AND (|isDomain| *1 (|SBoundary| *2)) (|ofCategory| *2 (|SPointCategory|))))
 (|getMin| (*1 *2 *1)
  (AND (|isDomain| *1 (|SBoundary| *2)) (|ofCategory| *2 (|SPointCategory|))))
 (|isBox?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SBoundary| *3))
       (|ofCategory| *3 (|SPointCategory|))))
 (|isEllipse?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SBoundary| *3))
       (|ofCategory| *3 (|SPointCategory|))))
 (|isNull?| (*1 *2 *1)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SBoundary| *3))
       (|ofCategory| *3 (|SPointCategory|))))
 (|lineIntersect| (*1 *2 *1 *2)
  (AND (|isDomain| *1 (|SBoundary| *2)) (|ofCategory| *2 (|SPointCategory|))))
 (|containsPoint?| (*1 *2 *1 *3)
  (AND (|isDomain| *2 (|Boolean|)) (|isDomain| *1 (|SBoundary| *3))
       (|ofCategory| *3 (|SPointCategory|))))
 (|extendToPoint| (*1 *1 *1 *2)
  (AND (|isDomain| *1 (|SBoundary| *2)) (|ofCategory| *2 (|SPointCategory|))))
 (|sunion| (*1 *1 *1 *1)
  (AND (|isDomain| *1 (|SBoundary| *2)) (|ofCategory| *2 (|SPointCategory|))))
 (|intersection| (*1 *1 *2)
                 (AND (|isDomain| *2 (|List| (|SBoundary| *3)))
                      (|isDomain| *1 (|SBoundary| *3))
                      (|ofCategory| *3 (|SPointCategory|))))
 (|union| (*1 *1 *2)
          (AND (|isDomain| *2 (|List| (|SBoundary| *3)))
               (|isDomain| *1 (|SBoundary| *3))
               (|ofCategory| *3 (|SPointCategory|))))
 (|ellipseBoundary| (*1 *1 *2 *2)
  (AND (|isDomain| *1 (|SBoundary| *2)) (|ofCategory| *2 (|SPointCategory|))))
 (|boxBoundary| (*1 *1 *2 *2)
  (AND (|isDomain| *1 (|SBoundary| *2)) (|ofCategory| *2 (|SPointCategory|))))
 (|nullBoundary| (*1 *1)
  (AND (|isDomain| *1 (|SBoundary| *2)) (|ofCategory| *2 (|SPointCategory|)))))
((|union| (($ (|List| $)) 14)) (|sunion| (($ $ $) 20)) (|nullBoundary| (($) 8))
 (|link| (((|List| |#1|) $ $) 52)) (|lineIntersect| ((|#1| $ |#1|) 46))
 (|isNull?| (((|Boolean|) $) 47)) (|isEllipse?| (((|Boolean|) $) 30))
 (|isBox?| (((|Boolean|) $) 48)) (|intersection| (($ (|List| $)) 15))
 (|getMin| ((|#1| $) 26)) (|getMax| ((|#1| $) 27)) (|getCentre| ((|#1| $) 50))
 (|extendToPoint| (($ $ |#1|) 25)) (|ellipseBoundary| (($ |#1| |#1|) 12))
 (|containsPoint?| (((|Boolean|) $ |#1|) 29))
 (|coerce| (((|OutputForm|) $) 62)) (|boxBoundary| (($ |#1| |#1|) 11)))
SBOUND
((|constructor|
  (NIL
   "\\indented{1}{SBoundary implements boundaries for use in scene graph} This defines the outer extent of the scene,{} or of an element in the scene,{} or of some branch in the scene. The difference between this boundary and an \\spad{n}-dimensional surface,{} such as IFS,{} is that boundary must always have a well defined inside and an outside. SBoundary does not necessarily follow the exact outer contours of the shape but just constructs a simple boundary shape where all points of the shape are guaranteed to be inside the boundary. Currently there are the following boundary forms: \\indented{1}{Simple types:} \\indented{2}{\"box\"::Symbol which is a \\spad{n}-dimensional axis-aligned rectangle.} \\indented{2}{\"ellipoid\"::Symbol which is a \\spad{n}-dimensional axis-aligned ellipse.} \\indented{1}{Compound types:} \\indented{2}{This is a combination of simple and other compound types such} \\indented{2}{as union or intersection.} \\indented{3}{\"union\"::Symbol represents union of supplied list} \\indented{3}{\"intersection\"::Symbol represents intersection of supplied list} \\indented{1}{Null types:} \\indented{2}{\"none\" is used for a node which does not have a boundary in} \\indented{6}{space,{} for example,{} when the boundary of a material node} \\indented{6}{is requested.} The uses of SBoundary are: 1) So we know how much to scale a given scene to fit in a \\indented{3}{given size.} 2) So that we know where to terminate arrows going in out out of \\indented{3}{of the shape.} 3) To detect if objects intersect (collision detect),{} or if one \\indented{3}{object is contained completely inside another.}"))
 (|coerce|
  (((|OutputForm|) $)
   "\\spad{coerce(bd)} outputs description of \\spad{bd} as formatted text"))
 (|link|
  (((|List| |#1|) $ $)
   "\\spad{link(m,{} n)} returns a line which is the shortest distance between the two boundaries. The line is represented by its two endpoints. \\spad{m:} \\% is the first boundary to be linked \\spad{n:} \\% is the second boundary to be linked"))
 (|getCentre|
  ((|#1| $)
   "\\spad{getCentre(n)} returns centre coordinate of the boundary. \\spad{n:} \\% is the boundary"))
 (|getMax|
  ((|#1| $)
   "\\spad{getMax(n)} returns maximum coordinate of the boundary. \\spad{n} is the boundary"))
 (|getMin|
  ((|#1| $)
   "\\spad{getMin(n)} returns minimum coordinate of the boundary. \\spad{n} is the boundary"))
 (|isBox?|
  (((|Boolean|) $)
   "\\spad{isBox?(n)} returns \\spad{true} if this is a rectangular boundary."))
 (|isEllipse?|
  (((|Boolean|) $)
   "\\spad{isEllipse?(n)} returns \\spad{true} if this is a ellipsoid boundary."))
 (|isNull?|
  (((|Boolean|) $)
   "\\spad{isNull?(n)} returns \\spad{true} if this is a null boundary,{} that is no boundary"))
 (|lineIntersect|
  ((|#1| $ |#1|)
   "\\spad{lineIntersect(n,{} p)} returns the point where a line,{} from the centre of the boundary to the point \\spad{p},{} intersects with the boundary. \\spad{n:} \\% is the boundary \\spad{p:} \\spad{PT} is the point at the end of the line (outside boundary)"))
 (|containsPoint?|
  (((|Boolean|) $ |#1|)
   "\\spad{containsPoint?(n,{} p)} returns \\spad{true} if the point is inside \\indented{2}{the boundary.} \\spad{n} is the boundary \\spad{p} is the point"))
 (|extendToPoint|
  (($ $ |#1|)
   "\\spad{extendToPoint(n,{} p)} creates a boundary that is the union \\indented{2}{of a boundary and a point.} \\spad{n} is the boundary \\spad{p} is the point"))
 (|sunion|
  (($ $ $)
   "\\spad{sunion(x,{} y)} gives the union of two boundaries as a box,{} \\indented{2}{that is it gives a box that is external to both.} \\spad{x:} \\% is first boundary to be combined \\spad{y:} \\% is second boundary to be combined"))
 (|intersection|
  (($ (|List| $))
   "\\spad{intersection(x)} constructs a compound boundary from the intersection of \\spad{x} \\spad{x:} List \\% is supplied list of boundaries to form intersection."))
 (|union|
  (($ (|List| $))
   "\\spad{union(x)} constructs a compound boundary from the union of \\spad{x} \\spad{x:} List \\% is supplied list of boundaries to form union"))
 (|ellipseBoundary|
  (($ |#1| |#1|)
   "\\spad{ellipseBoundary(c1,{} c2)} constructs an ellipse boundary \\spad{n}-dimensional axis-aligned ellipoid with given parameters \\spad{c1:} \\spad{PT} holds centre point \\spad{c2:} \\spad{PT} holds extent (radius for each coordinate)"))
 (|boxBoundary|
  (($ |#1| |#1|)
   "\\spad{boxBoundary(c1,{} c2)} constructs a box boundary (\\spad{n}-dimensional axis-aligned rectangle) with given parameters \\spad{c1:} \\spad{PT} holds minimum coordinates \\spad{c2:} \\spad{PT} holds maximum coordinates"))
 (|nullBoundary|
  (($)
   "\\spad{nullBoundary()} constructs a null boundary,{} for example,{} when the boundary of a material node is requested.")))
(("documentation" 0 4284) ("ancestors" 0 NIL) ("parents" 0 NIL)
 ("abbreviation" 0 4277) ("predicates" 0 NIL) ("superDomain" 0 NIL)
 ("operationAlist" 0 3714) ("modemaps" 0 1513) ("sourceFile" 0 1475)
 ("constructorCategory" 0 805) ("constructorModemap" 0 46)
 ("constructorKind" 0 37) ("constructorForm" 0 20))